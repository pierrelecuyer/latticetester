<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lattice Tester Guide: Background</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js", "TeX/AMSmath.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../latticetester.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Lattice Tester Guide
   &#160;<span id="projectnumber">0.1.0-848</span>
   </div>
   <div id="projectbrief">Software Package For Testing The Uniformity Of Integral Lattices In The Real Space</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "../../search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('../../',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('da/d18/a_intro.html','../../'); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Background </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This page contains a (not so brief) summary of the mathematical concepts used in <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em>.</p>
<p>The library is intended to ease the computation of uniformity measures (also called figures of merit) on lattices in the \(t\)-dimensional the real space \(\mathbb{R}^t\) that are contained in \(\mathbb{Z}^t\). We therefore introduce here exactly what those lattices are and part of the theory behind the implemented algorithms.</p>
<h1><a class="anchor" id="lattices_def"></a>
Lattices on the Integers</h1>
<h2><a class="anchor" id="lattices_def_def"></a>
Definitions</h2>
<p>\(t\)- dimensional <b>lattices</b> in the real space \(\mathbb{R}^t\) are discrete subspaces of the real vector space \(\mathbb{R}^t\) that can be expressed as </p><p class="formulaDsp">
\begin{equation} L_t = \left\{\mathbf{v} = \sum_{j=1}^t z_j\mathbf{v}_j\mid \mbox{ each } z_j\in\mathbb{Z}\right\} = \oplus_{j=1}^t \mathbb{Z} \mathbf{v}_j, \label {eq:lattice} \end{equation}
</p>
<p> where \(t\) is a positive integer, and \(\mathbf{v}_1,\dots,\mathbf{v}_t\) are linearly independent vectors in \(\mathbb{R}^t\) which form a <b>basis</b> of the lattice. The matrix \(\mathbf{V}\), whose \(i\)th row is \(\mathbf{v}_i\), is the corresponding <b>generator matrix</b> of \(L_t\). A comprehensive treatment of such lattices can be found in <b>[mCON99a]</b>. The algorithms implemented in <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> need to be exact most of the time. To work around this limitation, the library only considers lattices with \(\mathbf{v}_1,\dots,\mathbf{v}_t \in \mathbb{Z}^t\). Note that if the basis vectors are in \(\mathbb{Q}^t\) instead of \(\mathbb{Z}^t\) it is possible <b>rescale</b> the lattice by multiplying all the vectors it contains by an integer such that the resulting lattice is in \(\mathbb{Z}^t\). The details of this conversion are left to the user as it is not implemented.</p>
<p>The <b>dual lattice</b> of \(L_t^*\) is defined as </p><p class="formulaDsp">
\[ L_t^* = \{\mathbf{h} \in \mathbb{R}^t \mid \forall \mathbf{v} \in L_t, \mathbf{h}\cdot\mathbf{v} \in \mathbb{Z} \}. \]
</p>
<p> The <b>dual</b> of a given basis \(\mathbf{v}_1,\dots,\mathbf{v}_t\) is the set of vectors \(\mathbf{w}_1,\dots,\mathbf{w}_t\) in \(\mathbb{R}^t\) such that \(\mathbf{v}_i\cdot\mathbf{w}_j = \delta_{ij}\), where \(\delta_{ij}=1\) if \(i=j\), and \(\delta_{ij}=0\) otherwise. It forms a basis of the dual lattice. These \(\mathbf{w}_j\)'s are the columns of the <b>dual basis generator matrix</b> \(\mathbf{W} = \mathbf{V}^{-1}\), the inverse of the generator matrix \(\mathbf{V}\).</p>
<p><em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> stores and manipulates only lattices by storing its basis and, possibly, its dual basis in integer coordinates. If a lattice has an integer basis, its dual is often fractional. This is a problem that is solved by storing a rescaled version of the dual: the <b>m-dual</b> \(mL_t^*\). When using the m-dual, m is chosen so that \(m\mathbf{W}\) is an integer matrix. Such a m usually is defined by the application for which lattices are used. It is the responsibility of the user to find it out. In this software and the documentation, we assume that the appropriate rescaling has already been done and we always work directly with a lattice \(\Lambda_t \subset \mathbb{Z}^t\) and its m-dual \(\Lambda_t^*\subset\mathbb{Z}^t\). The advantage of this framework is that all vector coordinates are integers and easily representable exactly on the computer.</p>
<p>There are a few more usefull definitions needed to understand this software. The determinant of the matrix \(\mathbf{V}\) is equal to the volume of the fundamental parallelepiped \(\{\mathbf{v} = \lambda_1\mathbf{v}_1 + \cdots + \lambda_t\mathbf{v}_t \mid 0\le \lambda_i\le 1\) for \(1\le i\le t\}\). It is independent of the choice of basis and is called the <b>determinant</b> or <b>volume</b> of \(L_t\). The quantity \(n = 1/\det(L_t) = 1/\det(\mathbf{V}) = \det(\mathbf{V}^{-1})\) is called the <b>density</b> of \(L_t\) and it represents the average number of points per unit of volume in the lattice. When \(L_t\) contains \(\mathbb{Z}^t\), the density \(n\) is an integer equal to the cardinality of the point set \(L_t \cap [0,1)^t\).</p>
<p>For a given lattice \(L_t\) and a subset of coordinates \(I = \{i_1,\dots,i_d\} \subseteq \{1,\dots,t\}\), denote by \(L_t(I)\) the projection of \(L_t\) over the \(d\)-dimensional subspace determined by the coordinates in \(I\). This projection is also a lattice, whose density divides that of \(L_t\). There are exactly \(\det(L_t(I))/\det(L_t)\) points of \(L_t\) that are projected onto each point of \(L_t(I)\). In group theory language, \(L_t(I)\) corresponds to a coset of \(L_t\).</p>
<p>A <b>shifted lattice</b> is a lattice \(L_t\) shifted by a constant vector \(\mathbf{v}_0\not\in L_t\), i.e., a point set of the form \(L&#39;_t = \{\mathbf{v}+\mathbf{v}_0 : \mathbf{v} \in L_t\}\), where \(L_t\) is a lattice. The uniformity of a shifted lattices \(L&#39;_t\) can be analyzed by subtracting the shift and analyzing the (unshifted) lattice \(L_t\).</p>
<h2><a class="anchor" id="lattices_def_algo"></a>
Algorithms on lattices</h2>
<p>There are a few algorithms specifically doing lattice manipulations implemented in <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em>. The first is the computation of a diagonal basis for a lattice. Given a lattice basis \(\mathbf{V}\), there always exist a unimodular matrix \(T\) such that </p><p class="formulaDsp">
\begin{equation} T\mathbf{V} = \begin{bmatrix} \hat{v}_{11} &amp; \hat{v}_{12} &amp; \cdots &amp; \hat{v}_{1t} \\ 0 &amp; \hat{v}_{22} &amp; \cdots &amp; \hat{v}_{2t} \\ \vdots &amp; \ddots &amp; \ddots &amp; \vdots \\ 0 &amp; \cdots &amp; 0 &amp; \hat{v}_{tt} \end{bmatrix}. \end{equation}
</p>
<p> Since \(T\) is unimodular, \(T\mathbf{V}\) is still a basis for the lattice \(\Lambda_t\) and can be used in place of \(\mathbf{V}\) to perform computations. Lets note the lines of \(\mathbf{V}\) as <code>V[i]</code> and define the following algorithm: </p><div class="fragment"><div class="line"><span class="keyword">def </span>Euclid(vector1, vector2, i):</div>
<div class="line">  <span class="keywordflow">while</span> vector2[i] != 0:</div>
<div class="line">    int a  = vector1[i]/vector2[i] <span class="comment"># integer division</span></div>
<div class="line">    vector1 = vector1 - a * vector2</div>
<div class="line">    vect tmp = vector2</div>
<div class="line">    vector2 = vector1</div>
<div class="line">    vector1 = tmp</div>
</div><!-- fragment --><p> Then the next algorithm transforms V in a diagonal basis for lattice \(\Lambda_t\): </p><div class="fragment"><div class="line"><span class="keyword">def </span>Diagonalize(V, t):</div>
<div class="line">  <span class="keywordflow">for</span> 1 &lt;= i &lt;= t:</div>
<div class="line">    <span class="keywordflow">for</span> i &lt; j &lt;= t:</div>
<div class="line">      Euclid(V[i], V[j], i)</div>
</div><!-- fragment --><p>Having the preceding algorithm is usefull to compute the m-dual of a lattice. When m is known, it is easy to extrapolate the m-dual from a diagonal basis because the matrix \(m\mathbf{W}\) such that \(\mathbf{V}(m\mathbf{W})^t = m\mathbf{I}\) is a basis to the m-dual. As pointed out in <b>[rCOU96a]</b>, when we know that m is right, every of the divisions in the following algorithm will be integer and the m-dual is easily choosen: </p><div class="fragment"><div class="line"><span class="keyword">def </span>BuildDual(V, W, m):</div>
<div class="line">  W = 0</div>
<div class="line">  Diagonalize(V, V.size())</div>
<div class="line">  <span class="keywordflow">for</span> 1 &lt;= i &lt;= t:</div>
<div class="line">    W[i][i] = m / V[i][i]</div>
<div class="line">  <span class="keywordflow">for</span> 1 &lt;= i &lt;= t:</div>
<div class="line">    <span class="keywordflow">for</span> i &gt; j &gt;= 1:</div>
<div class="line">      <span class="keywordflow">for</span> j+1 &lt;= k &lt;= i:</div>
<div class="line">        W[i][j] -= m * V[j][k] * W[i][k] / V[j][j]</div>
</div><!-- fragment --><h1><a class="anchor" id="sec_merit"></a>
Measures of Uniformity</h1>
<h2><a class="anchor" id="sec_merit_short"></a>
Shortest Nonzero Lattice Vector and Spectral Test</h2>
<p>The euclidian length \(l\) of the shortest non-zero vector in the lattice \(\Lambda_t\) corresponds to the distance between the nearest lattice points. For a given lattice density, having a shorter \(l\) means that the points in the lattice are more tightly packed together on fewer parallel hyperplans, which is undesirable. As counter-intuitive as it seems, it turns out that the uniformity of the points of the lattice is maximized when the length of the shortest vector is maximized. This motivates taking this \(\ell\) as a measure of uniformity, which we want to maximize.</p>
<p>To make a measure of uniformity, we need to rescale the value of \(\ell\) so that it can be compared between different lattices with different densities. To do this, we need to make a parallel between lattices and sphere packings. It is possible to see a lattice as a packing of non-interlapping spheres of radius \(\ell/2\) centered on every lattice point. <b>[mCON99a]</b> provides the theoretical foundation needed to study this packing. It turns out that the proportion of space covered by these spheres is a good indicator of the uniformity of the points: a more even point distribution and a longer \(\ell\) mean that points are at a more even distance, which is preferable if we want an even point distribution.</p>
<p>Using what is available in <b>[mCON99a]</b>, it is also possible to provide bounds on the length \(\ell\). Let \(V_t\) be the volume of a sphere in dimension \(t\). Then the proportion of space taken by spheres of radius \(\ell/2\) centered on each point of the lattice is </p><p class="formulaDsp">
\[\Delta_t = \frac{V_t \ell n}{2^t}.\]
</p>
<p> With this equation it is to rewrite </p><p class="formulaDsp">
\[\ell = 2 \left(\frac{\Delta_t}{V_t n}\right)^{1/t} \leq 2\left(\frac{\Delta_t^*}{V_t n}\right)^{1/t}.\]
</p>
<p> where \(\Delta_t^*\) is a bound on \(\Delta_t\). <b>[mCON99a]</b> provides various values for Hermit constants (<b>[mCON99a]</b>, <b>[mNGU10l]</b>) \(\gamma_t = 4(\Delta_t^*/V_t)^{2/t}\) that <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> uses in subclasses of the <code>Normalizer</code> class to give a bound on \(\ell\) as \(\ell \leq \gamma_t^{1/2} \det(L_t)^{1/t}\).</p>
<p>Using these bounds, it is possible to build <b>figures of merit</b>. Figures of merit are values scaled between 0 and 1 that can be used to easily compare different lattice with different \(n\) with some criterion specified beforehand. <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> does not, however, provide figures of merit by itself so this topic is not covered more in depth here.</p>
<h3><a class="anchor" id="sec_merit_spectral"></a>
The Spectral Test</h3>
<p>The work previously done with \(\Lambda_t\) can also be applied on the shortest non-zero vector of \(\Lambda_t^*\) the m-dual of \(\Lambda_t\). The normalization \(\ell(\Lambda_t^*)/\ell^*\), with the upper bound \(\ell^*\), is called the spectral test and it is a widely used computation to assess the uniformity of a lattice. Geometrically, \(1/\ell(\Lambda_t)\) is the distance between the familly of hyperplans the furter away from each other that cover the points of the lattice. A large value of \(1/\ell(\Lambda_t^*)\) means large empty portions of space without points, this is undesirable when building a uniform lattice. The Spectral Test is a widely used figure of merit on lattices (see <b>[rKNU98a]</b>, <b>[rLEC97c]</b>, <b>[rLEC99b]</b>), especially when researching random number generators.</p>
<p>Finding the shortest non-zero vector is equivalent to the resolution of the following quadratic integer programming problem: </p><p class="formulaDsp">
\begin{align} \text{Minimize } &amp; &amp; \Vert \mathbf{v} \Vert^2 &amp; = \mathbf{v}^\mathbf{t} \mathbf{v} &amp; &amp; \\ \\ \text{Subject to } &amp; &amp; \mathbf{v} &amp; = \sum_{i=1}^t z_i \mathbf{v}_i \\ &amp; &amp; 0 &amp; &lt; \sum_{i=1}^t |z_i|\\ &amp; &amp; &amp; z_i \in \mathbb{Z}. \end{align}
</p>
<p> Solving this problem requires the usage of integer programming and of an algorithm that will ultimately amount to enumerating all the points. There exists a Branch-and-Bound (B&amp;B) procedure that specifically targets this problem first introduced in <b>[rDIE75a]</b>, than improved with <b>[mFIN85a]</b> and presented in <b>[rKNU98a]</b>. It is implemented in <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em>. Just like every B&amp;B algorithm, this algorithm can take up to exponential time in \(t\). To speed up its computation, <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> also provides other reduction algorithms that can be applied beforehand, so that search on the basis can be applied on already short vectors with a much smaller search space.</p>
<p>We first present the 3 reduction algorithms available in <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> before exposing in detail the B&amp;B procedure.</p>
<h2><a class="anchor" id="sec_latred"></a>
Lattice Reduction Algorithms</h2>
<h3><a class="anchor" id="sec_latred_dieter"></a>
Pairwise reduction</h3>
<p>Pairwise reduction (sometimes called Dieter reduction) is a long known heuristic based on the Gram-Schmidt orthogonalization. It was first used on this exact problem by Dieter in <b>[rDIE75a]</b>.</p>
<p>Let first recall and introduce our notation for the Gram-Schmidt orthogonalization. From the basis \(\{\mathbf{v}_1, \ldots, \mathbf{v}_t\}\), we can get an orthogonal basis \(\{\hat{\mathbf{v}}_1, \ldots, \hat{\mathbf{v}}_t\}\) by taking </p><p class="formulaDsp">
\begin{align*} \hat{\mathbf{v}}_1 &amp; = \mathbf{v}_1 \\ \hat{\mathbf{v}}_i &amp; = \mathbf{v}_i - \sum_{j=1}^{i-1} \mu_{ij} \hat{\mathbf{v}}_j,\ 1&lt; i \leq t\\ \mu_{ij} &amp; = \frac{\mathbf{v}_i \cdot \hat{\mathbf{v}}_j}{\hat{\mathbf{v}}_j \cdot \hat{\mathbf{v}}_j},\ 1 \leq j &lt; t,\ i &gt; j \end{align*}
</p>
<p>The heuristic consists in trying to reduce the length of a basis vector \(\mathbf{v}_i\) by subtracting from it \(q\) times another basis vector \(\mathbf{v}_j\), for some integer \(q\) and given indices \(i\not=j\). We want to choose \(q\) as a local minima for \(\Vert \mathbf{v}_i - q \mathbf{v}_j\Vert\). This means that we want </p><p class="formulaDsp">
\begin{equation} \Vert \mathbf{v}_i - (q-1) \mathbf{v}_j \Vert^2 \geq \Vert \mathbf{v}_i - q \mathbf{v}_j \Vert^2 \leq \Vert \mathbf{v}_i - (q+1) \mathbf{v}_j\Vert^2 \\ \mathbf{v}_j \cdot \mathbf{v}_j + 2(\mathbf{v}_i - q \mathbf{v}_j) \cdot \mathbf{v}_j \geq 0 \leq \mathbf{v}_j \cdot \mathbf{v}_j - 2(\mathbf{v}_i - q \mathbf{v}_j) \cdot \mathbf{v}_j \\ -\mathbf{v}_j \cdot \mathbf{v}_j \leq 2(\mathbf{v}_i - q \mathbf{v}_j) \cdot \mathbf{v}_j \leq \mathbf{v}_j \cdot \mathbf{v}_j \\ -\frac{1}{2} + \frac{\mathbf{v}_i \cdot \mathbf{v}_j}{\mathbf{v}_j\cdot\mathbf{v}_j} \leq q \leq \frac{1}{2} + \frac{\mathbf{v}_i \cdot \mathbf{v}_j}{\mathbf{v}_j\cdot\mathbf{v}_j} \end{equation}
</p>
<p> The last line means that \(q = \lfloor1/2 + \frac{\mathbf{v}_i \cdot \mathbf{v}_j}{\mathbf{v}_j\cdot \mathbf{v}_j}\rfloor\) is a suitable integer solution to the problem. By taking this \(q\) we also get that \(\Vert \mathbf{v}_i - q \mathbf{v}_j \Vert &lt;= \Vert \mathbf{v}_i \Vert\).</p>
<p>Pairwise reduction can then be written as the following algorithm with <code>V[i]</code>, \(t\)-dimensional vectors that are the rows of a matrix: </p><div class="fragment"><div class="line"><span class="keyword">def </span>Pairwise(V, t):</div>
<div class="line">  int i = 0</div>
<div class="line">  int k = 0</div>
<div class="line">  <span class="keywordflow">while</span> i &lt; t:</div>
<div class="line">   vector old = V[k]</div>
<div class="line">   <span class="keywordflow">for</span> 0 &lt;= j &lt; t:</div>
<div class="line">     <span class="keywordflow">if</span> j != k:</div>
<div class="line">       int q = (V[k] * V[j]) / (V[j] * V[j])</div>
<div class="line">       V[k] = V[k] - q * V[j]</div>
<div class="line">   <span class="keywordflow">if</span> old == V[k]:</div>
<div class="line">     i += 1</div>
<div class="line">   <span class="keywordflow">else</span>:</div>
<div class="line">     i = 0</div>
<div class="line">   k += 1</div>
</div><!-- fragment --><p>Since the algorithm is garanteed to reduce the vector length whenever it modifies a vector, it is also garanteed to stop at one point because there is minimal attainable length.</p>
<p>As noted by Dieter, pairwise reductions can also be applied conjointly on the primal and dual basis. The idea is simply to make it so that every time a vector is modified, the other basis is changed accordingly so that \(\mathbf{V}\mathbf{W} = mI\) at all times. More details are available in <b>[rDIE75a]</b>.</p>
<h3><a class="anchor" id="sec_latred_lll"></a>
Lenstra-Lenstra-Lovasz reduction</h3>
<p>Lenstra, Lenstra, and Lovasz <b>[mLEN82a]</b> have proposed a popular form of lattice basis reduction known as <b>LLL reduction</b>. Our software implements or uses (via a library implementation) a slightly modified version of this algorithm presented in <b>[mSCH91a]</b>.</p>
<p>For \(1/4 \leq \delta &lt; 1\) (usually close to 1), we say that a basis is \(\delta\)-LLL reduced if</p><ol type="1">
<li>\( |\mu_{ij}| \leq 1/2 \) for \(1 \leq j &lt; i \leq t\) ;</li>
<li>\(\delta \leq \frac{\Vert \hat{\mathbf{v}}_{i+1} + \mu_{i+1\,i} \hat{\mathbf{v}}_i \Vert^2}{\Vert \hat{\mathbf{v}}_i\Vert^2}\), for \(0 &lt; i \leq t-1 \).</li>
</ol>
<p>As stated by Victor Shoup in the <a href="https://www.shoup.net/ntl/doc/LLL.cpp.html">NTL documentation</a>, The conditions that the vectors respect when reduced with the LLL algorithm do not have a clear geometric meaning, but a \(\delta\)-LLL reduced basis with its vectors \(\{\mathbf{v}_1, \ldots, \mathbf{v}_t\}\) ordered by length satisfies the following: </p><p class="formulaDsp">
\[ (\delta-1/4)^{i-1} \leq \Vert\mathbf{v}_i\Vert^2 \lambda_i^{-2} \leq (\delta-1/4)^{1-t},\ 1 \leq i \leq t \]
</p>
<p> with \(\lambda_i\) the \(i\)-th shortest non-zero vector in the lattice. This condition gives a relatively tight bound on the shortest vector in the basis after the \(\delta\)-LLL reduction. This vector is often much shorter than the one obtained with pairwise reduction and yields a faster B&amp;B. It is also notable that, in large dimensions for which the B&amp;B is impractical, this short vector can be used as an approximation of the shortest non-zero vector in the lattice.</p>
<p>Schnorr and Euchner give the following algorithm for \(\delta\)-LLL reduction that is used in <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> on a lattice basis in matrix <code>V</code>, 1/2 &lt; <code>delta</code> &lt; 1 and <code>prec</code> the number of bits in the floating point arithmetic: </p><div class="fragment"><div class="line"><span class="keyword">def </span><a class="code" href="../../d8/d74/namespaceLatticeTester.html#af2a213e64bd54d3e33a7aff0f80068cba8d04551154f945a747c129cdabff4af5">LLL</a>(V, t, delta, prec):</div>
<div class="line">  <span class="comment"># Value initialization</span></div>
<div class="line">  int k = 1</div>
<div class="line">  bool Fc = false</div>
<div class="line">  float matrix V<span class="stringliteral">&#39; = V</span></div>
<div class="line"><span class="stringliteral">  float vector c </span><span class="comment"># Vector of dimension t</span></div>
<div class="line">  float s</div>
<div class="line">  float matrix mu <span class="comment"># Gram-Schmidt coefficients</span></div>
<div class="line">  <span class="keywordflow">while</span> k &lt; t:</div>
<div class="line">    c[k] = V<span class="stringliteral">&#39;[k]*V&#39;</span>[k]</div>
<div class="line">    <span class="keywordflow">if</span> k == 1:</div>
<div class="line">      c[0] = V<span class="stringliteral">&#39;[0]*V&#39;</span>[0]</div>
<div class="line">    <span class="keywordflow">for</span> 0 &lt;= j &lt; k-1:</div>
<div class="line">      <span class="keywordflow">if</span> |V<span class="stringliteral">&#39;[k]*V&#39;</span>[j]| &lt; 2^(-prec/2) * sqrt((V<span class="stringliteral">&#39;[k]*V&#39;</span>[k])*(V<span class="stringliteral">&#39;[j]*V&#39;</span>[j])):</div>
<div class="line">        s = float(V[k]*V[j])</div>
<div class="line">      <span class="keywordflow">else</span>:</div>
<div class="line">        s = V<span class="stringliteral">&#39;[k]*V&#39;</span>[j]</div>
<div class="line">      mu[k,j] = s</div>
<div class="line">      <span class="keywordflow">for</span> 0 &lt;= i &lt; j-1:</div>
<div class="line">        mu[k,j] -= mu[j,i]*mu[ki]*c[i]</div>
<div class="line">      mu[k,j] /= c[j]</div>
<div class="line">      c[k] = c[k] - mu[k,j] * mu[k,j] * c[j]</div>
<div class="line">    <span class="keywordflow">for</span> k-1 &gt; j &gt; 1:</div>
<div class="line">      int mu = mu[k,j]</div>
<div class="line">      <span class="keywordflow">if</span> |mu[k,j]| &gt; 0.5:</div>
<div class="line">        <span class="keywordflow">if</span> |mu| &gt; 2^(prec/2):</div>
<div class="line">          Fc = true</div>
<div class="line">        <span class="keywordflow">for</span> 0 &lt;= i &lt; j-1:</div>
<div class="line">          mu[k,i] = mu[k,i] - mu * mu[j,i]</div>
<div class="line">        mu[k,j] = m8[k,j] - mu</div>
<div class="line">        V[k] = V[k] - mu * b[j]</div>
<div class="line">        V<span class="stringliteral">&#39;[k] = float(V[k])</span></div>
<div class="line"><span class="stringliteral">     </span><span class="keywordflow">if</span> Fc:</div>
<div class="line">       Fc = false</div>
<div class="line">       k = max(k-1,1)</div>
<div class="line">       <span class="keywordflow">break</span></div>
<div class="line">     <span class="keywordflow">if</span> delta * c[k-1] &gt; c[k] + mu[k,k-1] * mu[k,k-1]c[k-1]:</div>
<div class="line">       temp = V[k]</div>
<div class="line">       V[k] = V[k-1]</div>
<div class="line">       V[k-1] = temp</div>
<div class="line">       temp = V<span class="stringliteral">&#39;[k]</span></div>
<div class="line"><span class="stringliteral">       V&#39;[k] = V&#39;</span>[k-1]</div>
<div class="line">       V<span class="stringliteral">&#39;[k-1] = temp</span></div>
<div class="line"><span class="stringliteral">       k = max(k-1, 1)</span></div>
<div class="line"><span class="stringliteral">     </span><span class="keywordflow">else</span>:</div>
<div class="line">       k = k+1</div>
<div class="ttc" id="anamespaceLatticeTester_html_af2a213e64bd54d3e33a7aff0f80068cba8d04551154f945a747c129cdabff4af5"><div class="ttname"><a href="../../d8/d74/namespaceLatticeTester.html#af2a213e64bd54d3e33a7aff0f80068cba8d04551154f945a747c129cdabff4af5">LatticeTester::LLL</a></div><div class="ttdeci">@ LLL</div><div class="ttdef"><b>Definition:</b> EnumTypes.h:145</div></div>
</div><!-- fragment --><p>This algorithm performs in polynomial time and usually does not suffer from precision problems that may arise from the usage of floating point numbers.</p>
<h3><a class="anchor" id="sec_latred_bkz"></a>
Block Korkine-Zolotarev Reduction</h3>
<p>The final reduction algorithm available in <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> is the Block Korkine-Zolotarev (BKZ) reduction. The objective of this reduction algorithm is to provide a generalization of the previous LLL algorithm that gives stronger bounds on the results. As it is, the LLL algorithm only considers a condition on basis vectors two at a time. BKZ however generalizes LLL by changing the condition 2 to: </p><p class="formulaDsp">
\[ \delta \Vert \hat{\mathbf{v}}_i \Vert^2 \leq \lambda_1(L^i(\mathbf{v}_1, \ldots, \mathbf{v}_{\min(i+\beta-1, t)}))^2,\ 1 \leq i \leq t-1. \]
</p>
<p> where \(2 \leq \beta &lt; t\) is called a block size, \(\lambda_1(L)\) is the shortest vector in lattice \(L\) and \(L_i(b_1, \ldots, b_n)\) is the projection of \(\{b_1,\ldots, b_n\}\) on \(\{\mathbf{v}_1, \ldots, \mathbf{v}_{i-1}\}\), which is a lattice of rank \(t-i+1\). A lattice respecting this condition and the condition 1 of \(\delta\)-LLL reduction is called \(\delta\)-BKZ with block size \(\beta\).</p>
<p>BKZ reduction has been introduced in <b>[mSCH87a]</b> and perfected to use a variable precision in <b>[mSCH91a]</b>. It turns out that BKZ reduction gives tighter bounds on the shortest obtained vector in the reduced basis: provided that \(\beta-1\) divides \(t-1\) theorem 2.3 in <b>[mSCH87a]</b> gives </p><p class="formulaDsp">
\[ \lambda_1(L_t)^2 \leq \Vert \mathbf{v}_1 \Vert^2 \leq \alpha_\beta^{(t-1)/(\beta-1)} \lambda_1(L_t)^2 \]
</p>
<p> as a bound on the first vector in the basis. Note that \(\alpha_\beta\) is a constant with \(\alpha_2 = \frac{4}{3}\) and generally \(\alpha_\beta \leq \beta^{1+\ln\beta}\). This implies that \(1 &lt; \alpha_\beta^{1/(\beta-1)} \rightarrow 1\) as \(\beta\) increases. This is better than what can be achieved with LLL, which is </p><p class="formulaDsp">
\[ \lambda_1(L_t)^2 \leq \Vert \mathbf{v}_1 \Vert^2 \leq \frac{4}{3}^{t-1} \lambda_1(L_t)^2. \]
</p>
<p> Note that, in reality, these bounds differ a little from this theory since the implemented algorithms use the floating point versions \(\delta\)-LLL and \(\delta\)-BKZ for efficiency.</p>
<p><em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> does not provide an implementation for the BKZ reduction algorithm and relies on the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> library to perform it. We therefore do not provide pseudo-code of this algorithm.</p>
<h3><a class="anchor" id="sec_latred_precision"></a>
A Quick Note on Precision</h3>
<p>The previous sections could have been confusing because there are many variants to the presented algorithms. This is because the two algorithms cannot generally be performed in polynomial time, but weakening their conditions with the \(\delta\) factor gives way better bounds on execution times. <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> implements and uses these weakened versions. Some theory that does not concern those versions is presented for comparison purposes only.</p>
<h2><a class="anchor" id="sec_svp"></a>
Shortest Vector Computation</h2>
<p>We now address the problem of computing a shortest nonzero vector with length \(\ell\) in the lattice \(\Lambda_t\). This problem amounts to finding integers \(z_1,\dots,z_t\), not all zero, such that the vector \(\mathbf{v} = z_1 \mathbf{v}_1 + \cdots + z_t \mathbf{v}_t\) is as short as possible. Trying all combinations for those \(z_j\)'s is definitely not an efficient option. For the Euclidean norm, we formulate this problem as a quadratic integer programming (optimization) problem with decision variables \(z_1,\dots, z_t\), and show how to solve it by a branch-and-bound (BB) procedure. Following the ideas of <b>[rDIE75a]</b> <b>[mFIN85a]</b>, we get the formulation we eluded to before: </p><p class="formulaDsp">
\begin{align} \text{Minimize } &amp; &amp; \Vert \mathbf{v} \Vert^2 &amp; = \mathbf{v}^\mathbf{t} \mathbf{v} &amp; &amp; \\ \\ \text{Subject to } &amp; &amp; \mathbf{v} &amp; = \sum_{i=1}^t z_i \mathbf{v}_i \\ &amp; &amp; 0 &amp; &lt; \sum_{i=1}^t |z_i|\\ &amp; &amp; &amp; z_i \in \mathbb{Z}. \end{align}
</p>
<p>Suppose that the basis vectors \(\mathbf{v}_1,\dots,\mathbf{v}_t\) are ordered by increasing length and that our best solution so far is the vector \(\mathbf{v}_1\), with square length \(\hat{\ell} = \mathbf{v}&#39;_1 \mathbf{v}_1\). This \(\hat{\ell}\) is an upper bound on the length \(\ell\) of a shortest vector.</p>
<p>In the B&amp;B algorithm, we fix successively \(z_t\), then \(z_{t-1}\), then \(z_{t-2}\), down to fixing \(z_1\). Without any more constraints, this yields an (possibly infinite) exponentially growing tree. To avoid this, at each step, for any fixed values of \(z_t,\dots,z_{j+1}\), we compute a finite range (interval) of values of \(z_j\) such that all values outside that range cannot lead to a better solution than \(\hat{\ell}\). All These values will be tested to verify that there is no possible shorter vector than the one we currently know. When a shorter vector is found, \(\mathbf{v}_1\) is changed to that new vector and the search continues. The search ends when all combinations of \(z_j\) inside the intervals have been tested.</p>
<p>Computing an interval for \(z_j\) is the main challenge of this problem. We present the approach of <b>[mAFF85a]</b> to get this interval. This is what is implemented in <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em>.</p>
<p>At the beginning of the B&amp;B procedure, as in <b>[rAFF85a]</b> <b>[mFIN85a]</b> <b>[rGRO88a]</b> <b>[mPOH81a]</b>, we compute a Cholesky decomposition <b>[mGOL89a]</b> of the matrix of scalar products of basis vectors \(\mathbf{V}\mathbf{V}^t\) which always is positive-definite: </p><p class="formulaDsp">
\[ \mathbf{V} \mathbf{V}^t = \mathbf{U}^t \mathbf{U} \]
</p>
<p> where \(\mathbf{U}\) is an upper triangular matrix: </p><p class="formulaDsp">
\[ \mathbf{U} = \begin{pmatrix} u_{11} &amp; \ldots &amp; u_{1t} \\\ \vdots &amp; \ddots &amp;\vdots \\\ \mathbf{0} &amp; \ldots &amp; u_{tt} \end{pmatrix} \]
</p>
<p>Now, if \(\mathbf{z} = (z_1,\dots,z_t)\), we have a shortest vector candidate \(\mathbf{v} = \mathbf{V}^t\mathbf{z}^t\). Note \(r_j = \sum_{k=j+1}^t u_{jk} z_k\), and \(s_j = \sum_{k=j+1}^t \left(\sum_{l=k}^t u_{kl} z_l\right)^2\), then we have <b>[rAFF85a]</b> <b>[mFIN85a]</b> <b>[mPOH81a]</b> :</p>
<p class="formulaDsp">
\begin{eqnarray*} \mathbf{v}^t\mathbf{v} &amp;=&amp; \mathbf{z}\mathbf{V} \mathbf{V}^t \mathbf{z}^t = \mathbf{z}\mathbf{U}^t \mathbf{U} \mathbf{z}^t = \sum_{k=1}^t \left(\sum_{l=k}^t u_{kl} z_l\right)^2 \\\\ &amp;\ge&amp; \left( u_{jj} z_j + \sum_{l=j+1}^t u_{jl} z_l\right)^2 + \sum_{k=j+1}^t \left(\sum_{l=k}^t u_{kl} z_l\right)^2 \\\\ &amp;=&amp; (u_{jj} z_j + r_j)^2 + s_{j} \quad = \; s_{j-1}. \end{eqnarray*}
</p>
<p>A better solution must satisfy \(\mathbf{v}^t\mathbf{v} &lt; \mathbf{v}_1^t \mathbf{v}_1\), which implies \((u_{jj} z_j + r_j)^2 + s_j &lt; \mathbf{v}_1^\mathbf{t} \mathbf{v}_1\). centering the inequalities around \(z_j\) gives the following bounds </p><p class="formulaDsp">
\[ \left\lceil {-(\mathbf{v}_1^\mathbf{t} \mathbf{v}_1-s_j)^{1/2} - r_j\over u_{jj}}\right\rceil \;\le z_j\le\; \left\lfloor {(\mathbf{v}_1^\mathbf{t} \mathbf{v}_1-s_j)^{1/2} - r_j\over u_{jj}}\right\rfloor. \tag{bounds} \]
</p>
<p>Note that to obtain these bounds, the knowledge of \(z_t,\dots,z_j\) is needed and that this strategy uses the continuous relaxation of the original problem. Finding and applying those bounds is a cutting plane method. The numbers obtained mean that the possible values of \(z_j\) to find a shorter vector in the lattice are in the interval. We can restrict ourselves to the integers that lie in that interval when branching from the node \(\{z_t,\dots, z_j\}\). Note that \(s_t = r_t = 0\), so at the beginning the bounds on \(z_t\) are given by \(z_t^2 \le \mathbf{v}_1^\mathbf{t} \mathbf{v}_1\).</p>
<p>The algorithm explores a B&amp;B tree in which each node corresponds to a partial solution \((z_t,\dots,z_{j})\). This node has a child \((z_t,\dots,z_{j},z_{j-1})\) for each value of \(z_j\) that satisfies the bounds and the root has a child for each \(z_t\) such that \(z_t^2 \le \mathbf{v}_1^\mathbf{t} \mathbf{v}_1\). When no \(z_j\) satisfies the bounds (when the interval is empty) the corresponding node has no child and the branch is a dead end. When we reach a tree leaf that represents a full admissible solution \((z_t,\dots,z_1)\), we have just found a shorter vector \(\mathbf{v}\) than our current shortest vector \(\mathbf{v}_1\). We can then update the basis in a way that it contains \(\mathbf{v}\) as its new \(\mathbf{v}_1\), and change the other vectors in a way that they still form a basis of our lattice.</p>
<p>More specifically (without repeating the computations above) the B&amp;B algorithm of <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> is the following, using <code>V</code> a lattice generator matrix with vectors ordered by length, <code>t</code> the dimension, <code>z</code> a candidate for the last <code>h</code> values of \(z\). </p><div class="fragment"><div class="line"><span class="keyword">def </span>B&amp;B(V, t, z, h):</div>
<div class="line">  <span class="keywordflow">if</span> h == t:</div>
<div class="line">    int i = 0</div>
<div class="line">    <span class="keywordflow">while</span> z[i] == 0:</div>
<div class="line">      i++</div>
<div class="line">    V[i] += (z[i]-1)*V[i]</div>
<div class="line">    <span class="keywordflow">for</span> i &lt; j &lt; t:</div>
<div class="line">      V[i] += z[j]*V[j]</div>
<div class="line">    Sort(V)</div>
<div class="line">    <span class="keywordflow">return</span> true</div>
<div class="line">  int min, max = GetBounds(V, t, z, h)</div>
<div class="line">  <span class="keywordflow">if</span> max &lt; min:</div>
<div class="line">    <span class="comment"># There is no possible child</span></div>
<div class="line">    <span class="keywordflow">return</span> false</div>
<div class="line">  i = min</div>
<div class="line">  <span class="keywordflow">while</span> min &lt;= i &lt;= max:</div>
<div class="line">    <span class="keywordflow">if</span> h = t-1</div>
<div class="line">      <span class="comment"># Avoid the null vector</span></div>
<div class="line">      vector v = 0</div>
<div class="line">      <span class="keywordflow">for</span> 0 &lt;= j &lt; t:</div>
<div class="line">        v += z[j]*V[j]</div>
<div class="line">      <span class="keywordflow">if</span> v == 0:</div>
<div class="line">        <span class="keywordflow">continue</span></div>
<div class="line">    <span class="keywordflow">if</span> h == 0 <span class="keywordflow">and</span> i &lt; 0:</div>
<div class="line">      <span class="comment"># -v and v are in the lattice and have the same length</span></div>
<div class="line">      <span class="keywordflow">continue</span></div>
<div class="line">    <span class="keywordflow">if</span> B&amp;B(V, t, (i,z), h+1):</div>
<div class="line">      <span class="comment"># We found a shorter vector</span></div>
<div class="line">      <span class="keywordflow">if</span> h &gt; 0:</div>
<div class="line">        <span class="comment"># Updating the whole tree, getting back to the root</span></div>
<div class="line">        <span class="keywordflow">return</span> true</div>
<div class="line">      min, max = GetBounds(V, t, z, h)</div>
<div class="line">      i = min</div>
<div class="line">      <span class="keywordflow">continue</span></div>
<div class="line">    i += 1</div>
<div class="line">  <span class="keywordflow">return</span> false</div>
</div><!-- fragment --><p> To call this function, one would use the generator matrix for <code>V</code>, \(t\) as <code>t</code>, an empty vector as <code>z</code> and <code>h=0</code>. This assumes that GetBounds returns the lower and upper bounds as above and that Sort sorts the vectors in V such that <code>||V[i]|| &lt; ||V[j]||</code> if <code>0 &lt;= i &lt; j &lt; t</code>.</p>
<p>This algorithm stops when every node in the tree returns false. This means that there is no combination of \(z_j\) that yields a shorter vector for the lattice than the current <code>V[0]</code> and that this <code>V[0]</code> therefore is the shortest non-zero vector in the lattice. Note that this can use a <code>static</code> computation of the Choleski decomposition that is only updated when <code>V</code> changes or when the function is called for the first time. This would reduce the computing time dramatically. Although this does not change the exactitude of the algorithm, surveying \(z\)'s is a different order in the <code>while</code> loop can shorten the execution time. We use <code>i = (min+max)/2</code> first, then <code>i = (min+max)/2±1</code>, <code>i = (min+max)/2±2</code>, ... which we experimentally determined to be the fastest way to get to a solution leaf that improves the current shortest vector (note that this is not exactly what is in the pseudo-code to make it more readable). Finally, since finding a new shorter vector can consequently reduce the size of the tree by giving way better cuts, each time the length of the vector is shortened, we go back to the root of the tree.</p>
<p>The total time taken by this B&amp;B algorithm is roughly proportional to the number of tree nodes visited. One major drawback is that in the worst case, this number of nodes typically grows exponentially with the dimension. It is therefore important to reduce this number as much possible. It helps to start with a basis in which \(\mathbf{v}_1\) is shorter. This shortens the search interval determined by the bounds at each level \(j\), and can greatly reduce the number of nodes that must be examined. The lattice reduction algorithms presented above (<a class="el" href="../../da/d18/a_intro.html#sec_latred">Lattice Reduction Algorithms</a>) are part of <em><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></em> to overcome this difficulty. For the same reason, it also helps it we quickly find a tree leaf that corresponds to an improved solution, because it can reduce the size of the tree.</p>
<p>Observe that if \(\mathbf{v} = \mathbf{z}\mathbf{V}\) is a lattice vector, \(-\mathbf{v} = (-\mathbf{z})\mathbf{V}\) is also a lattice vector with the same norm. We can exploit this symmetry to cut the BB tree in half, simply by considering only non-negative values of \(z_t\). We can do that because any vector \(\mathbf{z}\) with \(z_t &lt; 0\) has an equivalent vector \(-\mathbf{z}\) having \(z_t &gt; 0\). </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <a href="https://github.com/umontreal-simul/latticetester">Available on Github</a>
    <li class="footer">Generated on Sat Oct 26 2024 07:35:01 for Lattice Tester Guide by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.9.1 </li>
  </ul>
</div>
</body>
</html>
