<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.14.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lattice Tester Online Documentation: LatticeTester Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../latticetester.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lattice Tester Online Documentation<span id="projectnumber">&#160;unknown</span>
   </div>
   <div id="projectbrief">Software Package For Testing The Uniformity Of Integral Lattices In The Real Space</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.14.0 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
</script>
<script type="text/javascript">
$(function() { codefold.init(); });
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(function(){initNavTree('d8/d74/namespaceLatticeTester.html','../../',''); });
</script>
<div id="container">
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="headertitle"><div class="title">LatticeTester Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a> namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-namespaces" class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:CoordinateSets" id="r_CoordinateSets"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6f/namespaceLatticeTester_1_1CoordinateSets.html">CoordinateSets</a></td></tr>
<tr class="memdesc:d0/d6f/namespaceLatticeTester_1_1CoordinateSets"><td class="mdescLeft">&#160;</td><td class="mdescRight">The classes <span class="tt">FromRange</span>, <span class="tt">SubSets</span>, and <span class="tt"><a class="el" href="../../d7/d31/classLatticeTester_1_1CoordinateSets_1_1AddCoordinate.html" title="This template class wraps any implementation of a CoordinateSets and adds a specific coordinate to ea...">AddCoordinate</a></span> are defined here. <br /></td></tr>
<tr class="memitem:Random" id="r_Random"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dfe/namespaceLatticeTester_1_1Random.html">Random</a></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-nested-classes" class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:Chrono" id="r_Chrono"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d32/classLatticeTester_1_1Chrono.html">Chrono</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides <span class="tt"><a class="el" href="../../d9/d32/classLatticeTester_1_1Chrono.html" title="This class provides Chrono objects that act as stopwatches that use the system clock to compute the C...">Chrono</a></span> objects that act as stopwatches that use the system clock to compute the CPU time used by parts of a program.  <a href="../../d9/d32/classLatticeTester_1_1Chrono.html#details">More...</a><br /></td></tr>
<tr class="memitem:Coordinates" id="r_Coordinates"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An object type that contains a set of coordinate indices, used to specify a projection.  <a href="../../d9/dd3/classLatticeTester_1_1Coordinates.html#details">More...</a><br /></td></tr>
<tr class="memitem:FigureOfMeritDualM" id="r_FigureOfMeritDualM"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/ddf/classLatticeTester_1_1FigureOfMeritDualM.html">FigureOfMeritDualM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class offers tools to calculate the same figure of merit (FOM) as <span class="tt">FigureOfMerit</span>, but for the m-duals of the projections.  <a href="../../d4/ddf/classLatticeTester_1_1FigureOfMeritDualM.html#details">More...</a><br /></td></tr>
<tr class="memitem:FigureOfMeritM" id="r_FigureOfMeritM"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dca/classLatticeTester_1_1FigureOfMeritM.html">FigureOfMeritM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides tools to calculate the <em>figure of merit</em> (FOM)  <a href="../../d7/dca/classLatticeTester_1_1FigureOfMeritM.html#details">More...</a><br /></td></tr>
<tr class="memitem:IntLattice" id="r_IntLattice"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html">IntLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <span class="tt"><a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html" title="An IntLattice object is an integral lattice, with its basis or its m-dual basis, or both.">IntLattice</a></span> object is an integral lattice, with its basis or its <span class="tt">m</span>-dual basis, or both.  <a href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#details">More...</a><br /></td></tr>
<tr class="memitem:IntLatticeExt" id="r_IntLatticeExt"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d6c/classLatticeTester_1_1IntLatticeExt.html">IntLatticeExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class extends <span class="tt"><a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html" title="An IntLattice object is an integral lattice, with its basis or its m-dual basis, or both.">IntLattice</a></span> with additional (virtual) methods that must be implemented in subclasses that define specific types of lattices.  <a href="../../d8/d6c/classLatticeTester_1_1IntLatticeExt.html#details">More...</a><br /></td></tr>
<tr class="memitem:NormaBestLat" id="r_NormaBestLat"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d24/classLatticeTester_1_1NormaBestLat.html">NormaBestLat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="../../d0/dc8/classLatticeTester_1_1Normalizer.html" title="This is a base class for implementing normalization constants used in figures of merit,...">Normalizer</a> class implements approximate upper bounds on the length of the shortest nonzero vector in a lattice.  <a href="../../d1/d24/classLatticeTester_1_1NormaBestLat.html#details">More...</a><br /></td></tr>
<tr class="memitem:NormaBestUpBound" id="r_NormaBestUpBound"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d61/classLatticeTester_1_1NormaBestUpBound.html">NormaBestUpBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In this normalizer, the Hermite constants \(\gamma_s\) are approximated using the best upper bounds that are available.  <a href="../../d2/d61/classLatticeTester_1_1NormaBestUpBound.html#details">More...</a><br /></td></tr>
<tr class="memitem:NormaLaminated" id="r_NormaLaminated"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d0f/classLatticeTester_1_1NormaLaminated.html">NormaLaminated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="../../d0/dc8/classLatticeTester_1_1Normalizer.html" title="This is a base class for implementing normalization constants used in figures of merit,...">Normalizer</a> class implements approximate upper bounds on the length of the shortest nonzero vector in a lattice.  <a href="../../dd/d0f/classLatticeTester_1_1NormaLaminated.html#details">More...</a><br /></td></tr>
<tr class="memitem:Normalizer" id="r_Normalizer"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc8/classLatticeTester_1_1Normalizer.html">Normalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a base class for implementing normalization constants used in figures of merit, to normalize the length of the shortest nonzero vector in either the primal or dual lattice.  <a href="../../d0/dc8/classLatticeTester_1_1Normalizer.html#details">More...</a><br /></td></tr>
<tr class="memitem:NormaMinkHlaw" id="r_NormaMinkHlaw"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/d78/classLatticeTester_1_1NormaMinkHlaw.html">NormaMinkHlaw</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements <em>lower bounds</em> on the Hermite constants based on the Minkowski-Hlawka theorem <a class="el" href="../../d0/de3/citelist.html#CITEREF_mhla43a">[7]</a>.  <a href="../../df/d78/classLatticeTester_1_1NormaMinkHlaw.html#details">More...</a><br /></td></tr>
<tr class="memitem:NormaPalpha" id="r_NormaPalpha"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d6e/classLatticeTester_1_1NormaPalpha.html">NormaPalpha</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements theoretical bounds on the values of \(P_{\alpha}\) for a lattice (see class <span class="tt">Palpha</span>).  <a href="../../d8/d6e/classLatticeTester_1_1NormaPalpha.html#details">More...</a><br /></td></tr>
<tr class="memitem:NormaRogers" id="r_NormaRogers"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d30/classLatticeTester_1_1NormaRogers.html">NormaRogers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements upper bounds on the length of the shortest nonzero vector in a lattice, in which the Hermite constants \(\gamma_s\) are approximated by their Rogers's bounds for all \(s \ge 2\).  <a href="../../d1/d30/classLatticeTester_1_1NormaRogers.html#details">More...</a><br /></td></tr>
<tr class="memitem:Rank1Lattice" id="r_Rank1Lattice"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html">Rank1Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subclass of <span class="tt"><a class="el" href="../../d8/d6c/classLatticeTester_1_1IntLatticeExt.html" title="This abstract class extends IntLattice with additional (virtual) methods that must be implemented in ...">IntLatticeExt</a></span> defines a general rank-1 lattice rule in \(t\) dimensions, whose \(m\) points are \( \mathbf{u}_i = (i \mathbf{a} \bmod m)/m \) for \(i = 0,\dots,m-1\), where \(\mathbf{a} = (a_1,a_2,\dots,a_t) \in \mathbb{Z}_m^t\) is the generating vector, \(a_1 = 1\), and \(\gcd(a_j, m) = 1\) for \(j =2, \dots,t\).  <a href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html#details">More...</a><br /></td></tr>
<tr class="memitem:ReducerBB" id="r_ReducerBB"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dea/classLatticeTester_1_1ReducerBB.html">ReducerBB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class provides functions to find a shortest nonzero vector in the lattice using a BB algorithm as in <a class="el" href="../../d0/de3/citelist.html#CITEREF_mfin85a">[6]</a>, and to compute a Minkowski basis reduction as in <a class="el" href="../../d0/de3/citelist.html#CITEREF_raff85a">[1]</a>.  <a href="../../d0/dea/classLatticeTester_1_1ReducerBB.html#details">More...</a><br /></td></tr>
<tr class="memitem:Weights" id="r_Weights"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html">Weights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class that defines an interface to specify <a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html" title="Abstract class that defines an interface to specify Weights given to projections in figures of merit.">Weights</a> given to projections in figures of merit.  <a href="../../db/d40/classLatticeTester_1_1Weights.html#details">More...</a><br /></td></tr>
<tr class="memitem:WeightsOrderDependent" id="r_WeightsOrderDependent"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7f/classLatticeTester_1_1WeightsOrderDependent.html">WeightsOrderDependent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines order-dependent weights, for which the weight of a projection depends only on its order (cardinality).  <a href="../../dd/d7f/classLatticeTester_1_1WeightsOrderDependent.html#details">More...</a><br /></td></tr>
<tr class="memitem:WeightsPOD" id="r_WeightsPOD"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0e/classLatticeTester_1_1WeightsPOD.html">WeightsPOD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines product and order-dependent (POD) weights, for which the weight of a projection is the sum of a product weight and an order-dependent weight.  <a href="../../d8/d0e/classLatticeTester_1_1WeightsPOD.html#details">More...</a><br /></td></tr>
<tr class="memitem:WeightsProduct" id="r_WeightsProduct"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d8a/classLatticeTester_1_1WeightsProduct.html">WeightsProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines product weights, for which the weight of a projection is equal to the product of the weights of the individual coordinates.  <a href="../../d1/d8a/classLatticeTester_1_1WeightsProduct.html#details">More...</a><br /></td></tr>
<tr class="memitem:WeightsProjectionDependent" id="r_WeightsProjectionDependent"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html">WeightsProjectionDependent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines projection-dependent weights, for which the weight for any given projection can be set individually by <a class="el" href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html#a18af3f94aaaa4b82a574fec8a0bf26ad" title="Sets the weight of the projection specified by projection.">setWeight()</a>.  <a href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html#details">More...</a><br /></td></tr>
<tr class="memitem:WeightsUniform" id="r_WeightsUniform"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d8f/classLatticeTester_1_1WeightsUniform.html">WeightsUniform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies weights that are the same (usually 1) for all projections.  <a href="../../dd/d8f/classLatticeTester_1_1WeightsUniform.html#details">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-typedef-members" class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a951f7e7b03767aa0971dde55f9d328ec" id="r_a951f7e7b03767aa0971dde55f9d328ec"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a951f7e7b03767aa0971dde55f9d328ec">Weight</a></td></tr>
<tr class="memdesc:a951f7e7b03767aa0971dde55f9d328ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar weight type.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-enum-members" class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9770e4d57aa715e249cd7e700c6f37e4" id="r_a9770e4d57aa715e249cd7e700c6f37e4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> { <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4a3e12e2ca7e65c77c86a8afbbf1faed0d">SUPNORM</a>
, <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4a6031a75d242058c5b26d05f510267b41">L1NORM</a>
, <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4a2d8982335f008ef95768bd7ec450d86b">L2NORM</a>
, <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4a9dd28fa34c8fd3331bd55e85d9b8ff2b">ZAREMBANORM</a>
 }</td></tr>
<tr class="memdesc:a9770e4d57aa715e249cd7e700c6f37e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The available norm types to measure the length of vectors.  <a href="#a9770e4d57aa715e249cd7e700c6f37e4">More...</a><br /></td></tr>
<tr class="memitem:ab747c1cbb0f5e47fef711b62327a8e90" id="r_ab747c1cbb0f5e47fef711b62327a8e90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a> { <br />
&#160;&#160;<a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90a6f65388b2929fedcf40d456d30df3551">BESTLAT</a>
, <a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90ab2dc4f1b4d3313f8df8baf113e937d6e">BESTUPBOUND</a>
, <a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90ae8842bb9870dacacc65ef1ad46f8fa4b">LAMINATED</a>
, <a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90a81b5bfa5986a0cf0f014837542837641">ROGERS</a>
, <br />
&#160;&#160;<a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90a5e579ba5452180d37e3e048875ba46e5">MINKL1</a>
, <a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90ade77243f2c15d6fcd3ba37d25bf82ce9">MINKHLAW</a>
, <a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90a5e9d13ae2852670258864320734e0cbf">NONE</a>
<br />
 }</td></tr>
<tr class="memdesc:ab747c1cbb0f5e47fef711b62327a8e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different choices of output formats.  <a href="#ab747c1cbb0f5e47fef711b62327a8e90">More...</a><br /></td></tr>
<tr class="memitem:a0d2f9ab69a9d586b8273cbb29bb105fe" id="r_a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105fe">CalcType</a> { <a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105feae444ad54301419ac37ef878aedb20234">PAL</a>
, <a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105fea18fa93c0ce684acf5f50252d813034f4">NORMPAL</a>
, <a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105fea1eea8810a9a8d0e0721cbab47592d29c">BAL</a>
, <a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105feae7e8d0e1b5a15810847d798d1fe0b039">SEEKPAL</a>
 }</td></tr>
<tr class="memdesc:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which type of calculation is considered for the \(P_{\alpha}\) test.  <a href="#a0d2f9ab69a9d586b8273cbb29bb105fe">More...</a><br /></td></tr>
<tr class="memitem:af2a213e64bd54d3e33a7aff0f80068cb" id="r_af2a213e64bd54d3e33a7aff0f80068cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cb">ReductionType</a> { <br />
&#160;&#160;<a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cba7212a3bb53b382d1e38c3f8cdf7a47cf">PAIR</a>
, <a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cba8d04551154f945a747c129cdabff4af5">LLL</a>
, <a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cba14aace9298ad3f3297ff86c30b8d34eb">BKZ</a>
, <a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cba00217b110040213df758637d15e36795">BB</a>
, <br />
&#160;&#160;<a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cba59eedbabbb28a332f4d36822d74ae6dd">PAIRBB</a>
, <a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cba841193f6d276a17aff255f4f59a712d9">LLLBB</a>
, <a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cba3c1372bd908125ef772819276035b74c">BKZBB</a>
<br />
 }</td></tr>
<tr class="memdesc:af2a213e64bd54d3e33a7aff0f80068cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of all the possible lattice reductions implemented in <span class="tt"><a class="el" href="d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a></span>.  <a href="#af2a213e64bd54d3e33a7aff0f80068cb">More...</a><br /></td></tr>
<tr class="memitem:a5bf461b8f167cc8c7ebebc8ee6a96ee4" id="r_a5bf461b8f167cc8c7ebebc8ee6a96ee4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">DecompTypeBB</a> { <a class="el" href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4a3266f268976e38e1d5e53fb38ef4de9d">CHOLESKY</a>
, <a class="el" href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4ab3f7f0887ca0f53844b887588c92cd66">TRIANGULAR</a>
 }</td></tr>
<tr class="memdesc:a5bf461b8f167cc8c7ebebc8ee6a96ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two possible ways of obtaining a triangular matrix to compute the bounds in the BB algorithm.  <a href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">More...</a><br /></td></tr>
<tr class="memitem:a1ff6c9ee29ca0bac6c63d2622508aa46" id="r_a1ff6c9ee29ca0bac6c63d2622508aa46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a> { <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46a59c23f7e8d888fc3e79108dea9475dbb">LLLPROJ</a>
, <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46abbfbd0f53d264fdd705b4416b8c36d87">UPPERTRIPROJ</a>
 }</td></tr>
<tr class="memdesc:a1ff6c9ee29ca0bac6c63d2622508aa46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two possible ways of computing the basis for a projection.  <a href="#a1ff6c9ee29ca0bac6c63d2622508aa46">More...</a><br /></td></tr>
<tr class="memitem:a5e9e347d07097a1a3c82f1699ff93d58" id="r_a5e9e347d07097a1a3c82f1699ff93d58"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e9e347d07097a1a3c82f1699ff93d58">MeritType</a> { <a class="el" href="#a5e9e347d07097a1a3c82f1699ff93d58a094d81300c3a1bd13d96d01e8c53a3ad">MERITM</a>
, <a class="el" href="#a5e9e347d07097a1a3c82f1699ff93d58ad875e35fbaf2f2e8be530376935b6c6d">MERITQ</a>
 }</td></tr>
<tr class="memdesc:a5e9e347d07097a1a3c82f1699ff93d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two different types of figures of merit.  <a href="#a5e9e347d07097a1a3c82f1699ff93d58">More...</a><br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-func-members" class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aa57d18b5ef393224b7f1829d5682d759" id="r_aa57d18b5ef393224b7f1829d5682d759"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </td></tr>
<tr class="memitem:aa57d18b5ef393224b7f1829d5682d759 template"><td class="memItemLeft" align="right" valign="top">static Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa57d18b5ef393224b7f1829d5682d759">LLLConstruction0</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;gen, const double delta=0.9, long r=0, long c=0, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *sqlen=0)</td></tr>
<tr class="memdesc:aa57d18b5ef393224b7f1829d5682d759"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function takes a set of generating vectors of a lattice in matrix <span class="tt">gen</span> and finds a lattice basis by applying LLL reduction with the given value of <span class="tt">delta</span>, using the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> implementation specified by <span class="tt">prec</span>.  <br /></td></tr>
<tr class="memitem:a307eeecf6b0886bf41fdf57cd02f67b3" id="r_a307eeecf6b0886bf41fdf57cd02f67b3"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </td></tr>
<tr class="memitem:a307eeecf6b0886bf41fdf57cd02f67b3 template"><td class="memItemLeft" align="right" valign="top">static Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a307eeecf6b0886bf41fdf57cd02f67b3">LLLBasisConstruction</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;gen, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, const double delta=0.9, long r=0, long c=0, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *sqlen=0)</td></tr>
<tr class="memdesc:a307eeecf6b0886bf41fdf57cd02f67b3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <span class="tt">LLLConstruction0</span>, except that this function adds explicitly all the vectors \(m \mathbf{e}_i\) to the generating set, so there will be <span class="tt">r + c</span> rows initially and the function always returns a square matrix.  <br /></td></tr>
<tr class="memitem:a14056d5418242137d62897e30468af3a" id="r_a14056d5418242137d62897e30468af3a"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a14056d5418242137d62897e30468af3a template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14056d5418242137d62897e30468af3a">lowerTriangularBasis</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;gen, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long r=0, long c=0)</td></tr>
<tr class="memdesc:a14056d5418242137d62897e30468af3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a set of generating vectors in the matrix <span class="tt">gen</span> and iteratively transforms it into a lower triangular lattice basis into the matrix <span class="tt">basis</span>.  <br /></td></tr>
<tr class="memitem:a6a4f630a4729e98fe79e334181e26ce9" id="r_a6a4f630a4729e98fe79e334181e26ce9"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a6a4f630a4729e98fe79e334181e26ce9 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6a4f630a4729e98fe79e334181e26ce9">upperTriangularBasis</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;gen, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long r=0, long c=0)</td></tr>
<tr class="memdesc:a6a4f630a4729e98fe79e334181e26ce9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <span class="tt">lowerTriangularBasis</span>, except that the returned basis is upper triangular.  <br /></td></tr>
<tr class="memitem:abf5110b05c562288e6c78894b67309d1" id="r_abf5110b05c562288e6c78894b67309d1"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:abf5110b05c562288e6c78894b67309d1 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf5110b05c562288e6c78894b67309d1">upperTriangularBasisOld96</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;gen, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long r=0, long c=0)</td></tr>
<tr class="memdesc:abf5110b05c562288e6c78894b67309d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">The old version from <a class="el" href="../../d0/de3/citelist.html#CITEREF_rcou96a">[5]</a> and <a class="el" href="../../d0/de3/citelist.html#CITEREF_ilec00l">[10]</a>.  <br /></td></tr>
<tr class="memitem:a577b7e284f468095fc9063219950a309" id="r_a577b7e284f468095fc9063219950a309"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a577b7e284f468095fc9063219950a309 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a577b7e284f468095fc9063219950a309">mDualLowerTriangular</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basisDual, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long dim=0)</td></tr>
<tr class="memdesc:a577b7e284f468095fc9063219950a309"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a lower-triangular basis matrix <span class="tt">basis</span> and computes the m-dual basis <span class="tt">basisDual</span>.  <br /></td></tr>
<tr class="memitem:a74010e8963e3be1e042c2a530ecaa991" id="r_a74010e8963e3be1e042c2a530ecaa991"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a74010e8963e3be1e042c2a530ecaa991 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74010e8963e3be1e042c2a530ecaa991">mDualLowerTriangularMod0</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basisDual, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long dim=0)</td></tr>
<tr class="memdesc:a74010e8963e3be1e042c2a530ecaa991"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <span class="tt">mDualLowerTriangular</span> and then reduces all the non-diagonal <span class="tt">mod m</span> towards 0.  <br /></td></tr>
<tr class="memitem:a7076873730fe2764258ce837c228ec41" id="r_a7076873730fe2764258ce837c228ec41"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a7076873730fe2764258ce837c228ec41 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7076873730fe2764258ce837c228ec41">mDualUpperTriangular</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basisDual, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long dim=0)</td></tr>
<tr class="memdesc:a7076873730fe2764258ce837c228ec41"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a upper triangular basis matrix <span class="tt">basis</span> and computes the m-dual basis <span class="tt">basisDual</span>.  <br /></td></tr>
<tr class="memitem:a5b18b71fde30f5a2a619c6a6fdaa94fe" id="r_a5b18b71fde30f5a2a619c6a6fdaa94fe"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a5b18b71fde30f5a2a619c6a6fdaa94fe template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5b18b71fde30f5a2a619c6a6fdaa94fe">mDualUpperTriangularMod0</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basisDual, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long dim=0)</td></tr>
<tr class="memdesc:a5b18b71fde30f5a2a619c6a6fdaa94fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <span class="tt">mDualUpperTriangular</span> and then reduces all the non-diagonal <span class="tt">mod m</span> towards 0.  <br /></td></tr>
<tr class="memitem:a8dd3800cd5914504c14a8f2a24e6bc15" id="r_a8dd3800cd5914504c14a8f2a24e6bc15"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a8dd3800cd5914504c14a8f2a24e6bc15 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8dd3800cd5914504c14a8f2a24e6bc15">mDualUpperTriangularOld96</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basisDual, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long dim=0)</td></tr>
<tr class="memdesc:a8dd3800cd5914504c14a8f2a24e6bc15"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does essentially the same thing as <span class="tt">mDualUpperTriangular</span>, but the algorithm is slightly different.  <br /></td></tr>
<tr class="memitem:a55267cecc397bb7159dc1caadd4277f0" id="r_a55267cecc397bb7159dc1caadd4277f0"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a55267cecc397bb7159dc1caadd4277f0 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55267cecc397bb7159dc1caadd4277f0">mDualBasis</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basisDual, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m)</td></tr>
<tr class="memdesc:a55267cecc397bb7159dc1caadd4277f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assumes that <span class="tt">basis</span> contains a basis of the primal lattice scaled by the factor <span class="tt">m</span>, not necessarily triangular, and it returns in <span class="tt">basisDual</span> the m-dual basis.  <br /></td></tr>
<tr class="memitem:a8efa9af09c4f0908209a9039056fcb27" id="r_a8efa9af09c4f0908209a9039056fcb27"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a8efa9af09c4f0908209a9039056fcb27 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8efa9af09c4f0908209a9039056fcb27">projectMatrix</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;out, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;in, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, long r=0)</td></tr>
<tr class="memdesc:a8efa9af09c4f0908209a9039056fcb27"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function overwrites the first <span class="tt">r</span> rows of matrix 'out' by a matrix formed by the first <span class="tt">r</span> rows of the c columns of matrix <span class="tt">in</span> that are specified by <span class="tt">proj</span>, where &lsquo;c = size(proj)&rsquo; is the cardinality of the projection <span class="tt">proj</span>.  <br /></td></tr>
<tr class="memitem:a085b0d6b291e2104251d6bf3746c3158" id="r_a085b0d6b291e2104251d6bf3746c3158"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </td></tr>
<tr class="memitem:a085b0d6b291e2104251d6bf3746c3158 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a085b0d6b291e2104251d6bf3746c3158">projectionConstructionLLL</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;projBasis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;inBasis, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, const double delta=0.9, long r=0, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *sqlen=0)</td></tr>
<tr class="memdesc:a085b0d6b291e2104251d6bf3746c3158"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a basis for the projection <span class="tt">proj</span> of the lattice with basis <span class="tt">inBasis</span>, using <span class="tt">LLLBasisConstruction</span>, and returns it in <span class="tt">projBasis</span>.  <br /></td></tr>
<tr class="memitem:a23727477171c0b882c6c8a0c41c1ba2b" id="r_a23727477171c0b882c6c8a0c41c1ba2b"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a23727477171c0b882c6c8a0c41c1ba2b template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a23727477171c0b882c6c8a0c41c1ba2b">projectionConstructionUpperTri</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;projBasis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;inBasis, <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;genTemp, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long r=0)</td></tr>
<tr class="memdesc:a23727477171c0b882c6c8a0c41c1ba2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <span class="tt">projectionConstructionLLL</span>, but the construction is made using <span class="tt">upperTriangularBasis</span>, so the returned basis is upper triangular.  <br /></td></tr>
<tr class="memitem:ac2aae5201a480e23fa21343f289b0f2a" id="r_ac2aae5201a480e23fa21343f289b0f2a"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:ac2aae5201a480e23fa21343f289b0f2a template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac2aae5201a480e23fa21343f289b0f2a">projectionConstructionUpperTri</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;projBasis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;inBasis, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long r=0)</td></tr>
<tr class="memitem:a10b69f089b2845f22065ef00561511bd" id="r_a10b69f089b2845f22065ef00561511bd"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a10b69f089b2845f22065ef00561511bd template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a10b69f089b2845f22065ef00561511bd">projectionConstruction</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;projBasis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;inBasis, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, const <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a> projType=<a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46a59c23f7e8d888fc3e79108dea9475dbb">LLLPROJ</a>, const double delta=0.9)</td></tr>
<tr class="memdesc:a10b69f089b2845f22065ef00561511bd"><td class="mdescLeft">&#160;</td><td class="mdescRight">In this version, the construction method is passed as a parameter.  <br /></td></tr>
<tr class="memitem:aedff96000ec004065ececb54c4e25e70" id="r_aedff96000ec004065ececb54c4e25e70"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aedff96000ec004065ececb54c4e25e70 template"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aedff96000ec004065ececb54c4e25e70">LLLConstruction0</a> (NTL::Mat&lt; long &gt; &amp;gen, const double delta, long r, long c, NTL::Vec&lt; double &gt; *sqlen)</td></tr>
<tr class="memitem:a744f7989fb4fe55dcd495233b747e0d6" id="r_a744f7989fb4fe55dcd495233b747e0d6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a744f7989fb4fe55dcd495233b747e0d6 template"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a744f7989fb4fe55dcd495233b747e0d6">LLLConstruction0</a> (NTL::Mat&lt; NTL::ZZ &gt; &amp;gen, const double delta, long r, long c, NTL::Vec&lt; double &gt; *sqlen)</td></tr>
<tr class="memitem:a25d09e2b931b88a311d38461458099a8" id="r_a25d09e2b931b88a311d38461458099a8"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a25d09e2b931b88a311d38461458099a8 template"><td class="memItemLeft" align="right" valign="top">xdouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a25d09e2b931b88a311d38461458099a8">LLLConstruction0</a> (NTL::Mat&lt; NTL::ZZ &gt; &amp;gen, const double delta, long r, long c, NTL::Vec&lt; xdouble &gt; *sqlen)</td></tr>
<tr class="memitem:a72aa68b5a626ce9431145f7a3e753620" id="r_a72aa68b5a626ce9431145f7a3e753620"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a72aa68b5a626ce9431145f7a3e753620 template"><td class="memItemLeft" align="right" valign="top">quad_float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72aa68b5a626ce9431145f7a3e753620">LLLConstruction0</a> (NTL::Mat&lt; NTL::ZZ &gt; &amp;gen, const double delta, long r, long c, NTL::Vec&lt; quad_float &gt; *sqlen)</td></tr>
<tr class="memitem:a77ea11a7ef3fcc8747d0e89212050e19" id="r_a77ea11a7ef3fcc8747d0e89212050e19"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a77ea11a7ef3fcc8747d0e89212050e19 template"><td class="memItemLeft" align="right" valign="top">RR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a77ea11a7ef3fcc8747d0e89212050e19">LLLConstruction0</a> (NTL::Mat&lt; NTL::ZZ &gt; &amp;gen, const double delta, long r, long c, NTL::Vec&lt; NTL::RR &gt; *sqlen)</td></tr>
<tr class="memitem:aee78965591d1b5717dee3bba5be835bf" id="r_aee78965591d1b5717dee3bba5be835bf"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </td></tr>
<tr class="memitem:aee78965591d1b5717dee3bba5be835bf template"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aee78965591d1b5717dee3bba5be835bf">LLLBasisConstruction</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;gen, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, double delta, long r, long c, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *sqlen)</td></tr>
<tr class="memdesc:aee78965591d1b5717dee3bba5be835bf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <span class="tt">LLLConstruction0</span>, except that this function adds explicitly all the vectors \(m \mathbf{e}_i\) to the generating set, so there will be <span class="tt">r + c</span> rows initially and the function always returns a square matrix.  <br /></td></tr>
<tr class="memitem:adf38db6c503b603580edb998ab3dfb3a" id="r_adf38db6c503b603580edb998ab3dfb3a"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:adf38db6c503b603580edb998ab3dfb3a template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adf38db6c503b603580edb998ab3dfb3a">lowerTriangularBasis</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;gen, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long dim1, long dim2)</td></tr>
<tr class="memdesc:adf38db6c503b603580edb998ab3dfb3a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a set of generating vectors in the matrix <span class="tt">gen</span> and iteratively transforms it into a lower triangular lattice basis into the matrix <span class="tt">basis</span>.  <br /></td></tr>
<tr class="memitem:ac0699288204d864638ec9cc3461192bc" id="r_ac0699288204d864638ec9cc3461192bc"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:ac0699288204d864638ec9cc3461192bc template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac0699288204d864638ec9cc3461192bc">upperTriangularBasis</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;gen, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long dim1, long dim2)</td></tr>
<tr class="memdesc:ac0699288204d864638ec9cc3461192bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <span class="tt">lowerTriangularBasis</span>, except that the returned basis is upper triangular.  <br /></td></tr>
<tr class="memitem:a3d4b386e05b14e28a1a77e18af32acce" id="r_a3d4b386e05b14e28a1a77e18af32acce"><td class="memTemplParams" colspan="2">template&lt;typename Matr, typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a3d4b386e05b14e28a1a77e18af32acce template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d4b386e05b14e28a1a77e18af32acce">upperTriangularBasisOld96</a> (Matr &amp;V, Matr &amp;W, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, int64_t lin, int64_t col)</td></tr>
<tr class="memitem:a7599453daee81235947f198aa0fdabd2" id="r_a7599453daee81235947f198aa0fdabd2"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a7599453daee81235947f198aa0fdabd2 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7599453daee81235947f198aa0fdabd2">mDualLowerTriangular</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;B, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;A, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long dim)</td></tr>
<tr class="memdesc:a7599453daee81235947f198aa0fdabd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a lower-triangular basis matrix <span class="tt">basis</span> and computes the m-dual basis <span class="tt">basisDual</span>.  <br /></td></tr>
<tr class="memitem:a879bb70764843a663c4a22e993cd1d8b" id="r_a879bb70764843a663c4a22e993cd1d8b"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a879bb70764843a663c4a22e993cd1d8b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a879bb70764843a663c4a22e993cd1d8b">mDualUpperTriangular</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;B, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;A, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long dim)</td></tr>
<tr class="memdesc:a879bb70764843a663c4a22e993cd1d8b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a upper triangular basis matrix <span class="tt">basis</span> and computes the m-dual basis <span class="tt">basisDual</span>.  <br /></td></tr>
<tr class="memitem:a330c8d1822bd62d27f7708e04e409a96" id="r_a330c8d1822bd62d27f7708e04e409a96"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a330c8d1822bd62d27f7708e04e409a96 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a330c8d1822bd62d27f7708e04e409a96">mDualLowerTriangularMod0</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;B, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;A, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long dim)</td></tr>
<tr class="memdesc:a330c8d1822bd62d27f7708e04e409a96"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <span class="tt">mDualLowerTriangular</span> and then reduces all the non-diagonal <span class="tt">mod m</span> towards 0.  <br /></td></tr>
<tr class="memitem:a541c52e31adea978279ddd93a5cbdc18" id="r_a541c52e31adea978279ddd93a5cbdc18"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a541c52e31adea978279ddd93a5cbdc18 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a541c52e31adea978279ddd93a5cbdc18">mDualUpperTriangularMod0</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;B, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;A, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long dim)</td></tr>
<tr class="memdesc:a541c52e31adea978279ddd93a5cbdc18"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <span class="tt">mDualUpperTriangular</span> and then reduces all the non-diagonal <span class="tt">mod m</span> towards 0.  <br /></td></tr>
<tr class="memitem:a938bceedde41f1318302ed9037dc0f83" id="r_a938bceedde41f1318302ed9037dc0f83"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a938bceedde41f1318302ed9037dc0f83 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a938bceedde41f1318302ed9037dc0f83">mDualUpperTriangularOld96</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basisDual, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long dim)</td></tr>
<tr class="memdesc:a938bceedde41f1318302ed9037dc0f83"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does essentially the same thing as <span class="tt">mDualUpperTriangular</span>, but the algorithm is slightly different.  <br /></td></tr>
<tr class="memitem:a2cdb586351ffc042ae953045a73f01fb" id="r_a2cdb586351ffc042ae953045a73f01fb"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2cdb586351ffc042ae953045a73f01fb template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cdb586351ffc042ae953045a73f01fb">mDualUpperTriangularOld96</a> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basisDual, const NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, const NTL::ZZ &amp;m, long dim)</td></tr>
<tr class="memitem:a8b517f6075fece22fd4336115e2fd524" id="r_a8b517f6075fece22fd4336115e2fd524"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a8b517f6075fece22fd4336115e2fd524 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a8b517f6075fece22fd4336115e2fd524">mDualBasis</a> (NTL::Mat&lt; <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &gt; &amp;basisDual, const NTL::Mat&lt; <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &gt; &amp;basis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m)</td></tr>
<tr class="memitem:a452ed7260c613b06e3ccd84682b989a2" id="r_a452ed7260c613b06e3ccd84682b989a2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a452ed7260c613b06e3ccd84682b989a2 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a452ed7260c613b06e3ccd84682b989a2">mDualBasis</a> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basisDual, const NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, const NTL::ZZ &amp;m)</td></tr>
<tr class="memitem:aac6373857de656ccfeb0972950b2986d" id="r_aac6373857de656ccfeb0972950b2986d"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:aac6373857de656ccfeb0972950b2986d template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aac6373857de656ccfeb0972950b2986d">projectMatrix</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;out, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;in, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, long r)</td></tr>
<tr class="memdesc:aac6373857de656ccfeb0972950b2986d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function overwrites the first <span class="tt">r</span> rows of matrix 'out' by a matrix formed by the first <span class="tt">r</span> rows of the c columns of matrix <span class="tt">in</span> that are specified by <span class="tt">proj</span>, where &lsquo;c = size(proj)&rsquo; is the cardinality of the projection <span class="tt">proj</span>.  <br /></td></tr>
<tr class="memitem:a33e21410fcd60b6dc1a9bf1ac58ad029" id="r_a33e21410fcd60b6dc1a9bf1ac58ad029"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </td></tr>
<tr class="memitem:a33e21410fcd60b6dc1a9bf1ac58ad029 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33e21410fcd60b6dc1a9bf1ac58ad029">projectionConstructionLLL</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;projBasis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;inBasis, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, const double delta, long r, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *sqlen)</td></tr>
<tr class="memdesc:a33e21410fcd60b6dc1a9bf1ac58ad029"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a basis for the projection <span class="tt">proj</span> of the lattice with basis <span class="tt">inBasis</span>, using <span class="tt">LLLBasisConstruction</span>, and returns it in <span class="tt">projBasis</span>.  <br /></td></tr>
<tr class="memitem:afab54fa69b7e88d66cbcc2f7568674ac" id="r_afab54fa69b7e88d66cbcc2f7568674ac"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:afab54fa69b7e88d66cbcc2f7568674ac template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afab54fa69b7e88d66cbcc2f7568674ac">projectionConstructionUpperTri</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;projBasis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;inBasis, <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;genTemp, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long r)</td></tr>
<tr class="memdesc:afab54fa69b7e88d66cbcc2f7568674ac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <span class="tt">projectionConstructionLLL</span>, but the construction is made using <span class="tt">upperTriangularBasis</span>, so the returned basis is upper triangular.  <br /></td></tr>
<tr class="memitem:ad55ee07787a3411bde9ae8ae7dd18801" id="r_ad55ee07787a3411bde9ae8ae7dd18801"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:ad55ee07787a3411bde9ae8ae7dd18801 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad55ee07787a3411bde9ae8ae7dd18801">projectionConstructionUpperTri</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;projBasis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;inBasis, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, long r)</td></tr>
<tr class="memitem:aacaaa449af42b672227ce6606347a066" id="r_aacaaa449af42b672227ce6606347a066"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:aacaaa449af42b672227ce6606347a066 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aacaaa449af42b672227ce6606347a066">projectionConstruction</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;projBasis, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;inBasis, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m, const <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a> projType, const double delta)</td></tr>
<tr class="memdesc:aacaaa449af42b672227ce6606347a066"><td class="mdescLeft">&#160;</td><td class="mdescRight">In this version, the construction method is passed as a parameter.  <br /></td></tr>
<tr class="memitem:af65fc07f34906524398b038327a0bb14" id="r_af65fc07f34906524398b038327a0bb14"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af65fc07f34906524398b038327a0bb14">toStringNorm</a> (<a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm)</td></tr>
<tr class="memdesc:af65fc07f34906524398b038327a0bb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following are functions for printing the <span class="tt">enum</span> constants in this module.  <br /></td></tr>
<tr class="memitem:ac24879d5aa087958f258e3a9e3770d37" id="r_ac24879d5aa087958f258e3a9e3770d37"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac24879d5aa087958f258e3a9e3770d37">toStringNorma</a> (<a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a> norma)</td></tr>
<tr class="memitem:a137cd194ce614d43c80f65557ee96109" id="r_a137cd194ce614d43c80f65557ee96109"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a137cd194ce614d43c80f65557ee96109">toStringReduction</a> (<a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cb">ReductionType</a> reduct)</td></tr>
<tr class="memitem:a21f1a550ff7e4344554a043faceb7c55" id="r_a21f1a550ff7e4344554a043faceb7c55"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21f1a550ff7e4344554a043faceb7c55">toStringDecomp</a> (<a class="el" href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">DecompTypeBB</a> decomp)</td></tr>
<tr class="memitem:a12e050957b719073c06de41c7486f1ce" id="r_a12e050957b719073c06de41c7486f1ce"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12e050957b719073c06de41c7486f1ce">toStringProjConstruct</a> (<a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a> proj)</td></tr>
<tr class="memitem:a1a2fb1307d0863e4d38a3b813b180014" id="r_a1a2fb1307d0863e4d38a3b813b180014"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a2fb1307d0863e4d38a3b813b180014">toStringMeritType</a> (<a class="el" href="#a5e9e347d07097a1a3c82f1699ff93d58">MeritType</a> merit)</td></tr>
<tr class="memitem:a71110e4d0e1c979d7f5da2593e8edddb" id="r_a71110e4d0e1c979d7f5da2593e8edddb"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71110e4d0e1c979d7f5da2593e8edddb">lFactorial</a> (int64_t t)</td></tr>
<tr class="memdesc:a71110e4d0e1c979d7f5da2593e8edddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(t!\), the factorial of \(t\).  <br /></td></tr>
<tr class="memitem:a886c94b54767104cea58e0f1b6c0d11e" id="r_a886c94b54767104cea58e0f1b6c0d11e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a886c94b54767104cea58e0f1b6c0d11e">Digamma</a> (double x)</td></tr>
<tr class="memdesc:a886c94b54767104cea58e0f1b6c0d11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the logarithmic derivative of the Gamma function \(\psi(x) = \Gamma&#39;(x) / \Gamma(x)\).  <br /></td></tr>
<tr class="memitem:a67515c2643b5f7029486e8118ede05d6" id="r_a67515c2643b5f7029486e8118ede05d6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67515c2643b5f7029486e8118ede05d6">BernoulliPoly</a> (int64_t n, double x)</td></tr>
<tr class="memdesc:a67515c2643b5f7029486e8118ede05d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\).  <br /></td></tr>
<tr class="memitem:a61a4b5013c295f9f07b9b2d8f26ee5f4" id="r_a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61a4b5013c295f9f07b9b2d8f26ee5f4">Harmonic</a> (std::int64_t n)</td></tr>
<tr class="memdesc:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(n\)-th harmonic number \(H_n  = \sum_{j=1}^n 1/j\).  <br /></td></tr>
<tr class="memitem:a3aefa49a034495dcc46721c275f329b0" id="r_a3aefa49a034495dcc46721c275f329b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aefa49a034495dcc46721c275f329b0">Harmonic2</a> (std::int64_t n)</td></tr>
<tr class="memdesc:a3aefa49a034495dcc46721c275f329b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum.  <br /></td></tr>
<tr class="memitem:a0bb56e7569fb24800973df89d757f2fd" id="r_a0bb56e7569fb24800973df89d757f2fd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bb56e7569fb24800973df89d757f2fd">FourierC1</a> (double x, std::int64_t n)</td></tr>
<tr class="memdesc:a0bb56e7569fb24800973df89d757f2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series (see <a class="el" href="../../d0/de3/citelist.html#CITEREF_vjoe92b">[8]</a>)  <br /></td></tr>
<tr class="memitem:ab5f708fa0e8d6aa53427b3e8927f5504" id="r_ab5f708fa0e8d6aa53427b3e8927f5504"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5f708fa0e8d6aa53427b3e8927f5504">FourierE1</a> (double x, std::int64_t n)</td></tr>
<tr class="memdesc:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series.  <br /></td></tr>
<tr class="memitem:a3ceea9a41a24df6ed2031758a1d6ec20" id="r_a3ceea9a41a24df6ed2031758a1d6ec20"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </td></tr>
<tr class="memitem:a3ceea9a41a24df6ed2031758a1d6ec20 template"><td class="memItemLeft" align="right" valign="top">static Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3ceea9a41a24df6ed2031758a1d6ec20">redLLL</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, double delta=0.99999, long dim=0, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *sqlen=0)</td></tr>
<tr class="memdesc:a3ceea9a41a24df6ed2031758a1d6ec20"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> implementation of the LLL reduction algorithm with factor <span class="tt">delta</span>, presented in <a class="el" href="../../d0/de3/citelist.html#CITEREF_msch91a">[14]</a> (see also <a class="el" href="../../d0/de3/citelist.html#CITEREF_ilec22l">[11]</a>).  <br /></td></tr>
<tr class="memitem:a786516595510c5c25068e8799f0033a4" id="r_a786516595510c5c25068e8799f0033a4"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </td></tr>
<tr class="memitem:a786516595510c5c25068e8799f0033a4 template"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a786516595510c5c25068e8799f0033a4">redLLLExact</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, double delta=0.99999)</td></tr>
<tr class="memdesc:a786516595510c5c25068e8799f0033a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">This static function implements an exact algorithm from <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> to perform the original LLL reduction.  <br /></td></tr>
<tr class="memitem:a4a61a2dbcaf8040bb3ae3ffe23a098c8" id="r_a4a61a2dbcaf8040bb3ae3ffe23a098c8"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </td></tr>
<tr class="memitem:a4a61a2dbcaf8040bb3ae3ffe23a098c8 template"><td class="memItemLeft" align="right" valign="top">static Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a4a61a2dbcaf8040bb3ae3ffe23a098c8">redBKZ</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, double delta=0.99999, int64_t blocksize=10, long prune=0, long dim=0, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *sqlen=0)</td></tr>
<tr class="memdesc:a4a61a2dbcaf8040bb3ae3ffe23a098c8"><td class="mdescLeft">&#160;</td><td class="mdescRight">This calls the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> implementation of the floating point version of the BKZ reduction algorithm presented in <a class="el" href="../../d0/de3/citelist.html#CITEREF_msch91a">[14]</a>, with reduction factor <span class="tt">delta</span>, block size <span class="tt">blocksize</span>, pruning parameter &lsquo;prune&rsquo;; see <a class="el" href="../../d0/de3/citelist.html#CITEREF_ilec22l">[11]</a>.  <br /></td></tr>
<tr class="memitem:af8952c275a4f3ad1437fdbddf99ea679" id="r_af8952c275a4f3ad1437fdbddf99ea679"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </td></tr>
<tr class="memitem:af8952c275a4f3ad1437fdbddf99ea679 template"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af8952c275a4f3ad1437fdbddf99ea679">redLLL</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, double delta, long dim, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *sqlen)</td></tr>
<tr class="memdesc:af8952c275a4f3ad1437fdbddf99ea679"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function uses the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> implementation of the LLL reduction algorithm with factor <span class="tt">delta</span>, presented in <a class="el" href="../../d0/de3/citelist.html#CITEREF_msch91a">[14]</a> (see also <a class="el" href="../../d0/de3/citelist.html#CITEREF_ilec22l">[11]</a>).  <br /></td></tr>
<tr class="memitem:a45e9fb356874a9d69a083c447d35ee82" id="r_a45e9fb356874a9d69a083c447d35ee82"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a45e9fb356874a9d69a083c447d35ee82 template"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a45e9fb356874a9d69a083c447d35ee82">redLLL</a> (NTL::Mat&lt; int64_t &gt; &amp;basis, double delta, long dim, NTL::Vec&lt; double &gt; *sqlen)</td></tr>
<tr class="memitem:abf582f8ec90dc5bbc0c52a8afab88903" id="r_abf582f8ec90dc5bbc0c52a8afab88903"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:abf582f8ec90dc5bbc0c52a8afab88903 template"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf582f8ec90dc5bbc0c52a8afab88903">redLLL</a> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long dim, NTL::Vec&lt; double &gt; *sqlen)</td></tr>
<tr class="memitem:a3e85e9cda4a548bb9066dc93c01ffbc3" id="r_a3e85e9cda4a548bb9066dc93c01ffbc3"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a3e85e9cda4a548bb9066dc93c01ffbc3 template"><td class="memItemLeft" align="right" valign="top">xdouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e85e9cda4a548bb9066dc93c01ffbc3">redLLL</a> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long dim, NTL::Vec&lt; xdouble &gt; *sqlen)</td></tr>
<tr class="memitem:a6eb909d481b710dd72c07eb65f0f65af" id="r_a6eb909d481b710dd72c07eb65f0f65af"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a6eb909d481b710dd72c07eb65f0f65af template"><td class="memItemLeft" align="right" valign="top">quad_float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6eb909d481b710dd72c07eb65f0f65af">redLLL</a> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long dim, NTL::Vec&lt; quad_float &gt; *sqlen)</td></tr>
<tr class="memitem:a7c2d52c1e432a0aa02eb8d11c2b9efc5" id="r_a7c2d52c1e432a0aa02eb8d11c2b9efc5"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7c2d52c1e432a0aa02eb8d11c2b9efc5 template"><td class="memItemLeft" align="right" valign="top">NTL::RR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7c2d52c1e432a0aa02eb8d11c2b9efc5">redLLL</a> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long dim, NTL::Vec&lt; NTL::RR &gt; *sqlen)</td></tr>
<tr class="memitem:a5830bb0fae462b5e85c8eeb1c126a647" id="r_a5830bb0fae462b5e85c8eeb1c126a647"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a5830bb0fae462b5e85c8eeb1c126a647 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5830bb0fae462b5e85c8eeb1c126a647">redLLLExact</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, double delta)</td></tr>
<tr class="memitem:aebd6a9c79f1e8d406981e707235b99e6" id="r_aebd6a9c79f1e8d406981e707235b99e6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:aebd6a9c79f1e8d406981e707235b99e6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aebd6a9c79f1e8d406981e707235b99e6">redLLLExact</a> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta)</td></tr>
<tr class="memitem:acd4fd2f2c2477fc8ad2d483292d14baa" id="r_acd4fd2f2c2477fc8ad2d483292d14baa"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </td></tr>
<tr class="memitem:acd4fd2f2c2477fc8ad2d483292d14baa template"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#acd4fd2f2c2477fc8ad2d483292d14baa">redBKZ</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;basis, double delta, long blocksize, long prune, long dim, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *sqlen)</td></tr>
<tr class="memitem:a1d0913d24a5656d830a61018ce316716" id="r_a1d0913d24a5656d830a61018ce316716"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1d0913d24a5656d830a61018ce316716 template"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1d0913d24a5656d830a61018ce316716">redBKZ</a> (NTL::Mat&lt; int64_t &gt; &amp;basis, double delta, long blocksize, long prune, long dim, NTL::Vec&lt; double &gt; *sqlen)</td></tr>
<tr class="memitem:afa2d41ca2eff4fee580d48322b5fe8c0" id="r_afa2d41ca2eff4fee580d48322b5fe8c0"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:afa2d41ca2eff4fee580d48322b5fe8c0 template"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afa2d41ca2eff4fee580d48322b5fe8c0">redBKZ</a> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long blocksize, long prune, long dim, NTL::Vec&lt; double &gt; *sqlen)</td></tr>
<tr class="memitem:a2e11b9b3efca3e0ac3521dc42edb4f48" id="r_a2e11b9b3efca3e0ac3521dc42edb4f48"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2e11b9b3efca3e0ac3521dc42edb4f48 template"><td class="memItemLeft" align="right" valign="top">xdouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2e11b9b3efca3e0ac3521dc42edb4f48">redBKZ</a> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long blocksize, long prune, long dim, NTL::Vec&lt; xdouble &gt; *sqlen)</td></tr>
<tr class="memitem:a1f7c7c09bc3168a65b0a0750b9952f08" id="r_a1f7c7c09bc3168a65b0a0750b9952f08"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1f7c7c09bc3168a65b0a0750b9952f08 template"><td class="memItemLeft" align="right" valign="top">quad_float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f7c7c09bc3168a65b0a0750b9952f08">redBKZ</a> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long blocksize, long prune, long dim, NTL::Vec&lt; quad_float &gt; *sqlen)</td></tr>
<tr class="memitem:ae73d9d4b0e49f3431f21fc4bc0604a61" id="r_ae73d9d4b0e49f3431f21fc4bc0604a61"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ae73d9d4b0e49f3431f21fc4bc0604a61 template"><td class="memItemLeft" align="right" valign="top">NTL::RR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae73d9d4b0e49f3431f21fc4bc0604a61">redBKZ</a> (NTL::Mat&lt; NTL::ZZ &gt; &amp;basis, double delta, long blocksize, long prune, long dim, NTL::Vec&lt; NTL::RR &gt; *sqlen)</td></tr>
<tr class="memitem:ad4d16fed8fda92252dc423db28136932" id="r_ad4d16fed8fda92252dc423db28136932"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ad4d16fed8fda92252dc423db28136932 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad4d16fed8fda92252dc423db28136932">swap9</a> (T &amp;x, T &amp;y)</td></tr>
<tr class="memdesc:ad4d16fed8fda92252dc423db28136932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes references to two variables of a generic type and swaps their content.  <br /></td></tr>
<tr class="memitem:aab1b2821c4805119b5eb02b3fe0437eb" id="r_aab1b2821c4805119b5eb02b3fe0437eb"><td class="memTemplParams" colspan="2">template&lt;typename Matr1, typename Matr2&gt; </td></tr>
<tr class="memitem:aab1b2821c4805119b5eb02b3fe0437eb template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aab1b2821c4805119b5eb02b3fe0437eb">copyMatrixToMat</a> (Matr1 &amp;A, Matr2 &amp;B)</td></tr>
<tr class="memitem:a06b6fca0fb17656efed5391c452afc9b" id="r_a06b6fca0fb17656efed5391c452afc9b"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a06b6fca0fb17656efed5391c452afc9b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a06b6fca0fb17656efed5391c452afc9b">printBase</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> bas_mat)</td></tr>
<tr class="memitem:aaee961bb86089ad2cb9df512b1164e2f" id="r_aaee961bb86089ad2cb9df512b1164e2f"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:aaee961bb86089ad2cb9df512b1164e2f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaee961bb86089ad2cb9df512b1164e2f">printBase2</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> bas_mat)</td></tr>
<tr class="memitem:ab8df54cbab1b05dae27118a586c3d4c4" id="r_ab8df54cbab1b05dae27118a586c3d4c4"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:ab8df54cbab1b05dae27118a586c3d4c4 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab8df54cbab1b05dae27118a586c3d4c4">copy</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;b1, <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;b2)</td></tr>
<tr class="memitem:a6d1f7ecf7379c91d2d97bc70f20d5e24" id="r_a6d1f7ecf7379c91d2d97bc70f20d5e24"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a6d1f7ecf7379c91d2d97bc70f20d5e24 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6d1f7ecf7379c91d2d97bc70f20d5e24">copy</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;b1, <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;b2, int64_t r, int64_t c)</td></tr>
<tr class="memitem:a1b3637aa8820727e70ae7e915f3cde53" id="r_a1b3637aa8820727e70ae7e915f3cde53"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b3637aa8820727e70ae7e915f3cde53">getWidth</a> (clock_t time[], int64_t dim, std::string message, clock_t totals[], int64_t ind)</td></tr>
<tr class="memitem:a246df9b0832e4c4fc450c83aa5e171ab" id="r_a246df9b0832e4c4fc450c83aa5e171ab"><td class="memItemLeft" align="right" valign="top">static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html#a246df9b0832e4c4fc450c83aa5e171ab">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;coords)</td></tr>
<tr class="memdesc:a246df9b0832e4c4fc450c83aa5e171ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats the coordinate set <span class="tt">coords</span> and outputs it to <span class="tt">os</span>.  <br /></td></tr>
<tr class="memitem:ac71356dcc070f0bc5a4ed43864bd9971" id="r_ac71356dcc070f0bc5a4ed43864bd9971"><td class="memItemLeft" align="right" valign="top">static std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html#ac71356dcc070f0bc5a4ed43864bd9971">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;coords)</td></tr>
<tr class="memdesc:ac71356dcc070f0bc5a4ed43864bd9971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a formatted coordinate set from <span class="tt">is</span>.  <br /></td></tr>
<tr class="memitem:aef6c12eea0f3df2908bb03fb2675add3" id="r_aef6c12eea0f3df2908bb03fb2675add3"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html#aef6c12eea0f3df2908bb03fb2675add3">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html">Weights</a> &amp;o)</td></tr>
<tr class="memdesc:aef6c12eea0f3df2908bb03fb2675add3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the type of weights, formats them and outputs them on <code>os</code>.  <br /></td></tr>
<tr class="memitem:a85e872b69d81b7fd8a3abd47aaa29006" id="r_a85e872b69d81b7fd8a3abd47aaa29006"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html#a85e872b69d81b7fd8a3abd47aaa29006">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html">WeightsProjectionDependent</a> &amp;weights)</td></tr>
<tr class="memdesc:a85e872b69d81b7fd8a3abd47aaa29006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads formatted projection-dependent weights into the object <code>weights</code>.  <br /></td></tr>
<tr id="func-members-0" class="groupHeader"><td colspan="2"><div class="groupHeader">Random numbers</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>All the functions of this module use LFSR258 as an underlying source for pseudo-random numbers.</p>
<p>A free (as in freedom) implementation of this generator can be found at <a href="http://simul.iro.umontreal.ca/">http://simul.iro.umontreal.ca/</a> as well as the article presenting it. All the functions generating some sort of random number will advance an integer version of LFSR258 by one state and output a transformation of the state to give a double, an int64_t or bits. </p>
</div></td></tr>
<tr class="memitem:abba336d3a5abb22b8367ddfa37a713e4" id="r_abba336d3a5abb22b8367ddfa37a713e4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abba336d3a5abb22b8367ddfa37a713e4">RandU01</a> ()</td></tr>
<tr class="memdesc:abba336d3a5abb22b8367ddfa37a713e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random number in \([0, 1)\).  <br /></td></tr>
<tr class="memitem:a3f7dd0225a074e885d6d54916757fcec" id="r_a3f7dd0225a074e885d6d54916757fcec"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f7dd0225a074e885d6d54916757fcec">RandInt</a> (int64_t i, int64_t j)</td></tr>
<tr class="memdesc:a3f7dd0225a074e885d6d54916757fcec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a uniform pseudo-random integer in \([i, j]\).  <br /></td></tr>
<tr class="memitem:a3fdad6592203c9b83f2ef7caf7b8441f" id="r_a3fdad6592203c9b83f2ef7caf7b8441f"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fdad6592203c9b83f2ef7caf7b8441f">RandBits</a> (int64_t s)</td></tr>
<tr class="memdesc:a3fdad6592203c9b83f2ef7caf7b8441f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first s pseudo-random bits of the underlying RNG in the form of a s-bit integer.  <br /></td></tr>
<tr class="memitem:a1a68bc6b1e81a03d09ea07fa9efed658" id="r_a1a68bc6b1e81a03d09ea07fa9efed658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a68bc6b1e81a03d09ea07fa9efed658">SetSeed</a> (std::uint64_t seed)</td></tr>
<tr class="memdesc:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the seed of the generator.  <br /></td></tr>
<tr id="func-members-1" class="groupHeader"><td colspan="2"><div class="groupHeader">Mathematical functions</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>These are complete reimplementation of certain mathematical functions, or wrappers for standard C/C++ functions. </p>
</div></td></tr>
<tr class="memitem:a9abb8da9fdc5fa2c37d44165f8660aaf" id="r_a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9abb8da9fdc5fa2c37d44165f8660aaf">mysqrt</a> (double x)</td></tr>
<tr class="memdesc:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns \(\sqrt{x}\) for \(x\ge0\), and \(-1\) for \(x &lt; 0\).  <br /></td></tr>
<tr class="memitem:ae12db9335c229d7c60e570dab50ef05b" id="r_ae12db9335c229d7c60e570dab50ef05b"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:ae12db9335c229d7c60e570dab50ef05b template"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae12db9335c229d7c60e570dab50ef05b">Lg</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae12db9335c229d7c60e570dab50ef05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logarithm of \(x\) in base 2.  <br /></td></tr>
<tr class="memitem:a12e4b6c931cf0a19642828796b3b3bef" id="r_a12e4b6c931cf0a19642828796b3b3bef"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12e4b6c931cf0a19642828796b3b3bef">Lg</a> (std::int64_t x)</td></tr>
<tr class="memdesc:a12e4b6c931cf0a19642828796b3b3bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logarithm of \(x\) in base 2.  <br /></td></tr>
<tr class="memitem:a67e0668a966fb5fa3e22fc1ffa6d59ed" id="r_a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memTemplParams" colspan="2">template&lt;typename Scal&gt; </td></tr>
<tr class="memitem:a67e0668a966fb5fa3e22fc1ffa6d59ed template"><td class="memItemLeft" align="right" valign="top">Scal&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67e0668a966fb5fa3e22fc1ffa6d59ed">abs</a> (Scal x)</td></tr>
<tr class="memdesc:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of \(x\).  <br /></td></tr>
<tr class="memitem:a59016f13e4470ad17683b1cfeb70153c" id="r_a59016f13e4470ad17683b1cfeb70153c"><td class="memTemplParams" colspan="2">template&lt;typename T&gt; </td></tr>
<tr class="memitem:a59016f13e4470ad17683b1cfeb70153c template"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59016f13e4470ad17683b1cfeb70153c">sign</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a59016f13e4470ad17683b1cfeb70153c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sign of <span class="tt">x</span>.  <br /></td></tr>
<tr class="memitem:a15f15a1453b578cb49b2e3deda5a200d" id="r_a15f15a1453b578cb49b2e3deda5a200d"><td class="memTemplParams" colspan="2">template&lt;typename Real&gt; </td></tr>
<tr class="memitem:a15f15a1453b578cb49b2e3deda5a200d template"><td class="memItemLeft" align="right" valign="top">Real&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a15f15a1453b578cb49b2e3deda5a200d">Round</a> (Real x)</td></tr>
<tr class="memdesc:a15f15a1453b578cb49b2e3deda5a200d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of x rounded to the NEAREST integer value.  <br /></td></tr>
<tr class="memitem:a941ee9c334c67adb02d4d7098fa22553" id="r_a941ee9c334c67adb02d4d7098fa22553"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a941ee9c334c67adb02d4d7098fa22553">Factorial</a> (int64_t t)</td></tr>
<tr class="memdesc:a941ee9c334c67adb02d4d7098fa22553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(t!\), the factorial of \(t\) and returns it as an std::int64_t.  <br /></td></tr>
<tr id="func-members-2" class="groupHeader"><td colspan="2"><div class="groupHeader">Division and modular arithmetic</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd><b>Richard:</b> Pour certaines fonctions, les résultats sont mis dans les premiers arguments de la fonction pour être compatible avec <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a>; pour d’autres, ils sont mis dans les derniers arguments pour être compatible avec notre ancienne version de LatMRG en Modula-2. Plutôt détestable. Je crois qu’il faudra un jour réarranger les arguments des fonctions pour qu’elles suivent toutes la même convention que <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a>.</dd></dl>
<p>This module offers function to perform division and find remainders in a standard way. These functions are usefull in the case where one wants to do divisions or find remainders of operations with negative operands. The reason is that <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> and primitive types do not use the same logic when doing calculations on negative numbers.</p>
<p>Basically, <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> will always floor a division and C++ will always truncate a division (which effectively means the floor function is replaced by a roof function if the answer is a negative number). When calculating the remainder of x/y, both apply the same logic but get a different result because they do not do the same division. In both representations, we have that   </p><p class="formulaDsp">
\[   y\cdot(x/y) + x%y = x.
\]
</p>
<p> It turns out that, with negative values, <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> will return an integer with the same sign as y where C++ will return an integer of opposite sign (but both will return the same number modulo y). </p>
</div></td></tr>
<tr class="memitem:aa9056e4da6e74d83c6061650caf9e59f" id="r_aa9056e4da6e74d83c6061650caf9e59f"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:aa9056e4da6e74d83c6061650caf9e59f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa9056e4da6e74d83c6061650caf9e59f">Quotient</a> (const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;a, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;b, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;q)</td></tr>
<tr class="memdesc:aa9056e4da6e74d83c6061650caf9e59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <span class="tt">a/b</span>, truncates the fractional part and puts the result in q.  <br /></td></tr>
<tr class="memitem:a33b2ac0aaf5689dbf1f2225dbf14b327" id="r_a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memTemplParams" colspan="2">template&lt;typename Real&gt; </td></tr>
<tr class="memitem:a33b2ac0aaf5689dbf1f2225dbf14b327 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a33b2ac0aaf5689dbf1f2225dbf14b327">Modulo</a> (const Real &amp;a, const Real &amp;b, Real &amp;r)</td></tr>
<tr class="memdesc:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of a/b and stores its positive equivalent mod b in r.  <br /></td></tr>
<tr class="memitem:ace733f06613d555cb7c6fb617e8a33b7" id="r_ace733f06613d555cb7c6fb617e8a33b7"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:ace733f06613d555cb7c6fb617e8a33b7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ace733f06613d555cb7c6fb617e8a33b7">ModuloTowardZero</a> (const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;a, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;b, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;r)</td></tr>
<tr class="memdesc:ace733f06613d555cb7c6fb617e8a33b7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the element <span class="tt">r = a mod b</span> that is closest to 0.  <br /></td></tr>
<tr class="memitem:a3d24a696d90d81de9128f9af7c6694d5" id="r_a3d24a696d90d81de9128f9af7c6694d5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3d24a696d90d81de9128f9af7c6694d5">ModuloTowardZero</a> (const std::int64_t &amp;a, const std::int64_t &amp;b, std::int64_t &amp;r)</td></tr>
<tr class="memitem:aeccbd231b4002cadbaac0157871f5570" id="r_aeccbd231b4002cadbaac0157871f5570"><td class="memTemplParams" colspan="2">template&lt;typename Real&gt; </td></tr>
<tr class="memitem:aeccbd231b4002cadbaac0157871f5570 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aeccbd231b4002cadbaac0157871f5570">Divide</a> (Real &amp;q, Real &amp;r, const Real &amp;a, const Real &amp;b)</td></tr>
<tr class="memdesc:aeccbd231b4002cadbaac0157871f5570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotient \(q = a/b\) and remainder  \(r = a
\bmod b\).  <br /></td></tr>
<tr class="memitem:a76b74332cd4ded85d51dc6020b930772" id="r_a76b74332cd4ded85d51dc6020b930772"><td class="memTemplParams" colspan="2">template&lt;typename Real&gt; </td></tr>
<tr class="memitem:a76b74332cd4ded85d51dc6020b930772 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a76b74332cd4ded85d51dc6020b930772">DivideRound</a> (const Real &amp;a, const Real &amp;b, Real &amp;q)</td></tr>
<tr class="memdesc:a76b74332cd4ded85d51dc6020b930772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\).  <br /></td></tr>
<tr class="memitem:a14db19d396c104b730dd5ea23a7752b5" id="r_a14db19d396c104b730dd5ea23a7752b5"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14db19d396c104b730dd5ea23a7752b5">gcd</a> (std::int64_t a, std::int64_t b)</td></tr>
<tr class="memdesc:a14db19d396c104b730dd5ea23a7752b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the greatest common divisor of \(a\) and \(b\) by using Stein's binary GCD algorithm.  <br /></td></tr>
<tr class="memitem:abfe3d98ab5a4c91cac2ef0fa59ec897d" id="r_abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:abfe3d98ab5a4c91cac2ef0fa59ec897d template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">Euclide</a> (const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;A, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;B, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;C, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;D, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;E, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;F, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;G)</td></tr>
<tr class="memdesc:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method computes the greater common divisor of <span class="tt">A</span> and <span class="tt">B</span> with Euclid's algorithm.  <br /></td></tr>
<tr class="memitem:a734b88021d0f2b51a6c8ab5ca7c1a5aa" id="r_a734b88021d0f2b51a6c8ab5ca7c1a5aa"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a734b88021d0f2b51a6c8ab5ca7c1a5aa template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a734b88021d0f2b51a6c8ab5ca7c1a5aa">Euclide</a> (const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;A, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;B, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;C, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;D, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;G)</td></tr>
<tr class="memitem:aaa2f58453cd5cd239b67d0eb92b3dadf" id="r_aaa2f58453cd5cd239b67d0eb92b3dadf"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:aaa2f58453cd5cd239b67d0eb92b3dadf template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aaa2f58453cd5cd239b67d0eb92b3dadf">TransposeMatrix</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;mat, <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;mat2)</td></tr>
<tr class="memdesc:aaa2f58453cd5cd239b67d0eb92b3dadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a set of generating vectors in the matrix <span class="tt">mat</span> and iteratively transforms it into an upper triangular lattice basis into the matrix <span class="tt">mat2</span>.  <br /></td></tr>
<tr id="func-members-3" class="groupHeader"><td colspan="2"><div class="groupHeader">Vectors</div></td></tr>
<tr><td colspan="2" class="ititle"><div class="groupText"><p>These are utilities to manipulate vectors ranging from instantiation to scalar product.</p>
<p>******** MOST OF THIS CAN BE REMOVED. WE CAN JUST USE <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> DIRECTLY. ********* </p>
</div></td></tr>
<tr class="memitem:a0416b061a693a6e604d4cc99b14a7050" id="r_a0416b061a693a6e604d4cc99b14a7050"><td class="memTemplParams" colspan="2">template&lt;typename Real&gt; </td></tr>
<tr class="memitem:a0416b061a693a6e604d4cc99b14a7050 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0416b061a693a6e604d4cc99b14a7050">CreateVect</a> (Real *&amp;A, int64_t d)</td></tr>
<tr class="memdesc:a0416b061a693a6e604d4cc99b14a7050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory to <span class="tt">A</span> as an array of <span class="tt">Real</span> of dimension <span class="tt">d</span> and initializes its elements to 0.  <br /></td></tr>
<tr class="memitem:af40f02397dea42344f2c4b6016f5e4f0" id="r_af40f02397dea42344f2c4b6016f5e4f0"><td class="memTemplParams" colspan="2">template&lt;typename Vect&gt; </td></tr>
<tr class="memitem:af40f02397dea42344f2c4b6016f5e4f0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af40f02397dea42344f2c4b6016f5e4f0">CreateVect</a> (Vect &amp;A, int64_t d)</td></tr>
<tr class="memdesc:af40f02397dea42344f2c4b6016f5e4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the vector <span class="tt">A</span> of dimensions <span class="tt">d+1</span> and initializes its elements to 0.  <br /></td></tr>
<tr class="memitem:a3290d1c59f58412753021d37fd9059c3" id="r_a3290d1c59f58412753021d37fd9059c3"><td class="memTemplParams" colspan="2">template&lt;typename Real&gt; </td></tr>
<tr class="memitem:a3290d1c59f58412753021d37fd9059c3 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3290d1c59f58412753021d37fd9059c3">DeleteVect</a> (Real *&amp;A)</td></tr>
<tr class="memdesc:a3290d1c59f58412753021d37fd9059c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the vector <span class="tt">A</span>.  <br /></td></tr>
<tr class="memitem:a74b9ac2e545b1a8e3febffe458488898" id="r_a74b9ac2e545b1a8e3febffe458488898"><td class="memTemplParams" colspan="2">template&lt;typename Vect&gt; </td></tr>
<tr class="memitem:a74b9ac2e545b1a8e3febffe458488898 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a74b9ac2e545b1a8e3febffe458488898">DeleteVect</a> (Vect &amp;A)</td></tr>
<tr class="memdesc:a74b9ac2e545b1a8e3febffe458488898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the vector <span class="tt">A</span>, destroying all the elements it contains.  <br /></td></tr>
<tr class="memitem:aa42f9afe1397f5fba24397a495d995ff" id="r_aa42f9afe1397f5fba24397a495d995ff"><td class="memTemplParams" colspan="2">template&lt;typename Real&gt; </td></tr>
<tr class="memitem:aa42f9afe1397f5fba24397a495d995ff template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa42f9afe1397f5fba24397a495d995ff">SetZero</a> (Real *A, int64_t d)</td></tr>
<tr class="memdesc:aa42f9afe1397f5fba24397a495d995ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first <span class="tt">d</span> of <span class="tt">A</span> to 0.  <br /></td></tr>
<tr class="memitem:afe6937cb95337e67ec106791e9b528c3" id="r_afe6937cb95337e67ec106791e9b528c3"><td class="memTemplParams" colspan="2">template&lt;typename Vect&gt; </td></tr>
<tr class="memitem:afe6937cb95337e67ec106791e9b528c3 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afe6937cb95337e67ec106791e9b528c3">SetZero</a> (Vect &amp;A, int64_t d)</td></tr>
<tr class="memdesc:afe6937cb95337e67ec106791e9b528c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first <span class="tt">d</span> components of <span class="tt">A</span> to 0.  <br /></td></tr>
<tr class="memitem:a2a728d56ee563237fe943ebd333fa3f5" id="r_a2a728d56ee563237fe943ebd333fa3f5"><td class="memTemplParams" colspan="2">template&lt;typename Real&gt; </td></tr>
<tr class="memitem:a2a728d56ee563237fe943ebd333fa3f5 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2a728d56ee563237fe943ebd333fa3f5">SetValue</a> (Real *A, int64_t d, const Real &amp;x)</td></tr>
<tr class="memdesc:a2a728d56ee563237fe943ebd333fa3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first <span class="tt">d</span> components of <span class="tt">A</span> to 0.  <br /></td></tr>
<tr class="memitem:ad18ba9347ad4166201654eb4ad5c6972" id="r_ad18ba9347ad4166201654eb4ad5c6972"><td class="memTemplParams" colspan="2">template&lt;typename Vect&gt; </td></tr>
<tr class="memitem:ad18ba9347ad4166201654eb4ad5c6972 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad18ba9347ad4166201654eb4ad5c6972">toString</a> (const Vect &amp;A, int64_t c, int64_t d, const char *sep=&quot; &quot;)</td></tr>
<tr class="memdesc:ad18ba9347ad4166201654eb4ad5c6972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing <span class="tt">A[c]</span> to <span class="tt">A[d-1]</span> formated as <span class="tt">[A[c]sep...sepA[d-1]]</span>.  <br /></td></tr>
<tr class="memitem:a9c697e5d81b902cbb4283a21104ac62b" id="r_a9c697e5d81b902cbb4283a21104ac62b"><td class="memTemplParams" colspan="2">template&lt;typename Vect&gt; </td></tr>
<tr class="memitem:a9c697e5d81b902cbb4283a21104ac62b template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c697e5d81b902cbb4283a21104ac62b">toString</a> (const Vect &amp;A, int64_t d)</td></tr>
<tr class="memdesc:a9c697e5d81b902cbb4283a21104ac62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing the first <span class="tt">d</span> components of the vector <span class="tt">A</span> as a string.  <br /></td></tr>
<tr class="memitem:abe4590191d21abcdc4b30e0468ac416d" id="r_abe4590191d21abcdc4b30e0468ac416d"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </td></tr>
<tr class="memitem:abe4590191d21abcdc4b30e0468ac416d template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abe4590191d21abcdc4b30e0468ac416d">ProdScal</a> (const <a class="el" href="../../df/dca/FlexTypes_8h.html#a76f03239c9f9103a0d5c88ed1c28451a">IntVec</a> &amp;A, const <a class="el" href="../../df/dca/FlexTypes_8h.html#a76f03239c9f9103a0d5c88ed1c28451a">IntVec</a> &amp;B, int64_t n, Real &amp;D)</td></tr>
<tr class="memdesc:abe4590191d21abcdc4b30e0468ac416d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar product of vectors <span class="tt">A</span> and <span class="tt">B</span> truncated to their <span class="tt">n</span> first components, then puts the result in <span class="tt">D</span>.  <br /></td></tr>
<tr class="memitem:a72aa6823947400db540862e204399ccc" id="r_a72aa6823947400db540862e204399ccc"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a72aa6823947400db540862e204399ccc template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a72aa6823947400db540862e204399ccc">Invert</a> (const <a class="el" href="../../df/dca/FlexTypes_8h.html#a76f03239c9f9103a0d5c88ed1c28451a">IntVec</a> &amp;A, <a class="el" href="../../df/dca/FlexTypes_8h.html#a76f03239c9f9103a0d5c88ed1c28451a">IntVec</a> &amp;B, int64_t n)</td></tr>
<tr class="memdesc:a72aa6823947400db540862e204399ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an input vector <span class="tt">A</span> of dimension <span class="tt">n+1</span> and fill the vector <span class="tt">B</span> with the values <span class="tt">[-A[n] -A[n-1] ... -A[1][1]</span>.  <br /></td></tr>
<tr class="memitem:ab7f1c63a3d050a201b80a4efc541e240" id="r_ab7f1c63a3d050a201b80a4efc541e240"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </td></tr>
<tr class="memitem:ab7f1c63a3d050a201b80a4efc541e240 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab7f1c63a3d050a201b80a4efc541e240">CalcNorm</a> (const <a class="el" href="../../df/dca/FlexTypes_8h.html#a76f03239c9f9103a0d5c88ed1c28451a">IntVec</a> &amp;V, int64_t n, Real &amp;S, <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm)</td></tr>
<tr class="memdesc:ab7f1c63a3d050a201b80a4efc541e240"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <span class="tt">norm</span> norm of vector <span class="tt">V</span> trunctated to its <span class="tt">n</span> first components, and puts the result in <span class="tt">S</span>.  <br /></td></tr>
<tr class="memitem:aa45b3957599dec1d3c32b9dec0d0644c" id="r_aa45b3957599dec1d3c32b9dec0d0644c"><td class="memTemplParams" colspan="2">template&lt;typename Vect&gt; </td></tr>
<tr class="memitem:aa45b3957599dec1d3c32b9dec0d0644c template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aa45b3957599dec1d3c32b9dec0d0644c">CopyPartVec</a> (Vect &amp;toVec, const Vect &amp;fromVec, int64_t c)</td></tr>
<tr class="memdesc:aa45b3957599dec1d3c32b9dec0d0644c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the first <span class="tt">c</span> components of vector <span class="tt">fromVec</span> into vector <span class="tt">toVec</span>.  <br /></td></tr>
<tr class="memitem:aba7ffaaa36d63e57ab488e8815a77bb7" id="r_aba7ffaaa36d63e57ab488e8815a77bb7"><td class="memTemplParams" colspan="2">template&lt;typename Matr&gt; </td></tr>
<tr class="memitem:aba7ffaaa36d63e57ab488e8815a77bb7 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aba7ffaaa36d63e57ab488e8815a77bb7">CopyPartMat</a> (Matr &amp;toMat, const Matr &amp;fromMat, int64_t r, int64_t c)</td></tr>
<tr class="memdesc:aba7ffaaa36d63e57ab488e8815a77bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the first <span class="tt">r</span> rows and <span class="tt">c</span> columns of matrix <span class="tt">fromMat</span> into matrix <span class="tt">toMat</span>.  <br /></td></tr>
<tr class="memitem:a81bbadb519aa05a3a699329d0e08183e" id="r_a81bbadb519aa05a3a699329d0e08183e"><td class="memTemplParams" colspan="2">template&lt;typename Vect&gt; </td></tr>
<tr class="memitem:a81bbadb519aa05a3a699329d0e08183e template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a81bbadb519aa05a3a699329d0e08183e">CopyVect</a> (Vect &amp;A, const Vect &amp;B, int64_t n)</td></tr>
<tr class="memdesc:a81bbadb519aa05a3a699329d0e08183e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the first <span class="tt">n</span> components of vector <span class="tt">B</span> into vector <span class="tt">A</span>.  <br /></td></tr>
<tr class="memitem:a813a622816b9bdc2fc48e8315e16c7e9" id="r_a813a622816b9bdc2fc48e8315e16c7e9"><td class="memTemplParams" colspan="2">template&lt;typename Vect, typename Scal&gt; </td></tr>
<tr class="memitem:a813a622816b9bdc2fc48e8315e16c7e9 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a813a622816b9bdc2fc48e8315e16c7e9">ModifVect</a> (Vect &amp;A, const Vect &amp;B, Scal x, int64_t n)</td></tr>
<tr class="memdesc:a813a622816b9bdc2fc48e8315e16c7e9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the first <span class="tt">n</span> components of vector <span class="tt">B</span> multiplied by <span class="tt">x</span> to first <span class="tt">n</span> components of vector <span class="tt">A</span>.  <br /></td></tr>
<tr class="memitem:a2fb4b9cba25e9e08b49137b70a3b3d95" id="r_a2fb4b9cba25e9e08b49137b70a3b3d95"><td class="memTemplParams" colspan="2">template&lt;typename Vect, typename Scal, typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a2fb4b9cba25e9e08b49137b70a3b3d95 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2fb4b9cba25e9e08b49137b70a3b3d95">ModifVectModulo</a> (Vect &amp;A, const Vect &amp;B, Scal x, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> m, int64_t n)</td></tr>
<tr class="memdesc:a2fb4b9cba25e9e08b49137b70a3b3d95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the first <span class="tt">n</span> components of vector <span class="tt">B</span> multiplied by <span class="tt">x</span> to first <span class="tt">n</span> components of vector <span class="tt">A</span>, modulo m.  <br /></td></tr>
<tr class="memitem:a80edc77542f933dcde8561a54d59c13b" id="r_a80edc77542f933dcde8561a54d59c13b"><td class="memTemplParams" colspan="2">template&lt;typename Vect&gt; </td></tr>
<tr class="memitem:a80edc77542f933dcde8561a54d59c13b template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a80edc77542f933dcde8561a54d59c13b">ChangeSign</a> (Vect &amp;A, int64_t n)</td></tr>
<tr class="memdesc:a80edc77542f933dcde8561a54d59c13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the sign (multiplies by -1) the first <span class="tt">n</span> components of vector <span class="tt">A</span>.  <br /></td></tr>
<tr class="memitem:a037fd4e351a079af3d672889e89666e0" id="r_a037fd4e351a079af3d672889e89666e0"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a037fd4e351a079af3d672889e89666e0">GCD2vect</a> (std::vector&lt; std::int64_t &gt; V, int64_t k, int64_t n)</td></tr>
<tr class="memdesc:a037fd4e351a079af3d672889e89666e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of <span class="tt">V[k],...,V[n-1]</span>.  <br /></td></tr>
<tr id="func-members-4" class="groupHeader"><td colspan="2"><div class="groupHeader">Matrices</div></td></tr>
<tr class="memitem:a1f76eab56c1a9defffae5b8bf629290f" id="r_a1f76eab56c1a9defffae5b8bf629290f"><td class="memTemplParams" colspan="2">template&lt;typename Real&gt; </td></tr>
<tr class="memitem:a1f76eab56c1a9defffae5b8bf629290f template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1f76eab56c1a9defffae5b8bf629290f">CreateMatr</a> (Real **&amp;A, int64_t d)</td></tr>
<tr class="memdesc:a1f76eab56c1a9defffae5b8bf629290f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory to a square matrix <span class="tt">A</span> of dimensions \(d \times d\) and initializes its elements to 0.  <br /></td></tr>
<tr class="memitem:add086c03b1352ae2ed9413068d5e3f6d" id="r_add086c03b1352ae2ed9413068d5e3f6d"><td class="memTemplParams" colspan="2">template&lt;typename Real&gt; </td></tr>
<tr class="memitem:add086c03b1352ae2ed9413068d5e3f6d template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#add086c03b1352ae2ed9413068d5e3f6d">CreateMatr</a> (Real **&amp;A, int64_t line, int64_t col)</td></tr>
<tr class="memdesc:add086c03b1352ae2ed9413068d5e3f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the matrix <span class="tt">A</span> of dimensions  \(\text{line} \times
\text{col}\) and initializes its elements to 0.  <br /></td></tr>
<tr class="memitem:a03d33e22aad4f4a29a20c11bb96c7b02" id="r_a03d33e22aad4f4a29a20c11bb96c7b02"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a03d33e22aad4f4a29a20c11bb96c7b02 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a03d33e22aad4f4a29a20c11bb96c7b02">CreateMatr</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;A, int64_t d)</td></tr>
<tr class="memdesc:a03d33e22aad4f4a29a20c11bb96c7b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the matrix <span class="tt">A</span> to a square matrix of dimensions <span class="tt">d*d</span> and re-initializes its elements to 0.  <br /></td></tr>
<tr class="memitem:afcf8fb861104547f84a5d73c33401fe6" id="r_afcf8fb861104547f84a5d73c33401fe6"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:afcf8fb861104547f84a5d73c33401fe6 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#afcf8fb861104547f84a5d73c33401fe6">CreateMatr</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;A, int64_t line, int64_t col)</td></tr>
<tr class="memdesc:afcf8fb861104547f84a5d73c33401fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the matrix <span class="tt">A</span> to a matrix of dimensions \(line \times col\) and re-initializes its elements to 0.  <br /></td></tr>
<tr class="memitem:a2b3fbf56b76e1a95c0f935bb0acca3a4" id="r_a2b3fbf56b76e1a95c0f935bb0acca3a4"><td class="memTemplParams" colspan="2">template&lt;typename Real&gt; </td></tr>
<tr class="memitem:a2b3fbf56b76e1a95c0f935bb0acca3a4 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2b3fbf56b76e1a95c0f935bb0acca3a4">DeleteMatr</a> (Real **&amp;A, int64_t d)</td></tr>
<tr class="memdesc:a2b3fbf56b76e1a95c0f935bb0acca3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the \(d \times d\) matrix <span class="tt">A</span>.  <br /></td></tr>
<tr class="memitem:adb7b6d86bbad87845663bfb8e8e00d06" id="r_adb7b6d86bbad87845663bfb8e8e00d06"><td class="memTemplParams" colspan="2">template&lt;typename Real&gt; </td></tr>
<tr class="memitem:adb7b6d86bbad87845663bfb8e8e00d06 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adb7b6d86bbad87845663bfb8e8e00d06">DeleteMatr</a> (Real **&amp;A, int64_t line, int64_t col)</td></tr>
<tr class="memdesc:adb7b6d86bbad87845663bfb8e8e00d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the matrix <span class="tt">A</span> of dimension  \(\text{line} \times
\text{col}\).  <br /></td></tr>
<tr class="memitem:a0f66d14fcb15c8a2e358b9ab5e08b524" id="r_a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a0f66d14fcb15c8a2e358b9ab5e08b524 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0f66d14fcb15c8a2e358b9ab5e08b524">DeleteMatr</a> (<a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;A)</td></tr>
<tr class="memdesc:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the <span class="tt"><a class="el" href="../../d2/d5a/namespaceNTL.html#a2deeffef7195d2c3508b7618c6aed677" title="Sets x to 0.">clear()</a></span> method on <span class="tt">A</span>.  <br /></td></tr>
<tr class="memitem:adfb6cc508f7a12e043a9d39eab4e99c0" id="r_adfb6cc508f7a12e043a9d39eab4e99c0"><td class="memTemplParams" colspan="2">template&lt;typename Matr&gt; </td></tr>
<tr class="memitem:adfb6cc508f7a12e043a9d39eab4e99c0 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adfb6cc508f7a12e043a9d39eab4e99c0">CopyMatr</a> (Matr &amp;A, const Matr &amp;B, int64_t n)</td></tr>
<tr class="memdesc:adfb6cc508f7a12e043a9d39eab4e99c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the \(n \times n\) submatrix of the first lines and columns of <span class="tt">B</span> into matrix <span class="tt">A</span>.  <br /></td></tr>
<tr class="memitem:a620105c7b91ca77c4259bd116d48ed61" id="r_a620105c7b91ca77c4259bd116d48ed61"><td class="memTemplParams" colspan="2">template&lt;typename Matr&gt; </td></tr>
<tr class="memitem:a620105c7b91ca77c4259bd116d48ed61 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a620105c7b91ca77c4259bd116d48ed61">CopyMatr</a> (Matr &amp;A, const Matr &amp;B, int64_t line, int64_t col)</td></tr>
<tr class="memdesc:a620105c7b91ca77c4259bd116d48ed61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the \(\text{line} \times col\) submatrix of the first lines and columns of <span class="tt">B</span> into matrix <span class="tt">A</span>.  <br /></td></tr>
<tr class="memitem:a6c4c9e2b77c4dc22c74401738c15c8b8" id="r_a6c4c9e2b77c4dc22c74401738c15c8b8"><td class="memTemplParams" colspan="2">template&lt;typename MatT&gt; </td></tr>
<tr class="memitem:a6c4c9e2b77c4dc22c74401738c15c8b8 template"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6c4c9e2b77c4dc22c74401738c15c8b8">toStr</a> (const MatT &amp;mat, int64_t d1, int64_t d2, int64_t prec=2)</td></tr>
<tr class="memdesc:a6c4c9e2b77c4dc22c74401738c15c8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that is a representation of <span class="tt">mat</span>.  <br /></td></tr>
<tr class="memitem:adc093dc4ab413df7a7a08495c06677d1" id="r_adc093dc4ab413df7a7a08495c06677d1"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:adc093dc4ab413df7a7a08495c06677d1 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#adc093dc4ab413df7a7a08495c06677d1">ProductDiagonal</a> (const NTL::Mat&lt; <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &gt; &amp;A, long dim, <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;prod)</td></tr>
<tr class="memdesc:adc093dc4ab413df7a7a08495c06677d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of the diagonal elements of the matrix <span class="tt">A</span>, which is assumed to be square <span class="tt">dim x dim</span>.  <br /></td></tr>
<tr class="memitem:a025780512339ad633b6878b3663d6869" id="r_a025780512339ad633b6878b3663d6869"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a025780512339ad633b6878b3663d6869 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a025780512339ad633b6878b3663d6869">CheckTriangular</a> (const NTL::Mat&lt; <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &gt; &amp;A, long dim, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> m)</td></tr>
<tr class="memdesc:a025780512339ad633b6878b3663d6869"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the upper \(\text{dim} \times \text{dim}\) submatrix of <span class="tt">A</span> is triangular modulo <span class="tt">m</span>.  <br /></td></tr>
<tr class="memitem:abf5df314f92821aa4256133b3342f986" id="r_abf5df314f92821aa4256133b3342f986"><td class="memTemplParams" colspan="2">template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:abf5df314f92821aa4256133b3342f986 template"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abf5df314f92821aa4256133b3342f986">checkInverseModm</a> (const NTL::Mat&lt; <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &gt; &amp;A, const NTL::Mat&lt; <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &gt; &amp;B, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> m)</td></tr>
<tr class="memdesc:abf5df314f92821aa4256133b3342f986"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if A and B are m-dual to each other.  <br /></td></tr>
<tr class="memitem:a04449fdf436107c5ef230401edf3a200" id="r_a04449fdf436107c5ef230401edf3a200"><td class="memTemplParams" colspan="2">template&lt;typename Matr, typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </td></tr>
<tr class="memitem:a04449fdf436107c5ef230401edf3a200 template"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a04449fdf436107c5ef230401edf3a200">calcDual</a> (const Matr &amp;A, Matr &amp;B, int64_t d, const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;m)</td></tr>
<tr class="memdesc:a04449fdf436107c5ef230401edf3a200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an upper triangular basis <span class="tt">A</span> and computes an m-dual lattice basis to this matrix.  <br /></td></tr>
<tr id="func-members-5" class="groupHeader"><td colspan="2"><div class="groupHeader">Debugging functions</div></td></tr>
<tr class="memitem:a852fa8fe7dda3213afd5db3e65caa43c" id="r_a852fa8fe7dda3213afd5db3e65caa43c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a852fa8fe7dda3213afd5db3e65caa43c">myExit</a> (std::string msg)</td></tr>
<tr class="memdesc:a852fa8fe7dda3213afd5db3e65caa43c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Simple error exit function, prints <span class="tt">msg</span> on exit.  <br /></td></tr>
<tr id="func-members-6" class="groupHeader"><td colspan="2"><div class="groupHeader">Printing functions and operators</div></td></tr>
<tr class="memitem:a9c5c3904af8b547eb32bba8d42b5c3b1" id="r_a9c5c3904af8b547eb32bba8d42b5c3b1"><td class="memTemplParams" colspan="2">template&lt;class K, class T, class C, class A&gt; </td></tr>
<tr class="memitem:a9c5c3904af8b547eb32bba8d42b5c3b1 template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9c5c3904af8b547eb32bba8d42b5c3b1">operator&lt;&lt;</a> (std::ostream &amp;out, const std::map&lt; K, T, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a9c5c3904af8b547eb32bba8d42b5c3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for maps.  <br /></td></tr>
<tr class="memitem:a00572b373d97cc0227547867bd1cde0d" id="r_a00572b373d97cc0227547867bd1cde0d"><td class="memTemplParams" colspan="2">template&lt;class T1, class T2&gt; </td></tr>
<tr class="memitem:a00572b373d97cc0227547867bd1cde0d template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a00572b373d97cc0227547867bd1cde0d">operator&lt;&lt;</a> (std::ostream &amp;out, const std::pair&lt; T1, T2 &gt; &amp;x)</td></tr>
<tr class="memdesc:a00572b373d97cc0227547867bd1cde0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <br /></td></tr>
<tr class="memitem:a0ddcbc9a5e063f35176f9c48d38f2650" id="r_a0ddcbc9a5e063f35176f9c48d38f2650"><td class="memTemplParams" colspan="2">template&lt;class T, class A&gt; </td></tr>
<tr class="memitem:a0ddcbc9a5e063f35176f9c48d38f2650 template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0ddcbc9a5e063f35176f9c48d38f2650">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; T, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a0ddcbc9a5e063f35176f9c48d38f2650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <br /></td></tr>
<tr class="memitem:a97b28ac9e1e15b5ede018202a73fe664" id="r_a97b28ac9e1e15b5ede018202a73fe664"><td class="memTemplParams" colspan="2">template&lt;class K, class C, class A&gt; </td></tr>
<tr class="memitem:a97b28ac9e1e15b5ede018202a73fe664 template"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a97b28ac9e1e15b5ede018202a73fe664">operator&lt;&lt;</a> (std::ostream &amp;out, const std::set&lt; K, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a97b28ac9e1e15b5ede018202a73fe664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for sets.  <br /></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 id="header-var-members" class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac9adbd421a1148216c8eac1b7d96a5b8" id="r_ac9adbd421a1148216c8eac1b7d96a5b8"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9adbd421a1148216c8eac1b7d96a5b8">MAX_LONG_DOUBLE</a> = 9007199254740992.0</td></tr>
<tr class="memdesc:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum integer that can be represented exactly as a <span class="tt">double</span>: \(2^{53}\).  <br /></td></tr>
<tr class="memitem:ae5f464bde0cd79b7bbc47ff090e49b31" id="r_ae5f464bde0cd79b7bbc47ff090e49b31"><td class="memItemLeft" align="right" valign="top">const std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae5f464bde0cd79b7bbc47ff090e49b31">TWO_EXP</a> []</td></tr>
<tr class="memdesc:ae5f464bde0cd79b7bbc47ff090e49b31"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of powers of 2: <span class="tt">TWO_EXP[</span> \(i\)<span class="tt">]</span> \(= 2^i\), \(i=0, 1, …, 63\).  <br /></td></tr>
</table>
<a name="details" id="details"></a><h2 id="header-details" class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a> namespace. </p>
<p>These functions are in the latticetester namespace. </p>
</div><a name="doc-typedef-members" id="doc-typedef-members"></a><h2 id="header-doc-typedef-members" class="groupheader">Typedef Documentation</h2>
<a id="a951f7e7b03767aa0971dde55f9d328ec" name="a951f7e7b03767aa0971dde55f9d328ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951f7e7b03767aa0971dde55f9d328ec">&#9670;&#160;</a></span>Weight</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="#a951f7e7b03767aa0971dde55f9d328ec">LatticeTester::Weight</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A scalar weight type. </p>

</div>
</div>
<a name="doc-enum-members" id="doc-enum-members"></a><h2 id="header-doc-enum-members" class="groupheader">Enumeration Type Documentation</h2>
<a id="a9770e4d57aa715e249cd7e700c6f37e4" name="a9770e4d57aa715e249cd7e700c6f37e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9770e4d57aa715e249cd7e700c6f37e4">&#9670;&#160;</a></span>NormType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">LatticeTester::NormType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The available norm types to measure the length of vectors. </p>
<p>For \(X = (x_1,…,x_t)\):<br  />
 <span class="tt">SUPNORM</span> corresponds to \(\Vert X\Vert= \max(|x_1|,…,|x_t|)\).<br  />
 <span class="tt">L1NORM</span> corresponds to \(\Vert X\Vert= |x_1|+\cdots+|x_t|\).<br  />
 <span class="tt">L2NORM</span> corresponds to \(\Vert X\Vert= (x_1^2+\cdots+x_t^2)^{1/2}\).<br  />
 <span class="tt">ZAREMBANORM</span> corresponds to \(\Vert X\Vert= \max(1, |x_1|)\cdots\max(1, |x_t|)\). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9770e4d57aa715e249cd7e700c6f37e4a3e12e2ca7e65c77c86a8afbbf1faed0d" name="a9770e4d57aa715e249cd7e700c6f37e4a3e12e2ca7e65c77c86a8afbbf1faed0d"></a>SUPNORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9770e4d57aa715e249cd7e700c6f37e4a6031a75d242058c5b26d05f510267b41" name="a9770e4d57aa715e249cd7e700c6f37e4a6031a75d242058c5b26d05f510267b41"></a>L1NORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9770e4d57aa715e249cd7e700c6f37e4a2d8982335f008ef95768bd7ec450d86b" name="a9770e4d57aa715e249cd7e700c6f37e4a2d8982335f008ef95768bd7ec450d86b"></a>L2NORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9770e4d57aa715e249cd7e700c6f37e4a9dd28fa34c8fd3331bd55e85d9b8ff2b" name="a9770e4d57aa715e249cd7e700c6f37e4a9dd28fa34c8fd3331bd55e85d9b8ff2b"></a>ZAREMBANORM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ab747c1cbb0f5e47fef711b62327a8e90" name="ab747c1cbb0f5e47fef711b62327a8e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab747c1cbb0f5e47fef711b62327a8e90">&#9670;&#160;</a></span>NormaType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90">LatticeTester::NormaType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different choices of output formats. </p>
<p><span class="tt">TERM</span>: the results will appear only on the terminal screen.<br  />
 <span class="tt">RES</span>: the results will be in plain text and sent to a <span class="tt">.res</span> file.<br  />
 <span class="tt">TEX</span>: the results will be in a LaTeX file with extension <span class="tt">.tex</span>.<br  />
 <span class="tt">GEN</span>: a list of retained generators will be sent to a file with extension <span class="tt">.gen</span>, in a specific format so this list can be read again for further analysis. Types of problems that <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a> can handle. Not sure if we still need this. ******* This can be supersed by the Real type.</p>
<p>Types of precision that the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> can use for real numbers: <span class="tt">DOUBLE</span> &ndash; double <span class="tt">QUADRUPLE</span> &ndash; quad_float (quasi quadruple precision) this is useful when roundoff errors can cause problems <span class="tt">XDOUBLE</span> &ndash; xdouble (extended exponent doubles) this is useful when numbers get too big <span class="tt">RR</span> &ndash; RR (arbitrary precision floating point). The choice <span class="tt">DOUBLE</span> is usually the fastest, but may be prone to roundoff errors and/or overflow. See <span class="tt"><a href="https://github.com/u-u-h/NTL/blob/master/doc/LLL.txt">https://github.com/u-u-h/NTL/blob/master/doc/LLL.txt</a></span>. Indicates whether an integer is prime, probably prime, composite or its status is unknown (or we do not care). Merit criteria to measure the quality of generators or lattices. TO DO: this list is not very clear. Maybe outdated. ****************</p>
<p><span class="tt">LENGTH</span>: Only using the length of the shortest vector as a criterion. <span class="tt">SPECTRAL</span>: figure of merit \(S_T\) based on the spectral test.<br  />
 <span class="tt">BEYER</span>: figure of merit is the Beyer quotient \(Q_T\).<br  />
 <span class="tt">PALPHA</span>: figure of merit based on \(P_{\alpha}\).<br  />
 <span class="tt">BOUND_JS</span>: figure of merit based on the Joe-Sinescu bound <a class="el" href="../../d0/de3/citelist.html#CITEREF_rsin08a">[15]</a>.<br  />
 ??? Different types of normalizations that can be used for shortest-vector lengths. Corresponds to different ways of approximating the Hermite constants <span class="tt">gamma_t</span>.</p>
<p><span class="tt">BESTLAT</span>: the value used for \(d_t^*\) corresponds to the best lattice.<br  />
 <span class="tt">BESTUPBOUND</span>: the value used for \(d_t^*\) corresponds to the best bound known to us.<br  />
 <span class="tt">LAMINATED</span>: the value used for \(d_t^*\) corresponds to the best <em>laminated</em> lattice.<br  />
 <span class="tt">ROGERS</span>: the value for \(d_t^*\) is obtained from <em>Rogers’</em> bound on the density of sphere packing.<br  />
 <span class="tt">MINKL1</span>: the value for \(d_t^*\) is obtained from the theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\mathcal{L}}_1\) norm.<br  />
 <span class="tt">MINKHLAW</span>: the value for \(d_t^*\) is obtained from <em>Minkowski’</em> theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\mathcal{L}}_2\) norm.<br  />
 <span class="tt">NONE</span>: no normalization will be used.<br  />
 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90a6f65388b2929fedcf40d456d30df3551" name="ab747c1cbb0f5e47fef711b62327a8e90a6f65388b2929fedcf40d456d30df3551"></a>BESTLAT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90ab2dc4f1b4d3313f8df8baf113e937d6e" name="ab747c1cbb0f5e47fef711b62327a8e90ab2dc4f1b4d3313f8df8baf113e937d6e"></a>BESTUPBOUND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90ae8842bb9870dacacc65ef1ad46f8fa4b" name="ab747c1cbb0f5e47fef711b62327a8e90ae8842bb9870dacacc65ef1ad46f8fa4b"></a>LAMINATED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90a81b5bfa5986a0cf0f014837542837641" name="ab747c1cbb0f5e47fef711b62327a8e90a81b5bfa5986a0cf0f014837542837641"></a>ROGERS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90a5e579ba5452180d37e3e048875ba46e5" name="ab747c1cbb0f5e47fef711b62327a8e90a5e579ba5452180d37e3e048875ba46e5"></a>MINKL1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90ade77243f2c15d6fcd3ba37d25bf82ce9" name="ab747c1cbb0f5e47fef711b62327a8e90ade77243f2c15d6fcd3ba37d25bf82ce9"></a>MINKHLAW&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90a5e9d13ae2852670258864320734e0cbf" name="ab747c1cbb0f5e47fef711b62327a8e90a5e9d13ae2852670258864320734e0cbf"></a>NONE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a0d2f9ab69a9d586b8273cbb29bb105fe" name="a0d2f9ab69a9d586b8273cbb29bb105fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2f9ab69a9d586b8273cbb29bb105fe">&#9670;&#160;</a></span>CalcType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105fe">LatticeTester::CalcType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which type of calculation is considered for the \(P_{\alpha}\) test. </p>
<p><a class="anchor" id="REF__Const_CalcType_def"></a>Is this used anywhere? ************</p>
<p><span class="tt">PAL</span> is for the \(P_{\alpha}\) test. <br  />
 <span class="tt">BAL</span> is for the bound on the \(P_{\alpha}\) test. <br  />
 <span class="tt">NORMPAL</span> is for the \(P_{\alpha}\) test <span class="tt">PAL</span>, with the result normalized over the <span class="tt">BAL</span> bound. <br  />
 <span class="tt">SEEKPAL</span> is for the \(P_{\alpha}\) seek, which searches for good values of the multiplier. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0d2f9ab69a9d586b8273cbb29bb105feae444ad54301419ac37ef878aedb20234" name="a0d2f9ab69a9d586b8273cbb29bb105feae444ad54301419ac37ef878aedb20234"></a>PAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d2f9ab69a9d586b8273cbb29bb105fea18fa93c0ce684acf5f50252d813034f4" name="a0d2f9ab69a9d586b8273cbb29bb105fea18fa93c0ce684acf5f50252d813034f4"></a>NORMPAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d2f9ab69a9d586b8273cbb29bb105fea1eea8810a9a8d0e0721cbab47592d29c" name="a0d2f9ab69a9d586b8273cbb29bb105fea1eea8810a9a8d0e0721cbab47592d29c"></a>BAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d2f9ab69a9d586b8273cbb29bb105feae7e8d0e1b5a15810847d798d1fe0b039" name="a0d2f9ab69a9d586b8273cbb29bb105feae7e8d0e1b5a15810847d798d1fe0b039"></a>SEEKPAL&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="af2a213e64bd54d3e33a7aff0f80068cb" name="af2a213e64bd54d3e33a7aff0f80068cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a213e64bd54d3e33a7aff0f80068cb">&#9670;&#160;</a></span>ReductionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cb">LatticeTester::ReductionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of all the possible lattice reductions implemented in <span class="tt"><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="LatticeTester namespace.">LatticeTester</a></span>. </p>
<p><span class="tt">PAIR</span>: Pairwise reductions only. <span class="tt">LLL</span>: LLL reduction only. <span class="tt">BKZ</span>: block Korkine-Zolotarev reduction only. <span class="tt">BB</span>: direct shortest vector search with BB (no pre-red.). <span class="tt">PAIRBB</span>: Pairwise reduction followed by BB. <span class="tt">LLLBB</span>: LLL followed by BB. <span class="tt">BKZBB</span>: BKZ followed by BB. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af2a213e64bd54d3e33a7aff0f80068cba7212a3bb53b382d1e38c3f8cdf7a47cf" name="af2a213e64bd54d3e33a7aff0f80068cba7212a3bb53b382d1e38c3f8cdf7a47cf"></a>PAIR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2a213e64bd54d3e33a7aff0f80068cba8d04551154f945a747c129cdabff4af5" name="af2a213e64bd54d3e33a7aff0f80068cba8d04551154f945a747c129cdabff4af5"></a>LLL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2a213e64bd54d3e33a7aff0f80068cba14aace9298ad3f3297ff86c30b8d34eb" name="af2a213e64bd54d3e33a7aff0f80068cba14aace9298ad3f3297ff86c30b8d34eb"></a>BKZ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2a213e64bd54d3e33a7aff0f80068cba00217b110040213df758637d15e36795" name="af2a213e64bd54d3e33a7aff0f80068cba00217b110040213df758637d15e36795"></a>BB&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2a213e64bd54d3e33a7aff0f80068cba59eedbabbb28a332f4d36822d74ae6dd" name="af2a213e64bd54d3e33a7aff0f80068cba59eedbabbb28a332f4d36822d74ae6dd"></a>PAIRBB&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2a213e64bd54d3e33a7aff0f80068cba841193f6d276a17aff255f4f59a712d9" name="af2a213e64bd54d3e33a7aff0f80068cba841193f6d276a17aff255f4f59a712d9"></a>LLLBB&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2a213e64bd54d3e33a7aff0f80068cba3c1372bd908125ef772819276035b74c" name="af2a213e64bd54d3e33a7aff0f80068cba3c1372bd908125ef772819276035b74c"></a>BKZBB&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a5bf461b8f167cc8c7ebebc8ee6a96ee4" name="a5bf461b8f167cc8c7ebebc8ee6a96ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">&#9670;&#160;</a></span>DecompTypeBB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">LatticeTester::DecompTypeBB</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Two possible ways of obtaining a triangular matrix to compute the bounds in the BB algorithm. </p>
<p><span class="tt">CHOLESKY</span>: use a lower-triangular matrix obtained as the Cholesky decomposition of the matrix of scalar products. <span class="tt">TRIANGULAR</span>: use a lower-triangular basis </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5bf461b8f167cc8c7ebebc8ee6a96ee4a3266f268976e38e1d5e53fb38ef4de9d" name="a5bf461b8f167cc8c7ebebc8ee6a96ee4a3266f268976e38e1d5e53fb38ef4de9d"></a>CHOLESKY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5bf461b8f167cc8c7ebebc8ee6a96ee4ab3f7f0887ca0f53844b887588c92cd66" name="a5bf461b8f167cc8c7ebebc8ee6a96ee4ab3f7f0887ca0f53844b887588c92cd66"></a>TRIANGULAR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1ff6c9ee29ca0bac6c63d2622508aa46" name="a1ff6c9ee29ca0bac6c63d2622508aa46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff6c9ee29ca0bac6c63d2622508aa46">&#9670;&#160;</a></span>ProjConstructType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">LatticeTester::ProjConstructType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Two possible ways of computing the basis for a projection. </p>
<p><span class="tt">LLLPROJ</span>: uses LLL reduction. <span class="tt">UPPERTRIPROJ</span>: use an upper-triangular basis construction. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1ff6c9ee29ca0bac6c63d2622508aa46a59c23f7e8d888fc3e79108dea9475dbb" name="a1ff6c9ee29ca0bac6c63d2622508aa46a59c23f7e8d888fc3e79108dea9475dbb"></a>LLLPROJ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ff6c9ee29ca0bac6c63d2622508aa46abbfbd0f53d264fdd705b4416b8c36d87" name="a1ff6c9ee29ca0bac6c63d2622508aa46abbfbd0f53d264fdd705b4416b8c36d87"></a>UPPERTRIPROJ&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a5e9e347d07097a1a3c82f1699ff93d58" name="a5e9e347d07097a1a3c82f1699ff93d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9e347d07097a1a3c82f1699ff93d58">&#9670;&#160;</a></span>MeritType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a5e9e347d07097a1a3c82f1699ff93d58">LatticeTester::MeritType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Two different types of figures of merit. </p>
<p><span class="tt">MERITM</span>: based on shortest vector. <span class="tt">MERITQ</span>: based on Beyer quotient. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5e9e347d07097a1a3c82f1699ff93d58a094d81300c3a1bd13d96d01e8c53a3ad" name="a5e9e347d07097a1a3c82f1699ff93d58a094d81300c3a1bd13d96d01e8c53a3ad"></a>MERITM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5e9e347d07097a1a3c82f1699ff93d58ad875e35fbaf2f2e8be530376935b6c6d" name="a5e9e347d07097a1a3c82f1699ff93d58ad875e35fbaf2f2e8be530376935b6c6d"></a>MERITQ&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a name="doc-func-members" id="doc-func-members"></a><h2 id="header-doc-func-members" class="groupheader">Function Documentation</h2>
<a id="aa57d18b5ef393224b7f1829d5682d759" name="aa57d18b5ef393224b7f1829d5682d759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa57d18b5ef393224b7f1829d5682d759">&#9670;&#160;</a></span>LLLConstruction0() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real LatticeTester::LLLConstruction0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function takes a set of generating vectors of a lattice in matrix <span class="tt">gen</span> and finds a lattice basis by applying LLL reduction with the given value of <span class="tt">delta</span>, using the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> implementation specified by <span class="tt">prec</span>. </p>
<p>The basis is returned in the first rows of <span class="tt">gen</span>, in a number of rows equal to its rank. See the file <span class="tt">EnumTypes</span> and the documentation of LLL in <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> for the meaning and choices for <span class="tt">prec</span>. The default value of delta is not very close to 1 because the goal here is just to compute a basis. It can be taken much closer to 1 if we really prefer a highly-reduced basis. The optional parameters <span class="tt">r</span> and <span class="tt">c</span> indicate the numbers of rows and columns of the matrix <span class="tt">gen</span> that are actually used. When they are 0 (the default values), then these numbers are taken to be the dimensions of the matrix <span class="tt">gen</span>. When <span class="tt">sqlen</span> is not 0, the square lengths of the basis vectors are returned in this array, exactly as in the <span class="tt"><a class="el" href="../../d0/dd3/LLL__lt_8h.html" title="These static functions are slightly modified versions of the LLL and BKZ functions of NTL.">LLL_lt.h</a></span> module. The function returns the square length of the shortest basis vector. The basis <span class="tt">gen</span> is never resized.</p>
<p>This function <em>does not</em> assume that all vectors \(m e_i\) belong to the lattice, so it may return a basis matrix that has fewer rows than columns! To make sure that these vectors belong to the lattice, we can add them explicitly beforehand to the set of generating vectors, or call the next function, which does that. </p>

</div>
</div>
<a id="a307eeecf6b0886bf41fdf57cd02f67b3" name="a307eeecf6b0886bf41fdf57cd02f67b3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a307eeecf6b0886bf41fdf57cd02f67b3">&#9670;&#160;</a></span>LLLBasisConstruction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real LatticeTester::LLLBasisConstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <span class="tt">LLLConstruction0</span>, except that this function adds explicitly all the vectors \(m \mathbf{e}_i\) to the generating set, so there will be <span class="tt">r + c</span> rows initially and the function always returns a square matrix. </p>
<p>The matrix <span class="tt">gen</span> is not resized by this function, so it can remain larger than the lattice dimension. </p>

</div>
</div>
<a id="a14056d5418242137d62897e30468af3a" name="a14056d5418242137d62897e30468af3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14056d5418242137d62897e30468af3a">&#9670;&#160;</a></span>lowerTriangularBasis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::lowerTriangularBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a set of generating vectors in the matrix <span class="tt">gen</span> and iteratively transforms it into a lower triangular lattice basis into the matrix <span class="tt">basis</span>. </p>
<p>This lattice is assumed to contain all the vectors of the form \(m \mathbf{e}_j\), so these vectors are added implicitly to the generating set. Apart from that, all the entries of <span class="tt">gen</span> given as input are assumed to be reduced modulo the scaling factor <span class="tt">m</span> and all the computations are done modulo <span class="tt">m</span>. The matrix <span class="tt">basis</span> is assumed to be large enough to contain the new basis, whose dimension should be the number of columns taken from <span class="tt">gen</span>. After the execution, <span class="tt">gen</span> will contain irrelevant information (garbage) and <span class="tt">basis</span> will contain an upper triangular basis. The algorithm is explained in the lattice tester guide. Important: <span class="tt">gen</span> and <span class="tt">basis</span> must be different <span class="tt">IntMat</span> objects.</p>
<p>When <span class="tt">r</span> and/or <span class="tt">c</span> are strictly positive, they specify the numbers of rows and columns of <span class="tt">gen</span> that are actually used, as in <span class="tt">LLLConstruction0</span>. The matrix <span class="tt">gen</span> is never resized. The new basis should be c x c. </p>

</div>
</div>
<a id="a6a4f630a4729e98fe79e334181e26ce9" name="a6a4f630a4729e98fe79e334181e26ce9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a4f630a4729e98fe79e334181e26ce9">&#9670;&#160;</a></span>upperTriangularBasis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::upperTriangularBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <span class="tt">lowerTriangularBasis</span>, except that the returned basis is upper triangular. </p>

</div>
</div>
<a id="abf5110b05c562288e6c78894b67309d1" name="abf5110b05c562288e6c78894b67309d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5110b05c562288e6c78894b67309d1">&#9670;&#160;</a></span>upperTriangularBasisOld96() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::upperTriangularBasisOld96 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The old version from <a class="el" href="../../d0/de3/citelist.html#CITEREF_rcou96a">[5]</a> and <a class="el" href="../../d0/de3/citelist.html#CITEREF_ilec00l">[10]</a>. </p>

</div>
</div>
<a id="a577b7e284f468095fc9063219950a309" name="a577b7e284f468095fc9063219950a309"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a577b7e284f468095fc9063219950a309">&#9670;&#160;</a></span>mDualLowerTriangular() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualLowerTriangular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a lower-triangular basis matrix <span class="tt">basis</span> and computes the m-dual basis <span class="tt">basisDual</span>. </p>
<p>The function assumes that each coefficient on the diagonal of <span class="tt">basis</span> is nonzero and divides <span class="tt">m</span>. That is, the basis matrix must be square and m-invertible. Since the basis is lower triangular, its m-dual will be upper triangular. When <span class="tt">dim &gt; 0</span>, it must give the number of rows and columns of the matrix <span class="tt">basis</span> that is actually used. Otherwise (by default) the function uses <span class="tt">basis.numCols()</span>. </p>

</div>
</div>
<a id="a74010e8963e3be1e042c2a530ecaa991" name="a74010e8963e3be1e042c2a530ecaa991"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74010e8963e3be1e042c2a530ecaa991">&#9670;&#160;</a></span>mDualLowerTriangularMod0() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualLowerTriangularMod0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <span class="tt">mDualLowerTriangular</span> and then reduces all the non-diagonal <span class="tt">mod m</span> towards 0. </p>

</div>
</div>
<a id="a7076873730fe2764258ce837c228ec41" name="a7076873730fe2764258ce837c228ec41"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7076873730fe2764258ce837c228ec41">&#9670;&#160;</a></span>mDualUpperTriangular() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualUpperTriangular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a upper triangular basis matrix <span class="tt">basis</span> and computes the m-dual basis <span class="tt">basisDual</span>. </p>
<p>This function is the equivalent of mDualLowerTriangular for upper-triangular matrices. </p>

</div>
</div>
<a id="a5b18b71fde30f5a2a619c6a6fdaa94fe" name="a5b18b71fde30f5a2a619c6a6fdaa94fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5b18b71fde30f5a2a619c6a6fdaa94fe">&#9670;&#160;</a></span>mDualUpperTriangularMod0() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualUpperTriangularMod0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <span class="tt">mDualUpperTriangular</span> and then reduces all the non-diagonal <span class="tt">mod m</span> towards 0. </p>

</div>
</div>
<a id="a8dd3800cd5914504c14a8f2a24e6bc15" name="a8dd3800cd5914504c14a8f2a24e6bc15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8dd3800cd5914504c14a8f2a24e6bc15">&#9670;&#160;</a></span>mDualUpperTriangularOld96() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualUpperTriangularOld96 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function does essentially the same thing as <span class="tt">mDualUpperTriangular</span>, but the algorithm is slightly different. </p>
<p>It uses the method described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_rcou96a">[5]</a>. </p>

</div>
</div>
<a id="a55267cecc397bb7159dc1caadd4277f0" name="a55267cecc397bb7159dc1caadd4277f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55267cecc397bb7159dc1caadd4277f0">&#9670;&#160;</a></span>mDualBasis() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function assumes that <span class="tt">basis</span> contains a basis of the primal lattice scaled by the factor <span class="tt">m</span>, not necessarily triangular, and it returns in <span class="tt">basisDual</span> the m-dual basis. </p>
<p>It uses matrix inversion and is rather slow. It is currently implemented only for <span class="tt"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> = ZZ</span> and it also assumes that the dimensions of the two <span class="tt">IntMat</span> objects is exactly the same as the dimensions of the lattices. The reason for this is that we use an <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> function that works only under these conditions. </p>

</div>
</div>
<a id="a8efa9af09c4f0908209a9039056fcb27" name="a8efa9af09c4f0908209a9039056fcb27"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8efa9af09c4f0908209a9039056fcb27">&#9670;&#160;</a></span>projectMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function overwrites the first <span class="tt">r</span> rows of matrix 'out' by a matrix formed by the first <span class="tt">r</span> rows of the c columns of matrix <span class="tt">in</span> that are specified by <span class="tt">proj</span>, where &lsquo;c = size(proj)&rsquo; is the cardinality of the projection <span class="tt">proj</span>. </p>
<p>Only the first c columns of the first <span class="tt">r</span> rows are overwritten; the other entries are left unchanged. If <span class="tt">r = 0</span>, then all the rows of matrix <span class="tt">in</span> are taken. When <span class="tt">in</span> is a basis, <span class="tt">r</span> will usually be the dimension of that basis and <span class="tt">c</span> will be smaller. The dimensions of the matrices <span class="tt">in</span> and <span class="tt">out</span> are always left unchanged. The dimensions of <span class="tt">out</span> are assumed to be large enough. After the call, the matrix <span class="tt">out</span> will then contain a set of generating vectors for the projection <span class="tt">proj</span>. The matrices <span class="tt">in</span> and <span class="tt">out</span> must be different IntMat objects, otherwise the program halts with an error message. </p>

</div>
</div>
<a id="a085b0d6b291e2104251d6bf3746c3158" name="a085b0d6b291e2104251d6bf3746c3158"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a085b0d6b291e2104251d6bf3746c3158">&#9670;&#160;</a></span>projectionConstructionLLL() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectionConstructionLLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a basis for the projection <span class="tt">proj</span> of the lattice with basis <span class="tt">inBasis</span>, using <span class="tt">LLLBasisConstruction</span>, and returns it in <span class="tt">projBasis</span>. </p>
<p>This returned basis is not triangular in general. Its dimension will be the number of coordinates in <span class="tt">proj</span>. The matrix <span class="tt">projBasis</span> must have enough columns to hold it and at least as many rows as the number of rows that we use from <span class="tt">inBasis</span>. When <span class="tt">r &gt; 0</span>, only the first <span class="tt">r</span> rows of the matrix <span class="tt">inBasis</span> are used, otherwise we use all rows of that matrix. This <span class="tt">r</span> should normally be the true dimension <span class="tt">dim</span> of that basis, which is often smaller than the size <span class="tt">maxDim</span> of the <span class="tt">IntMat</span> object that contains the basis. The square Euclidean lengths of the basis vectors are returned in the array <span class="tt">sqlen</span> when the latter is given. </p>

</div>
</div>
<a id="a23727477171c0b882c6c8a0c41c1ba2b" name="a23727477171c0b882c6c8a0c41c1ba2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23727477171c0b882c6c8a0c41c1ba2b">&#9670;&#160;</a></span>projectionConstructionUpperTri() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectionConstructionUpperTri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>genTemp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <span class="tt">projectionConstructionLLL</span>, but the construction is made using <span class="tt">upperTriangularBasis</span>, so the returned basis is upper triangular. </p>
<p>When <span class="tt">r &gt; 0</span>, only the first <span class="tt">r</span> rows of the matrix <span class="tt">inBasis</span> are actually used, otherwise we use all rows of that matrix. In the first version, we pass a matrix <span class="tt">genTemp</span> that will be used to store the generating vectors of the projection before making the triangularization. The two matrices <span class="tt">projBasis</span> and <span class="tt">genTemp</span> must have enough columns to hold the projection and at least as many rows as the number of rows that we use from <span class="tt">inBasis</span>. We pass <span class="tt">genTemp</span> as a parameter to avoid the internal creation of a new matrix each time, in case we call this function several times. Its contents will be modified. In the second version, this matrix is not passed and a temporary one is created internally, which may add a bit of overhead. </p>

</div>
</div>
<a id="ac2aae5201a480e23fa21343f289b0f2a" name="ac2aae5201a480e23fa21343f289b0f2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac2aae5201a480e23fa21343f289b0f2a">&#9670;&#160;</a></span>projectionConstructionUpperTri() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectionConstructionUpperTri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a10b69f089b2845f22065ef00561511bd" name="a10b69f089b2845f22065ef00561511bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a10b69f089b2845f22065ef00561511bd">&#9670;&#160;</a></span>projectionConstruction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectionConstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a></td>          <td class="paramname"><span class="paramname"><em>projType</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46a59c23f7e8d888fc3e79108dea9475dbb">LLLPROJ</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In this version, the construction method is passed as a parameter. </p>
<p>The default is LLL. In the triangular case, a temporary matrix is created internally. </p>

</div>
</div>
<a id="aedff96000ec004065ececb54c4e25e70" name="aedff96000ec004065ececb54c4e25e70"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aedff96000ec004065ececb54c4e25e70">&#9670;&#160;</a></span>LLLConstruction0() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::LLLConstruction0 </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; long &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a744f7989fb4fe55dcd495233b747e0d6" name="a744f7989fb4fe55dcd495233b747e0d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a744f7989fb4fe55dcd495233b747e0d6">&#9670;&#160;</a></span>LLLConstruction0() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::LLLConstruction0 </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a25d09e2b931b88a311d38461458099a8" name="a25d09e2b931b88a311d38461458099a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a25d09e2b931b88a311d38461458099a8">&#9670;&#160;</a></span>LLLConstruction0() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">xdouble LatticeTester::LLLConstruction0 </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; xdouble &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a72aa68b5a626ce9431145f7a3e753620" name="a72aa68b5a626ce9431145f7a3e753620"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aa68b5a626ce9431145f7a3e753620">&#9670;&#160;</a></span>LLLConstruction0() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">quad_float LatticeTester::LLLConstruction0 </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; quad_float &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a77ea11a7ef3fcc8747d0e89212050e19" name="a77ea11a7ef3fcc8747d0e89212050e19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a77ea11a7ef3fcc8747d0e89212050e19">&#9670;&#160;</a></span>LLLConstruction0() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">RR LatticeTester::LLLConstruction0 </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; NTL::RR &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aee78965591d1b5717dee3bba5be835bf" name="aee78965591d1b5717dee3bba5be835bf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee78965591d1b5717dee3bba5be835bf">&#9670;&#160;</a></span>LLLBasisConstruction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Real LatticeTester::LLLBasisConstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <span class="tt">LLLConstruction0</span>, except that this function adds explicitly all the vectors \(m \mathbf{e}_i\) to the generating set, so there will be <span class="tt">r + c</span> rows initially and the function always returns a square matrix. </p>
<p>The matrix <span class="tt">gen</span> is not resized by this function, so it can remain larger than the lattice dimension. </p>

</div>
</div>
<a id="adf38db6c503b603580edb998ab3dfb3a" name="adf38db6c503b603580edb998ab3dfb3a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf38db6c503b603580edb998ab3dfb3a">&#9670;&#160;</a></span>lowerTriangularBasis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::lowerTriangularBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a set of generating vectors in the matrix <span class="tt">gen</span> and iteratively transforms it into a lower triangular lattice basis into the matrix <span class="tt">basis</span>. </p>
<p>This lattice is assumed to contain all the vectors of the form \(m \mathbf{e}_j\), so these vectors are added implicitly to the generating set. Apart from that, all the entries of <span class="tt">gen</span> given as input are assumed to be reduced modulo the scaling factor <span class="tt">m</span> and all the computations are done modulo <span class="tt">m</span>. The matrix <span class="tt">basis</span> is assumed to be large enough to contain the new basis, whose dimension should be the number of columns taken from <span class="tt">gen</span>. After the execution, <span class="tt">gen</span> will contain irrelevant information (garbage) and <span class="tt">basis</span> will contain an upper triangular basis. The algorithm is explained in the lattice tester guide. Important: <span class="tt">gen</span> and <span class="tt">basis</span> must be different <span class="tt">IntMat</span> objects.</p>
<p>When <span class="tt">r</span> and/or <span class="tt">c</span> are strictly positive, they specify the numbers of rows and columns of <span class="tt">gen</span> that are actually used, as in <span class="tt">LLLConstruction0</span>. The matrix <span class="tt">gen</span> is never resized. The new basis should be c x c. </p>

</div>
</div>
<a id="ac0699288204d864638ec9cc3461192bc" name="ac0699288204d864638ec9cc3461192bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac0699288204d864638ec9cc3461192bc">&#9670;&#160;</a></span>upperTriangularBasis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::upperTriangularBasis </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <span class="tt">lowerTriangularBasis</span>, except that the returned basis is upper triangular. </p>

</div>
</div>
<a id="a3d4b386e05b14e28a1a77e18af32acce" name="a3d4b386e05b14e28a1a77e18af32acce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d4b386e05b14e28a1a77e18af32acce">&#9670;&#160;</a></span>upperTriangularBasisOld96() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr, typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::upperTriangularBasisOld96 </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>W</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>lin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7599453daee81235947f198aa0fdabd2" name="a7599453daee81235947f198aa0fdabd2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7599453daee81235947f198aa0fdabd2">&#9670;&#160;</a></span>mDualLowerTriangular() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualLowerTriangular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a lower-triangular basis matrix <span class="tt">basis</span> and computes the m-dual basis <span class="tt">basisDual</span>. </p>
<p>The function assumes that each coefficient on the diagonal of <span class="tt">basis</span> is nonzero and divides <span class="tt">m</span>. That is, the basis matrix must be square and m-invertible. Since the basis is lower triangular, its m-dual will be upper triangular. When <span class="tt">dim &gt; 0</span>, it must give the number of rows and columns of the matrix <span class="tt">basis</span> that is actually used. Otherwise (by default) the function uses <span class="tt">basis.numCols()</span>. </p>

</div>
</div>
<a id="a879bb70764843a663c4a22e993cd1d8b" name="a879bb70764843a663c4a22e993cd1d8b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a879bb70764843a663c4a22e993cd1d8b">&#9670;&#160;</a></span>mDualUpperTriangular() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualUpperTriangular </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a upper triangular basis matrix <span class="tt">basis</span> and computes the m-dual basis <span class="tt">basisDual</span>. </p>
<p>This function is the equivalent of mDualLowerTriangular for upper-triangular matrices. </p>

</div>
</div>
<a id="a330c8d1822bd62d27f7708e04e409a96" name="a330c8d1822bd62d27f7708e04e409a96"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a330c8d1822bd62d27f7708e04e409a96">&#9670;&#160;</a></span>mDualLowerTriangularMod0() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualLowerTriangularMod0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <span class="tt">mDualLowerTriangular</span> and then reduces all the non-diagonal <span class="tt">mod m</span> towards 0. </p>

</div>
</div>
<a id="a541c52e31adea978279ddd93a5cbdc18" name="a541c52e31adea978279ddd93a5cbdc18"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a541c52e31adea978279ddd93a5cbdc18">&#9670;&#160;</a></span>mDualUpperTriangularMod0() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualUpperTriangularMod0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <span class="tt">mDualUpperTriangular</span> and then reduces all the non-diagonal <span class="tt">mod m</span> towards 0. </p>

</div>
</div>
<a id="a938bceedde41f1318302ed9037dc0f83" name="a938bceedde41f1318302ed9037dc0f83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a938bceedde41f1318302ed9037dc0f83">&#9670;&#160;</a></span>mDualUpperTriangularOld96() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualUpperTriangularOld96 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function does essentially the same thing as <span class="tt">mDualUpperTriangular</span>, but the algorithm is slightly different. </p>
<p>It uses the method described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_rcou96a">[5]</a>. </p>

</div>
</div>
<a id="a2cdb586351ffc042ae953045a73f01fb" name="a2cdb586351ffc042ae953045a73f01fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cdb586351ffc042ae953045a73f01fb">&#9670;&#160;</a></span>mDualUpperTriangularOld96() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualUpperTriangularOld96 </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a8b517f6075fece22fd4336115e2fd524" name="a8b517f6075fece22fd4336115e2fd524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b517f6075fece22fd4336115e2fd524">&#9670;&#160;</a></span>mDualBasis() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualBasis </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Mat&lt; <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a452ed7260c613b06e3ccd84682b989a2" name="a452ed7260c613b06e3ccd84682b989a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a452ed7260c613b06e3ccd84682b989a2">&#9670;&#160;</a></span>mDualBasis() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualBasis </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac6373857de656ccfeb0972950b2986d" name="aac6373857de656ccfeb0972950b2986d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac6373857de656ccfeb0972950b2986d">&#9670;&#160;</a></span>projectMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function overwrites the first <span class="tt">r</span> rows of matrix 'out' by a matrix formed by the first <span class="tt">r</span> rows of the c columns of matrix <span class="tt">in</span> that are specified by <span class="tt">proj</span>, where &lsquo;c = size(proj)&rsquo; is the cardinality of the projection <span class="tt">proj</span>. </p>
<p>Only the first c columns of the first <span class="tt">r</span> rows are overwritten; the other entries are left unchanged. If <span class="tt">r = 0</span>, then all the rows of matrix <span class="tt">in</span> are taken. When <span class="tt">in</span> is a basis, <span class="tt">r</span> will usually be the dimension of that basis and <span class="tt">c</span> will be smaller. The dimensions of the matrices <span class="tt">in</span> and <span class="tt">out</span> are always left unchanged. The dimensions of <span class="tt">out</span> are assumed to be large enough. After the call, the matrix <span class="tt">out</span> will then contain a set of generating vectors for the projection <span class="tt">proj</span>. The matrices <span class="tt">in</span> and <span class="tt">out</span> must be different IntMat objects, otherwise the program halts with an error message. </p>

</div>
</div>
<a id="a33e21410fcd60b6dc1a9bf1ac58ad029" name="a33e21410fcd60b6dc1a9bf1ac58ad029"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e21410fcd60b6dc1a9bf1ac58ad029">&#9670;&#160;</a></span>projectionConstructionLLL() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectionConstructionLLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a basis for the projection <span class="tt">proj</span> of the lattice with basis <span class="tt">inBasis</span>, using <span class="tt">LLLBasisConstruction</span>, and returns it in <span class="tt">projBasis</span>. </p>
<p>This returned basis is not triangular in general. Its dimension will be the number of coordinates in <span class="tt">proj</span>. The matrix <span class="tt">projBasis</span> must have enough columns to hold it and at least as many rows as the number of rows that we use from <span class="tt">inBasis</span>. When <span class="tt">r &gt; 0</span>, only the first <span class="tt">r</span> rows of the matrix <span class="tt">inBasis</span> are used, otherwise we use all rows of that matrix. This <span class="tt">r</span> should normally be the true dimension <span class="tt">dim</span> of that basis, which is often smaller than the size <span class="tt">maxDim</span> of the <span class="tt">IntMat</span> object that contains the basis. The square Euclidean lengths of the basis vectors are returned in the array <span class="tt">sqlen</span> when the latter is given. </p>

</div>
</div>
<a id="afab54fa69b7e88d66cbcc2f7568674ac" name="afab54fa69b7e88d66cbcc2f7568674ac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afab54fa69b7e88d66cbcc2f7568674ac">&#9670;&#160;</a></span>projectionConstructionUpperTri() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectionConstructionUpperTri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>genTemp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <span class="tt">projectionConstructionLLL</span>, but the construction is made using <span class="tt">upperTriangularBasis</span>, so the returned basis is upper triangular. </p>
<p>When <span class="tt">r &gt; 0</span>, only the first <span class="tt">r</span> rows of the matrix <span class="tt">inBasis</span> are actually used, otherwise we use all rows of that matrix. In the first version, we pass a matrix <span class="tt">genTemp</span> that will be used to store the generating vectors of the projection before making the triangularization. The two matrices <span class="tt">projBasis</span> and <span class="tt">genTemp</span> must have enough columns to hold the projection and at least as many rows as the number of rows that we use from <span class="tt">inBasis</span>. We pass <span class="tt">genTemp</span> as a parameter to avoid the internal creation of a new matrix each time, in case we call this function several times. Its contents will be modified. In the second version, this matrix is not passed and a temporary one is created internally, which may add a bit of overhead. </p>

</div>
</div>
<a id="ad55ee07787a3411bde9ae8ae7dd18801" name="ad55ee07787a3411bde9ae8ae7dd18801"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad55ee07787a3411bde9ae8ae7dd18801">&#9670;&#160;</a></span>projectionConstructionUpperTri() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectionConstructionUpperTri </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aacaaa449af42b672227ce6606347a066" name="aacaaa449af42b672227ce6606347a066"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aacaaa449af42b672227ce6606347a066">&#9670;&#160;</a></span>projectionConstruction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectionConstruction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a></td>          <td class="paramname"><span class="paramname"><em>projType</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46a59c23f7e8d888fc3e79108dea9475dbb">LLLPROJ</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In this version, the construction method is passed as a parameter. </p>
<p>The default is LLL. In the triangular case, a temporary matrix is created internally. </p>

</div>
</div>
<a id="af65fc07f34906524398b038327a0bb14" name="af65fc07f34906524398b038327a0bb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65fc07f34906524398b038327a0bb14">&#9670;&#160;</a></span>toStringNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toStringNorm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a></td>          <td class="paramname"><span class="paramname"><em>norm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following are functions for printing the <span class="tt">enum</span> constants in this module. </p>
<p>Each function returns the value of the <span class="tt">enum</span> variable given as input as a string. </p>

</div>
</div>
<a id="ac24879d5aa087958f258e3a9e3770d37" name="ac24879d5aa087958f258e3a9e3770d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24879d5aa087958f258e3a9e3770d37">&#9670;&#160;</a></span>toStringNorma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toStringNorma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a></td>          <td class="paramname"><span class="paramname"><em>norma</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a137cd194ce614d43c80f65557ee96109" name="a137cd194ce614d43c80f65557ee96109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137cd194ce614d43c80f65557ee96109">&#9670;&#160;</a></span>toStringReduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toStringReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cb">ReductionType</a></td>          <td class="paramname"><span class="paramname"><em>reduct</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21f1a550ff7e4344554a043faceb7c55" name="a21f1a550ff7e4344554a043faceb7c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f1a550ff7e4344554a043faceb7c55">&#9670;&#160;</a></span>toStringDecomp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toStringDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">DecompTypeBB</a></td>          <td class="paramname"><span class="paramname"><em>decomp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12e050957b719073c06de41c7486f1ce" name="a12e050957b719073c06de41c7486f1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e050957b719073c06de41c7486f1ce">&#9670;&#160;</a></span>toStringProjConstruct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toStringProjConstruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a></td>          <td class="paramname"><span class="paramname"><em>proj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a2fb1307d0863e4d38a3b813b180014" name="a1a2fb1307d0863e4d38a3b813b180014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2fb1307d0863e4d38a3b813b180014">&#9670;&#160;</a></span>toStringMeritType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toStringMeritType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a5e9e347d07097a1a3c82f1699ff93d58">MeritType</a></td>          <td class="paramname"><span class="paramname"><em>merit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a71110e4d0e1c979d7f5da2593e8edddb" name="a71110e4d0e1c979d7f5da2593e8edddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71110e4d0e1c979d7f5da2593e8edddb">&#9670;&#160;</a></span>lFactorial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::lFactorial </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \(t!\), the factorial of \(t\). </p>
<p>Might throw an error if <span class="tt">t</span> is too large or if std::int64_t cannot contain the factorial asked for. </p>

</div>
</div>
<a id="a886c94b54767104cea58e0f1b6c0d11e" name="a886c94b54767104cea58e0f1b6c0d11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886c94b54767104cea58e0f1b6c0d11e">&#9670;&#160;</a></span>Digamma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Digamma </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the logarithmic derivative of the Gamma function \(\psi(x) = \Gamma&#39;(x) / \Gamma(x)\). </p>

</div>
</div>
<a id="a67515c2643b5f7029486e8118ede05d6" name="a67515c2643b5f7029486e8118ede05d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67515c2643b5f7029486e8118ede05d6">&#9670;&#160;</a></span>BernoulliPoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::BernoulliPoly </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\). </p>
<p>The first Bernoulli polynomials are:           </p><p class="formulaDsp">
\begin{align*}B_0(x) &amp;= 1  \\
B_1(x) &amp;= x - 1/2  \\
B_2(x) &amp;= x^2-x+1/6  \\
B_3(x) &amp;= x^3 - 3x^2/2 + x/2  \\
B_4(x) &amp;= x^4-2x^3+x^2-1/30 \\
B_5(x) &amp;= x^5 - 5x^4/2 + 5x^3/3 - x/6  \\
B_6(x) &amp;= x^6-3x^5+5x^4/2-x^2/2+1/42  \\
B_7(x) &amp;= x^7 - 7x^6/2 +  7x^5/2 - 7x^3/6 + x/6  \\
B_8(x) &amp;= x^8-4x^7+14x^6/3 - 7x^4/3 +2x^2/3-1/30.
\end{align*}
</p>
<p> Only degrees \(n \le 8\) are programmed for now. </p>

</div>
</div>
<a id="a61a4b5013c295f9f07b9b2d8f26ee5f4" name="a61a4b5013c295f9f07b9b2d8f26ee5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a4b5013c295f9f07b9b2d8f26ee5f4">&#9670;&#160;</a></span>Harmonic()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Harmonic </td>
          <td>(</td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the \(n\)-th harmonic number \(H_n  = \sum_{j=1}^n 1/j\). </p>

</div>
</div>
<a id="a3aefa49a034495dcc46721c275f329b0" name="a3aefa49a034495dcc46721c275f329b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aefa49a034495dcc46721c275f329b0">&#9670;&#160;</a></span>Harmonic2()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Harmonic2 </td>
          <td>(</td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum. </p>
<p class="formulaDsp">
\[\sideset{}{&#39;}\sum_{-n/2&lt;j\le n/2}\; \frac 1{|j|},
\]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(j=0\) is excluded from the sum. </p>

</div>
</div>
<a id="a0bb56e7569fb24800973df89d757f2fd" name="a0bb56e7569fb24800973df89d757f2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb56e7569fb24800973df89d757f2fd">&#9670;&#160;</a></span>FourierC1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierC1 </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the value of the series (see <a class="el" href="../../d0/de3/citelist.html#CITEREF_vjoe92b">[8]</a>) </p>
<p class="formulaDsp">
\[S(x, n) = \sum_{j=1}^{n} \frac{\cos(2\pi j x)}{j}.
\]
</p>
<p> Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). </p>

</div>
</div>
<a id="ab5f708fa0e8d6aa53427b3e8927f5504" name="ab5f708fa0e8d6aa53427b3e8927f5504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f708fa0e8d6aa53427b3e8927f5504">&#9670;&#160;</a></span>FourierE1()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierE1 </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the value of the series. </p>
<p class="formulaDsp">
\[G(x, n) = \sideset{}{&#39;}\sum_{-n/2&lt;h\le n/2}\;  \frac{e^{2\pi i h x}}{|h|},
\]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(h=0\) is excluded from the sum, and assuming that the imaginary part of \(G(x, n)\) vanishes. Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). </p>

</div>
</div>
<a id="a3ceea9a41a24df6ed2031758a1d6ec20" name="a3ceea9a41a24df6ed2031758a1d6ec20"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ceea9a41a24df6ed2031758a1d6ec20">&#9670;&#160;</a></span>redLLL() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real LatticeTester::redLLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.99999</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function uses the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> implementation of the LLL reduction algorithm with factor <span class="tt">delta</span>, presented in <a class="el" href="../../d0/de3/citelist.html#CITEREF_msch91a">[14]</a> (see also <a class="el" href="../../d0/de3/citelist.html#CITEREF_ilec22l">[11]</a>). </p>
<p>The reduction is applied to the first <span class="tt">dim</span> basis vectors and coordinates when <span class="tt">dim &gt; 0</span>, and to the entire basis (all vectors) when <span class="tt">dim=0</span>. In the former case, the transformations are not applied to all the columns, so we will no longer have a consistent basis for the original lattice if it had more than <span class="tt">dim</span> dimensions. To recover a basis for the full lattice in this case, we may save it before calling this function, or rebuild it.</p>
<p>This function always uses the Euclidean norm. The factor <span class="tt">delta</span> must be in [1/2, 1). The closer it is to 1, the more the basis is reduced, in the sense that the LLL algorithm will enforce tighter conditions on the basis. The returned basis always has its shortest vector in first place. The vector pointed by <span class="tt">sqlen</span> (if given) will contain the square lengths of the basis vectors. To recover these values in a <span class="tt">Vec&lt;double&gt; v</span> one can pass <span class="tt">&amp;v</span> to the function. The parameter <span class="tt">precision</span> specifies the precision of the floating point numbers that the algorithm will use. <span class="tt"><a class="el" href="../../dd/d8f/EnumTypes_8h.html" title="Enumeration types and global constants used in LatticeTester.">EnumTypes.h</a></span> provides a list of the possible values, and their description is done in the module <span class="tt">LLL</span> of <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a>. </p>

</div>
</div>
<a id="a786516595510c5c25068e8799f0033a4" name="a786516595510c5c25068e8799f0033a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a786516595510c5c25068e8799f0033a4">&#9670;&#160;</a></span>redLLLExact() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redLLLExact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.99999</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This static function implements an exact algorithm from <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> to perform the original LLL reduction. </p>
<p>This is slower than <span class="tt">redLLLNTL</span>, but more accurate. It does not take the <span class="tt">dim</span> and <span class="tt">sqlen</span> parameters (for now). </p>

</div>
</div>
<a id="a4a61a2dbcaf8040bb3ae3ffe23a098c8" name="a4a61a2dbcaf8040bb3ae3ffe23a098c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a61a2dbcaf8040bb3ae3ffe23a098c8">&#9670;&#160;</a></span>redBKZ() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real LatticeTester::redBKZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.99999</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>blocksize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>prune</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel static">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This calls the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> implementation of the floating point version of the BKZ reduction algorithm presented in <a class="el" href="../../d0/de3/citelist.html#CITEREF_msch91a">[14]</a>, with reduction factor <span class="tt">delta</span>, block size <span class="tt">blocksize</span>, pruning parameter &lsquo;prune&rsquo;; see <a class="el" href="../../d0/de3/citelist.html#CITEREF_ilec22l">[11]</a>. </p>
<p>The other paraameters have the same meaning as in <span class="tt">redLLLNTL</span>. The parameter <span class="tt">blocksize</span> gives the size of the blocks in the BKZ reduction. Roughly, larger blocks means a stronger condition. A <span class="tt">blocksize</span> of 2 is equivalent to LLL reduction. </p>

</div>
</div>
<a id="af8952c275a4f3ad1437fdbddf99ea679" name="af8952c275a4f3ad1437fdbddf99ea679"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af8952c275a4f3ad1437fdbddf99ea679">&#9670;&#160;</a></span>redLLL() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Real LatticeTester::redLLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.99999</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function uses the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a> implementation of the LLL reduction algorithm with factor <span class="tt">delta</span>, presented in <a class="el" href="../../d0/de3/citelist.html#CITEREF_msch91a">[14]</a> (see also <a class="el" href="../../d0/de3/citelist.html#CITEREF_ilec22l">[11]</a>). </p>
<p>The reduction is applied to the first <span class="tt">dim</span> basis vectors and coordinates when <span class="tt">dim &gt; 0</span>, and to the entire basis (all vectors) when <span class="tt">dim=0</span>. In the former case, the transformations are not applied to all the columns, so we will no longer have a consistent basis for the original lattice if it had more than <span class="tt">dim</span> dimensions. To recover a basis for the full lattice in this case, we may save it before calling this function, or rebuild it.</p>
<p>This function always uses the Euclidean norm. The factor <span class="tt">delta</span> must be in [1/2, 1). The closer it is to 1, the more the basis is reduced, in the sense that the LLL algorithm will enforce tighter conditions on the basis. The returned basis always has its shortest vector in first place. The vector pointed by <span class="tt">sqlen</span> (if given) will contain the square lengths of the basis vectors. To recover these values in a <span class="tt">Vec&lt;double&gt; v</span> one can pass <span class="tt">&amp;v</span> to the function. The parameter <span class="tt">precision</span> specifies the precision of the floating point numbers that the algorithm will use. <span class="tt"><a class="el" href="../../dd/d8f/EnumTypes_8h.html" title="Enumeration types and global constants used in LatticeTester.">EnumTypes.h</a></span> provides a list of the possible values, and their description is done in the module <span class="tt">LLL</span> of <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a>. </p>

</div>
</div>
<a id="a45e9fb356874a9d69a083c447d35ee82" name="a45e9fb356874a9d69a083c447d35ee82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a45e9fb356874a9d69a083c447d35ee82">&#9670;&#160;</a></span>redLLL() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::redLLL </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abf582f8ec90dc5bbc0c52a8afab88903" name="abf582f8ec90dc5bbc0c52a8afab88903"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf582f8ec90dc5bbc0c52a8afab88903">&#9670;&#160;</a></span>redLLL() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::redLLL </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e85e9cda4a548bb9066dc93c01ffbc3" name="a3e85e9cda4a548bb9066dc93c01ffbc3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e85e9cda4a548bb9066dc93c01ffbc3">&#9670;&#160;</a></span>redLLL() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">xdouble LatticeTester::redLLL </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; xdouble &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6eb909d481b710dd72c07eb65f0f65af" name="a6eb909d481b710dd72c07eb65f0f65af"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6eb909d481b710dd72c07eb65f0f65af">&#9670;&#160;</a></span>redLLL() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">quad_float LatticeTester::redLLL </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; quad_float &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c2d52c1e432a0aa02eb8d11c2b9efc5" name="a7c2d52c1e432a0aa02eb8d11c2b9efc5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c2d52c1e432a0aa02eb8d11c2b9efc5">&#9670;&#160;</a></span>redLLL() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NTL::RR LatticeTester::redLLL </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; NTL::RR &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5830bb0fae462b5e85c8eeb1c126a647" name="a5830bb0fae462b5e85c8eeb1c126a647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5830bb0fae462b5e85c8eeb1c126a647">&#9670;&#160;</a></span>redLLLExact() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redLLLExact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aebd6a9c79f1e8d406981e707235b99e6" name="aebd6a9c79f1e8d406981e707235b99e6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd6a9c79f1e8d406981e707235b99e6">&#9670;&#160;</a></span>redLLLExact() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redLLLExact </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd4fd2f2c2477fc8ad2d483292d14baa" name="acd4fd2f2c2477fc8ad2d483292d14baa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd4fd2f2c2477fc8ad2d483292d14baa">&#9670;&#160;</a></span>redBKZ() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">Real LatticeTester::redBKZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>blocksize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>prune</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac31ec1900f910a5d820901146696b5cb">RealVec</a> *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1d0913d24a5656d830a61018ce316716" name="a1d0913d24a5656d830a61018ce316716"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d0913d24a5656d830a61018ce316716">&#9670;&#160;</a></span>redBKZ() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::redBKZ </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>blocksize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>prune</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afa2d41ca2eff4fee580d48322b5fe8c0" name="afa2d41ca2eff4fee580d48322b5fe8c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa2d41ca2eff4fee580d48322b5fe8c0">&#9670;&#160;</a></span>redBKZ() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::redBKZ </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>blocksize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>prune</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2e11b9b3efca3e0ac3521dc42edb4f48" name="a2e11b9b3efca3e0ac3521dc42edb4f48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2e11b9b3efca3e0ac3521dc42edb4f48">&#9670;&#160;</a></span>redBKZ() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">xdouble LatticeTester::redBKZ </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>blocksize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>prune</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; xdouble &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1f7c7c09bc3168a65b0a0750b9952f08" name="a1f7c7c09bc3168a65b0a0750b9952f08"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f7c7c09bc3168a65b0a0750b9952f08">&#9670;&#160;</a></span>redBKZ() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">quad_float LatticeTester::redBKZ </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>blocksize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>prune</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; quad_float &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ae73d9d4b0e49f3431f21fc4bc0604a61" name="ae73d9d4b0e49f3431f21fc4bc0604a61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae73d9d4b0e49f3431f21fc4bc0604a61">&#9670;&#160;</a></span>redBKZ() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">NTL::RR LatticeTester::redBKZ </td>
          <td>(</td>
          <td class="paramtype">NTL::Mat&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>blocksize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>prune</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">NTL::Vec&lt; NTL::RR &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4d16fed8fda92252dc423db28136932" name="ad4d16fed8fda92252dc423db28136932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d16fed8fda92252dc423db28136932">&#9670;&#160;</a></span>swap9()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::swap9 </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes references to two variables of a generic type and swaps their content. </p>
<p>This uses the assignment operator, so it might not always work well if this operator's implementation is not thorough. </p>

</div>
</div>
<a id="abba336d3a5abb22b8367ddfa37a713e4" name="abba336d3a5abb22b8367ddfa37a713e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba336d3a5abb22b8367ddfa37a713e4">&#9670;&#160;</a></span>RandU01()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::RandU01 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random number in \([0, 1)\). </p>
<p>The number will have 53 pseudo-random bits. </p>

</div>
</div>
<a id="a3f7dd0225a074e885d6d54916757fcec" name="a3f7dd0225a074e885d6d54916757fcec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7dd0225a074e885d6d54916757fcec">&#9670;&#160;</a></span>RandInt()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t LatticeTester::RandInt </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a uniform pseudo-random integer in \([i, j]\). </p>
<p>Note that the numbers \(i\) and \(j\) are part of the possible output. It is important that \(i &lt; j\) because the underlying arithmetic uses unsigned integers to store j-i+1 and that will be undefined behavior. </p>

</div>
</div>
<a id="a3fdad6592203c9b83f2ef7caf7b8441f" name="a3fdad6592203c9b83f2ef7caf7b8441f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdad6592203c9b83f2ef7caf7b8441f">&#9670;&#160;</a></span>RandBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t LatticeTester::RandBits </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first s pseudo-random bits of the underlying RNG in the form of a s-bit integer. </p>
<p>It is imperative that \(1 \leq s \leq 64\) because the RNG is 64 bits wide. </p>

</div>
</div>
<a id="a1a68bc6b1e81a03d09ea07fa9efed658" name="a1a68bc6b1e81a03d09ea07fa9efed658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a68bc6b1e81a03d09ea07fa9efed658">&#9670;&#160;</a></span>SetSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetSeed </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the seed of the generator. </p>
<p>Because of the constraints on the state, <span class="tt">seed</span> has to be \( &gt; 2\). If this is never called, a default seed will be used. </p>

</div>
</div>
<a id="a9abb8da9fdc5fa2c37d44165f8660aaf" name="a9abb8da9fdc5fa2c37d44165f8660aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abb8da9fdc5fa2c37d44165f8660aaf">&#9670;&#160;</a></span>mysqrt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::mysqrt </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns \(\sqrt{x}\) for \(x\ge0\), and \(-1\) for \(x &lt; 0\). </p>

</div>
</div>
<a id="ae12db9335c229d7c60e570dab50ef05b" name="ae12db9335c229d7c60e570dab50ef05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12db9335c229d7c60e570dab50ef05b">&#9670;&#160;</a></span>Lg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Lg </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logarithm of \(x\) in base 2. </p>

</div>
</div>
<a id="a12e4b6c931cf0a19642828796b3b3bef" name="a12e4b6c931cf0a19642828796b3b3bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e4b6c931cf0a19642828796b3b3bef">&#9670;&#160;</a></span>Lg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Lg </td>
          <td>(</td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logarithm of \(x\) in base 2. </p>

</div>
</div>
<a id="a67e0668a966fb5fa3e22fc1ffa6d59ed" name="a67e0668a966fb5fa3e22fc1ffa6d59ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e0668a966fb5fa3e22fc1ffa6d59ed">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scal LatticeTester::abs </td>
          <td>(</td>
          <td class="paramtype">Scal</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the absolute value of \(x\). </p>

</div>
</div>
<a id="a59016f13e4470ad17683b1cfeb70153c" name="a59016f13e4470ad17683b1cfeb70153c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59016f13e4470ad17683b1cfeb70153c">&#9670;&#160;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::sign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sign of <span class="tt">x</span>. </p>
<p>The sign is 1 if <span class="tt">x&gt;0</span>, 0 if <span class="tt">x==0</span> and -1 if <span class="tt">x&lt;0</span>. </p>

</div>
</div>
<a id="a15f15a1453b578cb49b2e3deda5a200d" name="a15f15a1453b578cb49b2e3deda5a200d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f15a1453b578cb49b2e3deda5a200d">&#9670;&#160;</a></span>Round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real LatticeTester::Round </td>
          <td>(</td>
          <td class="paramtype">Real</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of x rounded to the NEAREST integer value. </p>
<p>(This does not truncate the integer value as is usual in computer arithmetic.) </p>

</div>
</div>
<a id="a941ee9c334c67adb02d4d7098fa22553" name="a941ee9c334c67adb02d4d7098fa22553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941ee9c334c67adb02d4d7098fa22553">&#9670;&#160;</a></span>Factorial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::Factorial </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \(t!\), the factorial of \(t\) and returns it as an std::int64_t. </p>

</div>
</div>
<a id="aa9056e4da6e74d83c6061650caf9e59f" name="aa9056e4da6e74d83c6061650caf9e59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9056e4da6e74d83c6061650caf9e59f">&#9670;&#160;</a></span>Quotient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Quotient </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <span class="tt">a/b</span>, truncates the fractional part and puts the result in q. </p>
<p>This function is overloaded to work as specified on NTL::ZZ integers. Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\)</td><td class="r bl br">\(b\)</td><td class="r bl br">\(q\)</td></tr>
<tr class="bt">
<td class="r bl br">\(5\)</td><td class="r bl br">3</td><td class="r bl br">1</td></tr>
<tr>
<td class="r bl br">\(-5\)</td><td class="r bl br">\(3\)</td><td class="r bl br">\(-1\)</td></tr>
<tr>
<td class="r bl br">\(5\)</td><td class="r bl br">\(-3\)</td><td class="r bl br">\(-1\)</td></tr>
<tr>
<td class="r bl br">\(-5\)</td><td class="r bl br">\(-3\)</td><td class="r bl br">\(1\)</td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="a33b2ac0aaf5689dbf1f2225dbf14b327" name="a33b2ac0aaf5689dbf1f2225dbf14b327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b2ac0aaf5689dbf1f2225dbf14b327">&#9670;&#160;</a></span>Modulo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Modulo </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the remainder of a/b and stores its positive equivalent mod b in r. </p>
<p>This works with std::int64_t, NTL::ZZ and real numbers. </p>

</div>
</div>
<a id="ace733f06613d555cb7c6fb617e8a33b7" name="ace733f06613d555cb7c6fb617e8a33b7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace733f06613d555cb7c6fb617e8a33b7">&#9670;&#160;</a></span>ModuloTowardZero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ModuloTowardZero </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the element <span class="tt">r = a mod b</span> that is closest to 0. </p>
<p>Assumes <span class="tt">b &gt; 0</span>. For example, <span class="tt">8 mod 11 = -3</span>, <span class="tt">-2 mod 11 = -2</span>, <span class="tt">-10 mod 11 = 1</span>. </p>

</div>
</div>
<a id="a3d24a696d90d81de9128f9af7c6694d5" name="a3d24a696d90d81de9128f9af7c6694d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d24a696d90d81de9128f9af7c6694d5">&#9670;&#160;</a></span>ModuloTowardZero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ModuloTowardZero </td>
          <td>(</td>
          <td class="paramtype">const std::int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aeccbd231b4002cadbaac0157871f5570" name="aeccbd231b4002cadbaac0157871f5570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccbd231b4002cadbaac0157871f5570">&#9670;&#160;</a></span>Divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Divide </td>
          <td>(</td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotient \(q = a/b\) and remainder  \(r = a
\bmod b\). </p>
<p>Truncates \(q\) to the nearest integer toward 0. One always has \(a = qb + r\) and \(|r| &lt; |b|\). This works with std::int64_t, NTL::ZZ and real numbers.</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\)</td><td class="r bl br">\(b\)</td><td class="r bl br">\(q\)</td><td class="r bl br">\(r\)</td></tr>
<tr class="bt">
<td class="r bl br">\(5\)</td><td class="r bl br">3</td><td class="r bl br">1</td><td class="r bl br">\(2\)</td></tr>
<tr>
<td class="r bl br">\(-5\)</td><td class="r bl br">\(3\)</td><td class="r bl br">\(-1\)</td><td class="r bl br">\(-2\)</td></tr>
<tr>
<td class="r bl br">\(5\)</td><td class="r bl br">\(-3\)</td><td class="r bl br">\(-1\)</td><td class="r bl br">\(2\)</td></tr>
<tr>
<td class="r bl br">\(-5\)</td><td class="r bl br">\(-3\)</td><td class="r bl br">\(1\)</td><td class="r bl br">\(-2\)</td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="a76b74332cd4ded85d51dc6020b930772" name="a76b74332cd4ded85d51dc6020b930772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b74332cd4ded85d51dc6020b930772">&#9670;&#160;</a></span>DivideRound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DivideRound </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\). </p>
<p>This works with std::int64_t, NTL::ZZ and real numbers. </p>

</div>
</div>
<a id="a14db19d396c104b730dd5ea23a7752b5" name="a14db19d396c104b730dd5ea23a7752b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14db19d396c104b730dd5ea23a7752b5">&#9670;&#160;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::gcd </td>
          <td>(</td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the greatest common divisor of \(a\) and \(b\) by using Stein's binary GCD algorithm. </p>

</div>
</div>
<a id="abfe3d98ab5a4c91cac2ef0fa59ec897d" name="abfe3d98ab5a4c91cac2ef0fa59ec897d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">&#9670;&#160;</a></span>Euclide() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Euclide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>F</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method computes the greater common divisor of <span class="tt">A</span> and <span class="tt">B</span> with Euclid's algorithm. </p>
<p>This will store this gcd in <span class="tt">G</span> and also the linear combination that permits to get <span class="tt">G</span> from <span class="tt">A</span> and <span class="tt">B</span>. This function should work with std::int64_t and NTL::ZZ.</p>
<p>For \(A\) and \(B\) this will assign to \(C\), \(D\), \(E\), \(F\) and \(G\) values such that:    </p><p class="formulaDsp">
\begin{align*}   C a + D b &amp; = G = \mbox{GCD } (a,b)\\
    E a + F b &amp; = 0.
\end{align*}
</p>
 
</div>
</div>
<a id="a734b88021d0f2b51a6c8ab5ca7c1a5aa" name="a734b88021d0f2b51a6c8ab5ca7c1a5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734b88021d0f2b51a6c8ab5ca7c1a5aa">&#9670;&#160;</a></span>Euclide() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Euclide </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa2f58453cd5cd239b67d0eb92b3dadf" name="aaa2f58453cd5cd239b67d0eb92b3dadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2f58453cd5cd239b67d0eb92b3dadf">&#9670;&#160;</a></span>TransposeMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::TransposeMatrix </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>mat2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a set of generating vectors in the matrix <span class="tt">mat</span> and iteratively transforms it into an upper triangular lattice basis into the matrix <span class="tt">mat2</span>. </p>
<p><span class="tt">mat</span> and <span class="tt">mat2</span> have to have the same number of rows and the same number of columns. All the computations will be done modulo <span class="tt">mod</span>, which means that you must know the rescaling factor for the vector system to call this function. After the execution, <span class="tt">mat</span> will be a matrix containing irrelevant information and <span class="tt">mat2</span> will contain an upper triangular basis.</p>
<p>For more details please look at <b>[latTesterGide]</b>. This algorithm basically implements what is written in this guide. The matrix <span class="tt">mat</span> contains the set of vectors that is used and modified at each step to get a new vector from the basis. Lower triangularization </p>

</div>
</div>
<a id="a0416b061a693a6e604d4cc99b14a7050" name="a0416b061a693a6e604d4cc99b14a7050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0416b061a693a6e604d4cc99b14a7050">&#9670;&#160;</a></span>CreateVect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateVect </td>
          <td>(</td>
          <td class="paramtype">Real *&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory to <span class="tt">A</span> as an array of <span class="tt">Real</span> of dimension <span class="tt">d</span> and initializes its elements to 0. </p>
<p><span class="tt">Real</span> has to be a numeric type. </p>

</div>
</div>
<a id="af40f02397dea42344f2c4b6016f5e4f0" name="af40f02397dea42344f2c4b6016f5e4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40f02397dea42344f2c4b6016f5e4f0">&#9670;&#160;</a></span>CreateVect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the vector <span class="tt">A</span> of dimensions <span class="tt">d+1</span> and initializes its elements to 0. </p>
<p>The type <span class="tt">Vect</span> must have a method <span class="tt">SetLength</span>, as for <span class="tt">Vec&lt;T&gt;</span> in <a class="el" href="../../d2/d5a/namespaceNTL.html" title="These functions are in the NTL namespace.">NTL</a>. </p>

</div>
</div>
<a id="a3290d1c59f58412753021d37fd9059c3" name="a3290d1c59f58412753021d37fd9059c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3290d1c59f58412753021d37fd9059c3">&#9670;&#160;</a></span>DeleteVect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteVect </td>
          <td>(</td>
          <td class="paramtype">Real *&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the vector <span class="tt">A</span>. </p>
<p>This calls <span class="tt">delete[]</span> on <span class="tt">A</span> so trying to access <span class="tt">A</span> after using this is unsafe. </p>

</div>
</div>
<a id="a74b9ac2e545b1a8e3febffe458488898" name="a74b9ac2e545b1a8e3febffe458488898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b9ac2e545b1a8e3febffe458488898">&#9670;&#160;</a></span>DeleteVect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the vector <span class="tt">A</span>, destroying all the elements it contains. </p>
<p><span class="tt">Vect</span> type has to have a <span class="tt">kill()</span> method that deallocates all the elements in the vector. </p>

</div>
</div>
<a id="aa42f9afe1397f5fba24397a495d995ff" name="aa42f9afe1397f5fba24397a495d995ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42f9afe1397f5fba24397a495d995ff">&#9670;&#160;</a></span>SetZero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetZero </td>
          <td>(</td>
          <td class="paramtype">Real *</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the first <span class="tt">d</span> of <span class="tt">A</span> to 0. </p>

</div>
</div>
<a id="afe6937cb95337e67ec106791e9b528c3" name="afe6937cb95337e67ec106791e9b528c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6937cb95337e67ec106791e9b528c3">&#9670;&#160;</a></span>SetZero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetZero </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the first <span class="tt">d</span> components of <span class="tt">A</span> to 0. </p>

</div>
</div>
<a id="a2a728d56ee563237fe943ebd333fa3f5" name="a2a728d56ee563237fe943ebd333fa3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a728d56ee563237fe943ebd333fa3f5">&#9670;&#160;</a></span>SetValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetValue </td>
          <td>(</td>
          <td class="paramtype">Real *</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the first <span class="tt">d</span> components of <span class="tt">A</span> to 0. </p>
<p>Sets the first <span class="tt">d</span> components of <span class="tt">A</span> to the value <span class="tt">x</span>. </p>

</div>
</div>
<a id="ad18ba9347ad4166201654eb4ad5c6972" name="ad18ba9347ad4166201654eb4ad5c6972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18ba9347ad4166201654eb4ad5c6972">&#9670;&#160;</a></span>toString() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toString </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&#160;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing <span class="tt">A[c]</span> to <span class="tt">A[d-1]</span> formated as <span class="tt">[A[c]sep...sepA[d-1]]</span>. </p>
<p>In this string, components are separated by string <span class="tt">sep</span>. By default, <span class="tt">sep</span> is just a whitespace character. </p>

</div>
</div>
<a id="a9c697e5d81b902cbb4283a21104ac62b" name="a9c697e5d81b902cbb4283a21104ac62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c697e5d81b902cbb4283a21104ac62b">&#9670;&#160;</a></span>toString() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toString </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing the first <span class="tt">d</span> components of the vector <span class="tt">A</span> as a string. </p>
<p>Calls <span class="tt">toString(const Vect&amp;, int, int, const char*)</span>. </p>

</div>
</div>
<a id="abe4590191d21abcdc4b30e0468ac416d" name="abe4590191d21abcdc4b30e0468ac416d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe4590191d21abcdc4b30e0468ac416d">&#9670;&#160;</a></span>ProdScal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ProdScal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#a76f03239c9f9103a0d5c88ed1c28451a">IntVec</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#a76f03239c9f9103a0d5c88ed1c28451a">IntVec</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>D</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the scalar product of vectors <span class="tt">A</span> and <span class="tt">B</span> truncated to their <span class="tt">n</span> first components, then puts the result in <span class="tt">D</span>. </p>
<p>There is a lot to consider when passing types to this function. The best is for <span class="tt">Vect1</span> to be the same type as <span class="tt">Vect2</span> and for <span class="tt">Scal</span> to be the same as <span class="tt"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a></span>, and that those types are the ones stored in <span class="tt">Vect1</span> and <span class="tt">Vect2</span>.</p>
<p><b>WARNING</b>: This uses so many types without check about them and also assumes all those types can be converted to each other without problem. This is used in some places to compute a floating point norm of vectors with integers values. Take care when using this function. </p>

</div>
</div>
<a id="a72aa6823947400db540862e204399ccc" name="a72aa6823947400db540862e204399ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aa6823947400db540862e204399ccc">&#9670;&#160;</a></span>Invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Invert </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#a76f03239c9f9103a0d5c88ed1c28451a">IntVec</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#a76f03239c9f9103a0d5c88ed1c28451a">IntVec</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes an input vector <span class="tt">A</span> of dimension <span class="tt">n+1</span> and fill the vector <span class="tt">B</span> with the values <span class="tt">[-A[n] -A[n-1] ... -A[1][1]</span>. </p>
<p><span class="tt">B</span> is assumed to be of dimension at least <span class="tt">n+1</span>. </p>

</div>
</div>
<a id="ab7f1c63a3d050a201b80a4efc541e240" name="ab7f1c63a3d050a201b80a4efc541e240"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab7f1c63a3d050a201b80a4efc541e240">&#9670;&#160;</a></span>CalcNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>, typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CalcNorm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#a76f03239c9f9103a0d5c88ed1c28451a">IntVec</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a></td>          <td class="paramname"><span class="paramname"><em>norm</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the <span class="tt">norm</span> norm of vector <span class="tt">V</span> trunctated to its <span class="tt">n</span> first components, and puts the result in <span class="tt">S</span>. </p>
<p><span class="tt">Scal</span> has to be a floating point type. For the L2 norm, it returns the square norm instead. </p>

</div>
</div>
<a id="aa45b3957599dec1d3c32b9dec0d0644c" name="aa45b3957599dec1d3c32b9dec0d0644c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45b3957599dec1d3c32b9dec0d0644c">&#9670;&#160;</a></span>CopyPartVec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyPartVec </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>toVec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>fromVec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the first <span class="tt">c</span> components of vector <span class="tt">fromVec</span> into vector <span class="tt">toVec</span>. </p>

</div>
</div>
<a id="aba7ffaaa36d63e57ab488e8815a77bb7" name="aba7ffaaa36d63e57ab488e8815a77bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7ffaaa36d63e57ab488e8815a77bb7">&#9670;&#160;</a></span>CopyPartMat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyPartMat </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>toMat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>fromMat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the first <span class="tt">r</span> rows and <span class="tt">c</span> columns of matrix <span class="tt">fromMat</span> into matrix <span class="tt">toMat</span>. </p>

</div>
</div>
<a id="a81bbadb519aa05a3a699329d0e08183e" name="a81bbadb519aa05a3a699329d0e08183e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81bbadb519aa05a3a699329d0e08183e">&#9670;&#160;</a></span>CopyVect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the first <span class="tt">n</span> components of vector <span class="tt">B</span> into vector <span class="tt">A</span>. </p>

</div>
</div>
<a id="a813a622816b9bdc2fc48e8315e16c7e9" name="a813a622816b9bdc2fc48e8315e16c7e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a813a622816b9bdc2fc48e8315e16c7e9">&#9670;&#160;</a></span>ModifVect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect, typename Scal&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ModifVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the first <span class="tt">n</span> components of vector <span class="tt">B</span> multiplied by <span class="tt">x</span> to first <span class="tt">n</span> components of vector <span class="tt">A</span>. </p>
<p>This will modify <span class="tt">A</span>. This does weird type conversions and may not work well if different types are used. </p>

</div>
</div>
<a id="a2fb4b9cba25e9e08b49137b70a3b3d95" name="a2fb4b9cba25e9e08b49137b70a3b3d95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fb4b9cba25e9e08b49137b70a3b3d95">&#9670;&#160;</a></span>ModifVectModulo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect, typename Scal, typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ModifVectModulo </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the first <span class="tt">n</span> components of vector <span class="tt">B</span> multiplied by <span class="tt">x</span> to first <span class="tt">n</span> components of vector <span class="tt">A</span>, modulo m. </p>
<p>This will modify <span class="tt">A</span>. The elements that are not multiples of <span class="tt">m</span> are reduced mod m. </p>

</div>
</div>
<a id="a80edc77542f933dcde8561a54d59c13b" name="a80edc77542f933dcde8561a54d59c13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80edc77542f933dcde8561a54d59c13b">&#9670;&#160;</a></span>ChangeSign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ChangeSign </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the sign (multiplies by -1) the first <span class="tt">n</span> components of vector <span class="tt">A</span>. </p>

</div>
</div>
<a id="a037fd4e351a079af3d672889e89666e0" name="a037fd4e351a079af3d672889e89666e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037fd4e351a079af3d672889e89666e0">&#9670;&#160;</a></span>GCD2vect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::GCD2vect </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the greatest common divisor of <span class="tt">V[k],...,V[n-1]</span>. </p>

</div>
</div>
<a id="a1f76eab56c1a9defffae5b8bf629290f" name="a1f76eab56c1a9defffae5b8bf629290f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f76eab56c1a9defffae5b8bf629290f">&#9670;&#160;</a></span>CreateMatr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory to a square matrix <span class="tt">A</span> of dimensions \(d \times d\) and initializes its elements to 0. </p>

</div>
</div>
<a id="add086c03b1352ae2ed9413068d5e3f6d" name="add086c03b1352ae2ed9413068d5e3f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add086c03b1352ae2ed9413068d5e3f6d">&#9670;&#160;</a></span>CreateMatr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory for the matrix <span class="tt">A</span> of dimensions  \(\text{line} \times
\text{col}\) and initializes its elements to 0. </p>

</div>
</div>
<a id="a03d33e22aad4f4a29a20c11bb96c7b02" name="a03d33e22aad4f4a29a20c11bb96c7b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d33e22aad4f4a29a20c11bb96c7b02">&#9670;&#160;</a></span>CreateMatr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the matrix <span class="tt">A</span> to a square matrix of dimensions <span class="tt">d*d</span> and re-initializes its elements to 0. </p>

</div>
</div>
<a id="afcf8fb861104547f84a5d73c33401fe6" name="afcf8fb861104547f84a5d73c33401fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf8fb861104547f84a5d73c33401fe6">&#9670;&#160;</a></span>CreateMatr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the matrix <span class="tt">A</span> to a matrix of dimensions \(line \times col\) and re-initializes its elements to 0. </p>

</div>
</div>
<a id="a2b3fbf56b76e1a95c0f935bb0acca3a4" name="a2b3fbf56b76e1a95c0f935bb0acca3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3fbf56b76e1a95c0f935bb0acca3a4">&#9670;&#160;</a></span>DeleteMatr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the \(d \times d\) matrix <span class="tt">A</span>. </p>
<p>This will not free all the memory allocated to <span class="tt">A</span> if <span class="tt">A</span> is of greater dimension and it can cause a memory leak. </p>

</div>
</div>
<a id="adb7b6d86bbad87845663bfb8e8e00d06" name="adb7b6d86bbad87845663bfb8e8e00d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7b6d86bbad87845663bfb8e8e00d06">&#9670;&#160;</a></span>DeleteMatr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the matrix <span class="tt">A</span> of dimension  \(\text{line} \times
\text{col}\). </p>
<p>This will not free all the memory allocated to <span class="tt">A</span> if <span class="tt">A</span> is of greater dimension and it can cause a memory leak. </p>

</div>
</div>
<a id="a0f66d14fcb15c8a2e358b9ab5e08b524" name="a0f66d14fcb15c8a2e358b9ab5e08b524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f66d14fcb15c8a2e358b9ab5e08b524">&#9670;&#160;</a></span>DeleteMatr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the <span class="tt"><a class="el" href="../../d2/d5a/namespaceNTL.html#a2deeffef7195d2c3508b7618c6aed677" title="Sets x to 0.">clear()</a></span> method on <span class="tt">A</span>. </p>
<p><span class="tt">A</span> has to have a <span class="tt"><a class="el" href="../../d2/d5a/namespaceNTL.html#a2deeffef7195d2c3508b7618c6aed677" title="Sets x to 0.">clear()</a></span> method that frees the memory allocated to it. </p>

</div>
</div>
<a id="adfb6cc508f7a12e043a9d39eab4e99c0" name="adfb6cc508f7a12e043a9d39eab4e99c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb6cc508f7a12e043a9d39eab4e99c0">&#9670;&#160;</a></span>CopyMatr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyMatr </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the \(n \times n\) submatrix of the first lines and columns of <span class="tt">B</span> into matrix <span class="tt">A</span>. </p>
<p>This function does not check for sizes, so <span class="tt">A</span> and <span class="tt">B</span> both have to be at leat \(n \times n\). </p>

</div>
</div>
<a id="a620105c7b91ca77c4259bd116d48ed61" name="a620105c7b91ca77c4259bd116d48ed61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620105c7b91ca77c4259bd116d48ed61">&#9670;&#160;</a></span>CopyMatr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyMatr </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the \(\text{line} \times col\) submatrix of the first lines and columns of <span class="tt">B</span> into matrix <span class="tt">A</span>. </p>
<p>This function does not check for sizes, so <span class="tt">A</span> and <span class="tt">B</span> both have to be at leat \(line \times col\). </p>

</div>
</div>
<a id="a6c4c9e2b77c4dc22c74401738c15c8b8" name="a6c4c9e2b77c4dc22c74401738c15c8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4c9e2b77c4dc22c74401738c15c8b8">&#9670;&#160;</a></span>toStr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatT&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toStr </td>
          <td>(</td>
          <td class="paramtype">const MatT &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string that is a representation of <span class="tt">mat</span>. </p>
<p>This string represents the \(d1 \times d2\) submatrix of the first lines and columns of <span class="tt">mat</span>. </p>

</div>
</div>
<a id="adc093dc4ab413df7a7a08495c06677d1" name="adc093dc4ab413df7a7a08495c06677d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc093dc4ab413df7a7a08495c06677d1">&#9670;&#160;</a></span>ProductDiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ProductDiagonal </td>
          <td>(</td>
          <td class="paramtype">const NTL::Mat&lt; <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>prod</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the product of the diagonal elements of the matrix <span class="tt">A</span>, which is assumed to be square <span class="tt">dim x dim</span>. </p>

</div>
</div>
<a id="a025780512339ad633b6878b3663d6869" name="a025780512339ad633b6878b3663d6869"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a025780512339ad633b6878b3663d6869">&#9670;&#160;</a></span>CheckTriangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LatticeTester::CheckTriangular </td>
          <td>(</td>
          <td class="paramtype">const NTL::Mat&lt; <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the upper \(\text{dim} \times \text{dim}\) submatrix of <span class="tt">A</span> is triangular modulo <span class="tt">m</span>. </p>
<p>This will return <span class="tt">true</span> if all the elements under the diagonal are equal to zero modulo <span class="tt">m</span> and <span class="tt">false</span> otherwise. If <span class="tt">m</span> is <span class="tt">0</span>, this function simply verifies that the matrix is triangular. </p>

</div>
</div>
<a id="abf5df314f92821aa4256133b3342f986" name="abf5df314f92821aa4256133b3342f986"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abf5df314f92821aa4256133b3342f986">&#9670;&#160;</a></span>checkInverseModm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LatticeTester::checkInverseModm </td>
          <td>(</td>
          <td class="paramtype">const NTL::Mat&lt; <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::Mat&lt; <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a></td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if A and B are m-dual to each other. </p>
<p>They must be square with the same dimensions. Returns <span class="tt">true</span> if <span class="tt">AB = mI</span>, false otherwise. </p>

</div>
</div>
<a id="a04449fdf436107c5ef230401edf3a200" name="a04449fdf436107c5ef230401edf3a200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04449fdf436107c5ef230401edf3a200">&#9670;&#160;</a></span>calcDual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr, typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::calcDual </td>
          <td>(</td>
          <td class="paramtype">const Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes an upper triangular basis <span class="tt">A</span> and computes an m-dual lattice basis to this matrix. </p>
<p>For this algorithm to work, <span class="tt">A</span> has to be upper triangular and all the coefficients on the diagonal have to divide <span class="tt">m</span>.</p>
<p>For <span class="tt">B</span> to be <span class="tt">m</span>-dual to <span class="tt">A</span>, we have to have that \(AB^t = mI\). It is quite easy to show that, knowing <span class="tt">A</span> is upper triangular, <span class="tt">B</span> will be a lower triangular matrix with <span class="tt">A(i,i)*B(i,i) = m</span> for all <span class="tt">i</span> and \( A_i \cdot B_j = 0\) for \(i\neq j\). To get the second condition, we simply have to recursively take for each line </p><p class="formulaDsp">
\[B_{i,j} = -\frac{1}{A_{j,j}}\sum_{k=j+1}^i A_{j,k} B_{i,k}.\]
</p>
 
</div>
</div>
<a id="a852fa8fe7dda3213afd5db3e65caa43c" name="a852fa8fe7dda3213afd5db3e65caa43c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852fa8fe7dda3213afd5db3e65caa43c">&#9670;&#160;</a></span>myExit()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::myExit </td>
          <td>(</td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>msg</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Simple error exit function, prints <span class="tt">msg</span> on exit. </p>

</div>
</div>
<a id="a9c5c3904af8b547eb32bba8d42b5c3b1" name="a9c5c3904af8b547eb32bba8d42b5c3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5c3904af8b547eb32bba8d42b5c3b1">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class T, class C, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; K, T, C, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for maps. </p>
<p>Formats a map as: <span class="tt">{ key1=&gt;val1, ..., keyN=&gt;valN }</span>. </p>

</div>
</div>
<a id="a00572b373d97cc0227547867bd1cde0d" name="a00572b373d97cc0227547867bd1cde0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00572b373d97cc0227547867bd1cde0d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1, class T2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a pair as: <span class="tt">(first,second)</span>. </p>

</div>
</div>
<a id="a0ddcbc9a5e063f35176f9c48d38f2650" name="a0ddcbc9a5e063f35176f9c48d38f2650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddcbc9a5e063f35176f9c48d38f2650">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a vector as: <span class="tt">[ val1, ..., valN ]</span>. </p>

</div>
</div>
<a id="a97b28ac9e1e15b5ede018202a73fe664" name="a97b28ac9e1e15b5ede018202a73fe664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b28ac9e1e15b5ede018202a73fe664">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K, class C, class A&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; K, C, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for sets. </p>
<p>Formats a set as: <span class="tt">{ val1, ..., valN }</span>. </p>

</div>
</div>
<a id="aab1b2821c4805119b5eb02b3fe0437eb" name="aab1b2821c4805119b5eb02b3fe0437eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1b2821c4805119b5eb02b3fe0437eb">&#9670;&#160;</a></span>copyMatrixToMat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr1, typename Matr2&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::copyMatrixToMat </td>
          <td>(</td>
          <td class="paramtype">Matr1 &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr2 &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a06b6fca0fb17656efed5391c452afc9b" name="a06b6fca0fb17656efed5391c452afc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b6fca0fb17656efed5391c452afc9b">&#9670;&#160;</a></span>printBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::printBase </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a></td>          <td class="paramname"><span class="paramname"><em>bas_mat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaee961bb86089ad2cb9df512b1164e2f" name="aaee961bb86089ad2cb9df512b1164e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee961bb86089ad2cb9df512b1164e2f">&#9670;&#160;</a></span>printBase2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::printBase2 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a></td>          <td class="paramname"><span class="paramname"><em>bas_mat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab8df54cbab1b05dae27118a586c3d4c4" name="ab8df54cbab1b05dae27118a586c3d4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8df54cbab1b05dae27118a586c3d4c4">&#9670;&#160;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d1f7ecf7379c91d2d97bc70f20d5e24" name="a6d1f7ecf7379c91d2d97bc70f20d5e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1f7ecf7379c91d2d97bc70f20d5e24">&#9670;&#160;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename <a class="el" href="../../df/dca/FlexTypes_8h.html#ac775e369c033ede683d47ebc2b5ae2a0">Int</a>&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::copy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../df/dca/FlexTypes_8h.html#ae61b2b49771cae3d1484b00260fdaff7">IntMat</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>b2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1b3637aa8820727e70ae7e915f3cde53" name="a1b3637aa8820727e70ae7e915f3cde53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3637aa8820727e70ae7e915f3cde53">&#9670;&#160;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t LatticeTester::getWidth </td>
          <td>(</td>
          <td class="paramtype">clock_t</td>          <td class="paramname"><span class="paramname"><em>time</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>message</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">clock_t</td>          <td class="paramname"><span class="paramname"><em>totals</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>ind</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel inline">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a name="doc-var-members" id="doc-var-members"></a><h2 id="header-doc-var-members" class="groupheader">Variable Documentation</h2>
<a id="ac9adbd421a1148216c8eac1b7d96a5b8" name="ac9adbd421a1148216c8eac1b7d96a5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9adbd421a1148216c8eac1b7d96a5b8">&#9670;&#160;</a></span>MAX_LONG_DOUBLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double LatticeTester::MAX_LONG_DOUBLE = 9007199254740992.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum integer that can be represented exactly as a <span class="tt">double</span>: \(2^{53}\). </p>

</div>
</div>
<a id="ae5f464bde0cd79b7bbc47ff090e49b31" name="ae5f464bde0cd79b7bbc47ff090e49b31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae5f464bde0cd79b7bbc47ff090e49b31">&#9670;&#160;</a></span>TWO_EXP</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const std::int64_t LatticeTester::TWO_EXP[]</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel extern">extern</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Table of powers of 2: <span class="tt">TWO_EXP[</span> \(i\)<span class="tt">]</span> \(= 2^i\), \(i=0, 1, …, 63\). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<div id="page-nav" class="page-nav-panel">
<div id="page-nav-resize-handle"></div>
<div id="page-nav-tree">
<div id="page-nav-contents">
</div><!-- page-nav-contents -->
</div><!-- page-nav-tree -->
</div><!-- page-nav -->
</div><!-- container -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <a href="https://github.com/umontreal-simul/latticetester">Available on Github</a>
    <li class="navelem"><a href="../../d8/d74/namespaceLatticeTester.html">LatticeTester</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.14.0 </li>
  </ul>
</div>
</body>
</html>
