<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Lattice Tester Online Documentation: LatticeTester Namespace Reference</title>
<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../dynsections.js"></script>
<script type="text/javascript" src="../../clipboard.js"></script>
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../navtreedata.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../cookie.js"></script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/searchdata.js"></script>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  extensions: ["tex2jax.js", "TeX/AMSmath.js"],
  jax: ["input/TeX","output/HTML-CSS"],
});
</script>
<script type="text/javascript" async="async" src="https://cdn.jsdelivr.net/npm/mathjax@2/MathJax.js"></script>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../latticetester.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Lattice Tester Online Documentation<span id="projectnumber">&#160;0.1.0-861</span>
   </div>
   <div id="projectbrief">Software Package For Testing The Uniformity Of Integral Lattices In The Real Space</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "../../search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(1); });
/* @license-end */
</script>
<script type="text/javascript" src="../../menudata.js"></script>
<script type="text/javascript" src="../../menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('../../',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('d8/d74/namespaceLatticeTester.html','../../'); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle"><div class="title">LatticeTester Namespace Reference</div></div>
</div><!--header-->
<div class="contents">

<p>Lattice namespace.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="namespaces" name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/d6f/namespaceLatticeTester_1_1CoordinateSets.html">CoordinateSets</a></td></tr>
<tr class="memdesc:d0/d6f/namespaceLatticeTester_1_1CoordinateSets"><td class="mdescLeft">&#160;</td><td class="mdescRight">The classes <code>FromRange</code>, <code>SubSets</code>, and <code><a class="el" href="../../d7/d31/classLatticeTester_1_1CoordinateSets_1_1AddCoordinate.html" title="This template class wraps any implementation of a CoordinateSets and adds a specific coordinate to ea...">AddCoordinate</a></code> are defined here. <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">namespace &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d3/dfe/namespaceLatticeTester_1_1Random.html">Random</a></td></tr>
<tr class="memdesc:d3/dfe/namespaceLatticeTester_1_1Random"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class generates random numbers (in fact pseudo-random numbers). <br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d32/classLatticeTester_1_1Chrono.html">Chrono</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class acts as an interface to the system clock to compute the CPU time used by parts of a program.  <a href="../../d9/d32/classLatticeTester_1_1Chrono.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is basically a <code>std::set&lt;std::size_t&gt;</code>, i.e., a standard C++ set.  <a href="../../d9/dd3/classLatticeTester_1_1Coordinates.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/ddf/classLatticeTester_1_1FigureOfMeritDualM.html">FigureOfMeritDualM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class offers funcitons to calculate the figure of merit (FOM) for the m-dual of any given '<a class="el" href="../../d8/d6c/classLatticeTester_1_1IntLatticeExt.html" title="This abstract class extends IntLattice and is a skeleton for the specialized subclasses that define s...">IntLatticeExt</a>' object.  <a href="../../d4/ddf/classLatticeTester_1_1FigureOfMeritDualM.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d7/dca/classLatticeTester_1_1FigureOfMeritM.html">FigureOfMeritM</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">$\f, for each order \(s &gt; 1\).  <a href="../../d7/dca/classLatticeTester_1_1FigureOfMeritM.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/df4/classLatticeTester_1_1FoMCalc.html">FoMCalc</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class offers methods (functions) to calculate figure of merit for a given <a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html" title="An IntLattice object is an integral lattice, with its basis or its m-dual basis, or both.">IntLattice</a> object.  <a href="../../d9/df4/classLatticeTester_1_1FoMCalc.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html">IntLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">An <code><a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html" title="An IntLattice object is an integral lattice, with its basis or its m-dual basis, or both.">IntLattice</a></code> object is an integral lattice, with its basis or its <code>m</code>-dual basis, or both.  <a href="../../d6/dc0/classLatticeTester_1_1IntLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d6c/classLatticeTester_1_1IntLatticeExt.html">IntLatticeExt</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This abstract class extends <code><a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html" title="An IntLattice object is an integral lattice, with its basis or its m-dual basis, or both.">IntLattice</a></code> and is a skeleton for the specialized subclasses that define specific types of lattices.  <a href="../../d8/d6c/classLatticeTester_1_1IntLatticeExt.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d3b/classLatticeTester_1_1Lacunary.html">Lacunary</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">REMOVE!  <a href="../../d8/d3b/classLatticeTester_1_1Lacunary.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/d4e/classLatticeTester_1_1MRGLattice.html">MRGLattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subclass of <code><a class="el" href="../../d8/d6c/classLatticeTester_1_1IntLatticeExt.html" title="This abstract class extends IntLattice and is a skeleton for the specialized subclasses that define s...">IntLatticeExt</a></code> defines an MRG lattice and is similar to <a class="el" href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html" title="This subclass of IntLatticeExt defines a general rank 1 lattice rule in  dimensions,...">Rank1Lattice</a>, but constructs lattices associated with multiple recursive generators (MRGs) with modulus m, order k, and vector of multipliers a = (a_1, .  <a href="../../d9/d4e/classLatticeTester_1_1MRGLattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../df/de5/classLatticeTester_1_1NormaBestBound.html">NormaBestBound</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">In this normalizer, the Hermite constants \(\gamma_s\) are approximated using the best upper bounds that are available.  <a href="../../df/de5/classLatticeTester_1_1NormaBestBound.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d24/classLatticeTester_1_1NormaBestLat.html">NormaBestLat</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="../../d0/dc8/classLatticeTester_1_1Normalizer.html" title="This is a base class for implementing normalization constants used in figures of merit,...">Normalizer</a> class implements upper bounds on the length of the shortest nonzero vector in a lattice.  <a href="../../d1/d24/classLatticeTester_1_1NormaBestLat.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d0f/classLatticeTester_1_1NormaLaminated.html">NormaLaminated</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <a class="el" href="../../d0/dc8/classLatticeTester_1_1Normalizer.html" title="This is a base class for implementing normalization constants used in figures of merit,...">Normalizer</a> class implements upper bounds on the length of the shortest nonzero vector in a lattice.  <a href="../../dd/d0f/classLatticeTester_1_1NormaLaminated.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dc8/classLatticeTester_1_1Normalizer.html">Normalizer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is a base class for implementing normalization constants used in figures of merit, to normalize the length of the shortest nonzero vector in either the primal or dual lattice.  <a href="../../d0/dc8/classLatticeTester_1_1Normalizer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/dea/classLatticeTester_1_1NormaMinkL2.html">NormaMinkL2</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements Minkowski’s theoretical <b>LOWER</b> bound on the length of the shortest non-zero vector in a lattice, with the \({\mathcal{L}}_2\) norm.  <a href="../../d1/dea/classLatticeTester_1_1NormaMinkL2.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d6e/classLatticeTester_1_1NormaPalpha.html">NormaPalpha</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements some theoretical bounds on the values of \(P_{\alpha}\) for a lattice (see class <code>Palpha</code>).  <a href="../../d8/d6e/classLatticeTester_1_1NormaPalpha.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d30/classLatticeTester_1_1NormaRogers.html">NormaRogers</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class implements upper bounds on the length of the shortest nonzero vector in a lattice, in which the Hermite constants \(\gamma_s\) are approximated by their Rogers's bounds.  <a href="../../d1/d30/classLatticeTester_1_1NormaRogers.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../da/d47/classLatticeTester_1_1ParamReader.html">ParamReader</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility class that can be used to read different kind of data from a file.  <a href="../../da/d47/classLatticeTester_1_1ParamReader.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html">Rank1Lattice</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This subclass of <code><a class="el" href="../../d8/d6c/classLatticeTester_1_1IntLatticeExt.html" title="This abstract class extends IntLattice and is a skeleton for the specialized subclasses that define s...">IntLatticeExt</a></code> defines a general rank 1 lattice rule in \(d\) dimensions, whose points \(\mathbb{u}_i\) are defined by.  <a href="../../de/dfe/classLatticeTester_1_1Rank1Lattice.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d0/dea/classLatticeTester_1_1ReducerBB.html">ReducerBB</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This <code><a class="el" href="../../d0/dea/classLatticeTester_1_1ReducerBB.html" title="This ReducerBB class provides facilities to reduce the basis of a lattice (an IntLattice object) in v...">ReducerBB</a></code> class provides facilities to reduce the basis of a lattice (an <code><a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html" title="An IntLattice object is an integral lattice, with its basis or its m-dual basis, or both.">IntLattice</a></code> object) in various ways (pairwise, LLL, BKZ, Minkowski <a class="el" href="../../d0/de3/citelist.html#CITEREF_rdie75a">[4]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_mlen82a">[9]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_msch91a">[10]</a>), and to find a shortest nonzero vector in the lattice using a BB algorithm <b>[rFIN85a]</b>.  <a href="../../d0/dea/classLatticeTester_1_1ReducerBB.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d6/df9/classLatticeTester_1_1Types.html">Types</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets standard <code>typedef</code>’s for the types that can be used in <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a>.  <a href="../../d6/df9/classLatticeTester_1_1Types.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html">Weights</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Abstract class that defines an interface to specify <a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html" title="Abstract class that defines an interface to specify Weights given to projections in figures of merit.">Weights</a> given to projections in figures of merit.  <a href="../../db/d40/classLatticeTester_1_1Weights.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d7f/classLatticeTester_1_1WeightsOrderDependent.html">WeightsOrderDependent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines order-dependent weights.  <a href="../../dd/d7f/classLatticeTester_1_1WeightsOrderDependent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d8/d0e/classLatticeTester_1_1WeightsPOD.html">WeightsPOD</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines product and order-dependent (POD) weights.  <a href="../../d8/d0e/classLatticeTester_1_1WeightsPOD.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d1/d8a/classLatticeTester_1_1WeightsProduct.html">WeightsProduct</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines product weights.  <a href="../../d1/d8a/classLatticeTester_1_1WeightsProduct.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html">WeightsProjectionDependent</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Defines projection-dependent weights.  <a href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../dd/d8f/classLatticeTester_1_1WeightsUniform.html">WeightsUniform</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Specifies projection weights that are the same (usually 1) for all projections.  <a href="../../dd/d8f/classLatticeTester_1_1WeightsUniform.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d4/dc5/classLatticeTester_1_1Writer.html">Writer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This is an abstract class that represents an interface to <code><a class="el" href="../../d4/dc5/classLatticeTester_1_1Writer.html" title="This is an abstract class that represents an interface to Writer classes.">Writer</a></code> classes.  <a href="../../d4/dc5/classLatticeTester_1_1Writer.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d30/classLatticeTester_1_1WriterRes.html">WriterRes</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This class is a simple implementation of the <code><a class="el" href="../../d4/dc5/classLatticeTester_1_1Writer.html" title="This is an abstract class that represents an interface to Writer classes.">Writer</a></code> abstract class to write in plain text format on the stream.  <a href="../../d2/d30/classLatticeTester_1_1WriterRes.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a951f7e7b03767aa0971dde55f9d328ec" id="r_a951f7e7b03767aa0971dde55f9d328ec"><td class="memItemLeft" align="right" valign="top">typedef double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a951f7e7b03767aa0971dde55f9d328ec">Weight</a></td></tr>
<tr class="memdesc:a951f7e7b03767aa0971dde55f9d328ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">A scalar weight type.  <br /></td></tr>
<tr class="separator:a951f7e7b03767aa0971dde55f9d328ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a9770e4d57aa715e249cd7e700c6f37e4" id="r_a9770e4d57aa715e249cd7e700c6f37e4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> { <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4a3e12e2ca7e65c77c86a8afbbf1faed0d">SUPNORM</a>
, <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4a6031a75d242058c5b26d05f510267b41">L1NORM</a>
, <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4a2d8982335f008ef95768bd7ec450d86b">L2NORM</a>
, <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4a9dd28fa34c8fd3331bd55e85d9b8ff2b">ZAREMBANORM</a>
 }</td></tr>
<tr class="memdesc:a9770e4d57aa715e249cd7e700c6f37e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">The available norm types to measure the length of vectors.  <a href="#a9770e4d57aa715e249cd7e700c6f37e4">More...</a><br /></td></tr>
<tr class="separator:a9770e4d57aa715e249cd7e700c6f37e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad78f099c800f4c648134967a45b91058" id="r_ad78f099c800f4c648134967a45b91058"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ad78f099c800f4c648134967a45b91058">OutputType</a> { <a class="el" href="#ad78f099c800f4c648134967a45b91058a7424f6330dcef06bb69cd6d1f4f9045a">TERM</a>
, <a class="el" href="#ad78f099c800f4c648134967a45b91058a0c648307bf3301ea0606de04fcb79715">RES</a>
, <a class="el" href="#ad78f099c800f4c648134967a45b91058a3143e7b5be2e3d8d6aad062460f51f97">TEX</a>
, <a class="el" href="#ad78f099c800f4c648134967a45b91058a0f15b71adaba58b2f5476a93823f1767">GEN</a>
 }</td></tr>
<tr class="memdesc:ad78f099c800f4c648134967a45b91058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different choices of output formats.  <a href="#ad78f099c800f4c648134967a45b91058">More...</a><br /></td></tr>
<tr class="separator:ad78f099c800f4c648134967a45b91058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad7b917d5ef7e8167bc50aa56109faff" id="r_aad7b917d5ef7e8167bc50aa56109faff"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aad7b917d5ef7e8167bc50aa56109faff">ProblemType</a> { <br />
&#160;&#160;<a class="el" href="#aad7b917d5ef7e8167bc50aa56109faffaa9cfecaf8d5048f10d4016c41ff814d2">BASIS</a>
, <a class="el" href="#aad7b917d5ef7e8167bc50aa56109faffa6230d8b5b7473284e7ae5ce9c99a879a">DUAL</a>
, <a class="el" href="#aad7b917d5ef7e8167bc50aa56109faffae72b9cc5c1b60f82db4dc146e05102bc">REDUCTION</a>
, <a class="el" href="#aad7b917d5ef7e8167bc50aa56109faffabc152d94a75cc74adfdb22335c8980f9">SHORTEST</a>
, <br />
&#160;&#160;<a class="el" href="#aad7b917d5ef7e8167bc50aa56109faffa861d3886c143a0cc3d686de47fb98920">MERIT</a>
<br />
 }</td></tr>
<tr class="memdesc:aad7b917d5ef7e8167bc50aa56109faff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Types of problems that <a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a> can handle.  <a href="#aad7b917d5ef7e8167bc50aa56109faff">More...</a><br /></td></tr>
<tr class="separator:aad7b917d5ef7e8167bc50aa56109faff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94f96ff406f8b56147a2b7fd96209cb2" id="r_a94f96ff406f8b56147a2b7fd96209cb2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> { <a class="el" href="#a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6">DOUBLE</a>
, <a class="el" href="#a94f96ff406f8b56147a2b7fd96209cb2a3a2dae8e1fda53e4a5f9744979a818e0">QUADRUPLE</a>
, <a class="el" href="#a94f96ff406f8b56147a2b7fd96209cb2acf1cb9ccf9b182660b0f40feabc2f007">XDOUBLE</a>
, <a class="el" href="#a94f96ff406f8b56147a2b7fd96209cb2aa4d2c16f89d60274b8ed8859a2594ab7">RR</a>
 }</td></tr>
<tr class="memdesc:a94f96ff406f8b56147a2b7fd96209cb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">This can be supersed by the Real type.  <a href="#a94f96ff406f8b56147a2b7fd96209cb2">More...</a><br /></td></tr>
<tr class="separator:a94f96ff406f8b56147a2b7fd96209cb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b64954fb374b16e1fe991e435501d65" id="r_a9b64954fb374b16e1fe991e435501d65"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9b64954fb374b16e1fe991e435501d65">PrimeType</a> { <a class="el" href="#a9b64954fb374b16e1fe991e435501d65a1a116a76db19a0cf4ad43973fc2c2279">PRIME</a>
, <a class="el" href="#a9b64954fb374b16e1fe991e435501d65a4ad8925491567caca357efe9f609bb27">PROB_PRIME</a>
, <a class="el" href="#a9b64954fb374b16e1fe991e435501d65aac48dba763e4f64c60ef238bf66f82f8">COMPOSITE</a>
, <a class="el" href="#a9b64954fb374b16e1fe991e435501d65a5a0fef7085559362287f893caa97425e">UNKNOWN</a>
 }</td></tr>
<tr class="memdesc:a9b64954fb374b16e1fe991e435501d65"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates whether an integer is prime, probably prime, composite or its status is unknown (or we do not care).  <a href="#a9b64954fb374b16e1fe991e435501d65">More...</a><br /></td></tr>
<tr class="separator:a9b64954fb374b16e1fe991e435501d65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cf3c4f4181718b7adc6f5e4513695a0" id="r_a2cf3c4f4181718b7adc6f5e4513695a0"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2cf3c4f4181718b7adc6f5e4513695a0">CriterionType</a> { <br />
&#160;&#160;<a class="el" href="#a2cf3c4f4181718b7adc6f5e4513695a0ab6783128c1344cbef4cc8429cc63d0b5">LENGTH</a>
, <a class="el" href="#a2cf3c4f4181718b7adc6f5e4513695a0a012ebaf6929fea5b0d330cf292d19e3c">SPECTRAL</a>
, <a class="el" href="#a2cf3c4f4181718b7adc6f5e4513695a0a91ce17e475c9002db6b12ed2e528d7e8">BEYER</a>
, <a class="el" href="#a2cf3c4f4181718b7adc6f5e4513695a0a782750d0af36a267ddfd84b32ae7d79c">PALPHA</a>
, <br />
&#160;&#160;<a class="el" href="#a2cf3c4f4181718b7adc6f5e4513695a0aad5231f38003aaa7c1cc16c314d9605e">BOUND_JS</a>
<br />
 }</td></tr>
<tr class="memdesc:a2cf3c4f4181718b7adc6f5e4513695a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merit criteria to measure the quality of generators or lattices.  <a href="#a2cf3c4f4181718b7adc6f5e4513695a0">More...</a><br /></td></tr>
<tr class="separator:a2cf3c4f4181718b7adc6f5e4513695a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab747c1cbb0f5e47fef711b62327a8e90" id="r_ab747c1cbb0f5e47fef711b62327a8e90"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a> { <br />
&#160;&#160;<a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90a6f65388b2929fedcf40d456d30df3551">BESTLAT</a>
, <a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90af1bfd880a4ddd5ed4fb67c6b69a5f1bf">BESTBOUND</a>
, <a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90ae8842bb9870dacacc65ef1ad46f8fa4b">LAMINATED</a>
, <a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90a81b5bfa5986a0cf0f014837542837641">ROGERS</a>
, <br />
&#160;&#160;<a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90a5e579ba5452180d37e3e048875ba46e5">MINKL1</a>
, <a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90ae8cc385eecfe5b72009c9e74386b1c96">MINKL2</a>
, <a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90a5e9d13ae2852670258864320734e0cbf">NONE</a>
<br />
 }</td></tr>
<tr class="memdesc:ab747c1cbb0f5e47fef711b62327a8e90"><td class="mdescLeft">&#160;</td><td class="mdescRight">Different types of normalizations that can be used for shortest-vector lengths.  <a href="#ab747c1cbb0f5e47fef711b62327a8e90">More...</a><br /></td></tr>
<tr class="separator:ab747c1cbb0f5e47fef711b62327a8e90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d2f9ab69a9d586b8273cbb29bb105fe" id="r_a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105fe">CalcType</a> { <a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105feae444ad54301419ac37ef878aedb20234">PAL</a>
, <a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105fea18fa93c0ce684acf5f50252d813034f4">NORMPAL</a>
, <a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105fea1eea8810a9a8d0e0721cbab47592d29c">BAL</a>
, <a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105feae7e8d0e1b5a15810847d798d1fe0b039">SEEKPAL</a>
 }</td></tr>
<tr class="memdesc:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Indicates which type of calculation is considered for the \(P_{\alpha}\) test.  <a href="#a0d2f9ab69a9d586b8273cbb29bb105fe">More...</a><br /></td></tr>
<tr class="separator:a0d2f9ab69a9d586b8273cbb29bb105fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2a213e64bd54d3e33a7aff0f80068cb" id="r_af2a213e64bd54d3e33a7aff0f80068cb"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cb">ReductionType</a> { <br />
&#160;&#160;<a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cba7212a3bb53b382d1e38c3f8cdf7a47cf">PAIR</a>
, <a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cba8d04551154f945a747c129cdabff4af5">LLL</a>
, <a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cba14aace9298ad3f3297ff86c30b8d34eb">BKZ</a>
, <a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cba00217b110040213df758637d15e36795">BB</a>
, <br />
&#160;&#160;<a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cba59eedbabbb28a332f4d36822d74ae6dd">PAIRBB</a>
, <a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cba841193f6d276a17aff255f4f59a712d9">LLLBB</a>
, <a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cba3c1372bd908125ef772819276035b74c">BKZBB</a>
<br />
 }</td></tr>
<tr class="memdesc:af2a213e64bd54d3e33a7aff0f80068cb"><td class="mdescLeft">&#160;</td><td class="mdescRight">A list of all the possible lattice reductions implemented in <code><a class="el" href="d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></code>.  <a href="#af2a213e64bd54d3e33a7aff0f80068cb">More...</a><br /></td></tr>
<tr class="separator:af2a213e64bd54d3e33a7aff0f80068cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5bf461b8f167cc8c7ebebc8ee6a96ee4" id="r_a5bf461b8f167cc8c7ebebc8ee6a96ee4"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">DecompTypeBB</a> { <a class="el" href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4a3266f268976e38e1d5e53fb38ef4de9d">CHOLESKY</a>
, <a class="el" href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4ab3f7f0887ca0f53844b887588c92cd66">TRIANGULAR</a>
 }</td></tr>
<tr class="memdesc:a5bf461b8f167cc8c7ebebc8ee6a96ee4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two possible ways of obtaining a triangular matrix to compute the bounds in the BB algorithm.  <a href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">More...</a><br /></td></tr>
<tr class="separator:a5bf461b8f167cc8c7ebebc8ee6a96ee4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ff6c9ee29ca0bac6c63d2622508aa46" id="r_a1ff6c9ee29ca0bac6c63d2622508aa46"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a> { <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46a59c23f7e8d888fc3e79108dea9475dbb">LLLPROJ</a>
, <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46abbfbd0f53d264fdd705b4416b8c36d87">UPPERTRIPROJ</a>
 }</td></tr>
<tr class="memdesc:a1ff6c9ee29ca0bac6c63d2622508aa46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two possible ways of computing the basis for a projection.  <a href="#a1ff6c9ee29ca0bac6c63d2622508aa46">More...</a><br /></td></tr>
<tr class="separator:a1ff6c9ee29ca0bac6c63d2622508aa46"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e9e347d07097a1a3c82f1699ff93d58" id="r_a5e9e347d07097a1a3c82f1699ff93d58"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5e9e347d07097a1a3c82f1699ff93d58">MeritType</a> { <a class="el" href="#a5e9e347d07097a1a3c82f1699ff93d58a094d81300c3a1bd13d96d01e8c53a3ad">MERITM</a>
, <a class="el" href="#a5e9e347d07097a1a3c82f1699ff93d58ad875e35fbaf2f2e8be530376935b6c6d">MERITQ</a>
 }</td></tr>
<tr class="memdesc:a5e9e347d07097a1a3c82f1699ff93d58"><td class="mdescLeft">&#160;</td><td class="mdescRight">Two different types of figures of merit.  <a href="#a5e9e347d07097a1a3c82f1699ff93d58">More...</a><br /></td></tr>
<tr class="separator:a5e9e347d07097a1a3c82f1699ff93d58"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5f920d49aa69c0997fcb3d9a57be59fd" id="r_a5f920d49aa69c0997fcb3d9a57be59fd"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename RealVec &gt; </td></tr>
<tr class="memitem:a5f920d49aa69c0997fcb3d9a57be59fd"><td class="memTemplItemLeft" align="right" valign="top">static long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5f920d49aa69c0997fcb3d9a57be59fd">LLLConstruction0</a> (IntMat &amp;gen, const double delta=0.9, long r=0, long c=0, RealVec *sqlen=0)</td></tr>
<tr class="memdesc:a5f920d49aa69c0997fcb3d9a57be59fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">This static class offers methods (functions) to construct a basis from a set of generating vectors that are not necessarily independent, to construct a triangular basis, to construct the basis for a projection over a given subset of coordinates, and to obtain the \(m\)-dual of a given basis.  <br /></td></tr>
<tr class="separator:a5f920d49aa69c0997fcb3d9a57be59fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b7cb50b78290e16a29bd5e4be503a1f" id="r_a1b7cb50b78290e16a29bd5e4be503a1f"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int , typename RealVec &gt; </td></tr>
<tr class="memitem:a1b7cb50b78290e16a29bd5e4be503a1f"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1b7cb50b78290e16a29bd5e4be503a1f">LLLBasisConstruction</a> (IntMat &amp;gen, const Int &amp;m, const double delta=0.9, long r=0, long c=0, RealVec *sqlen=0)</td></tr>
<tr class="memdesc:a1b7cb50b78290e16a29bd5e4be503a1f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>LLLConstruction0</code>, except that in case the set of generating vectors do not generate a full-dimensional lattice, it adds the vectors \(m e_i\) to the generating set, so it always returns a square matrix.  <br /></td></tr>
<tr class="separator:a1b7cb50b78290e16a29bd5e4be503a1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdf5792485dd769979e3d1e3e9da1932" id="r_acdf5792485dd769979e3d1e3e9da1932"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:acdf5792485dd769979e3d1e3e9da1932"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acdf5792485dd769979e3d1e3e9da1932">lowerTriangularBasis</a> (IntMat &amp;gen, IntMat &amp;basis, const Int &amp;m, long r=0, long c=0)</td></tr>
<tr class="memdesc:acdf5792485dd769979e3d1e3e9da1932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a set of generating vectors in the matrix <code>gen</code> and iteratively transforms it into a lower triangular lattice basis into the matrix <code>basis</code>.  <br /></td></tr>
<tr class="separator:acdf5792485dd769979e3d1e3e9da1932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03944f3ab46d31e7574872bcfaad6956" id="r_a03944f3ab46d31e7574872bcfaad6956"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:a03944f3ab46d31e7574872bcfaad6956"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a03944f3ab46d31e7574872bcfaad6956">upperTriangularBasis</a> (IntMat &amp;gen, IntMat &amp;basis, const Int &amp;m, long r=0, long c=0)</td></tr>
<tr class="memdesc:a03944f3ab46d31e7574872bcfaad6956"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>lowerTriangularBasis</code>, except that the returned basis is upper triangular.  <br /></td></tr>
<tr class="separator:a03944f3ab46d31e7574872bcfaad6956"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7138efa423d213c77627f9e530e37533" id="r_a7138efa423d213c77627f9e530e37533"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:a7138efa423d213c77627f9e530e37533"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7138efa423d213c77627f9e530e37533">mDualUpperTriangular</a> (const IntMat &amp;basis, IntMat &amp;basisDual, const Int &amp;m, long dim=0)</td></tr>
<tr class="memdesc:a7138efa423d213c77627f9e530e37533"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an upper triangular basis matrix <code>basis</code> and computes the m-dual basis <code>basisDual</code>.  <br /></td></tr>
<tr class="separator:a7138efa423d213c77627f9e530e37533"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81445b4f83a91c2b0c25685c17b66d0b" id="r_a81445b4f83a91c2b0c25685c17b66d0b"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:a81445b4f83a91c2b0c25685c17b66d0b"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a81445b4f83a91c2b0c25685c17b66d0b">mDualUpperTriangular96</a> (IntMat &amp;basis, IntMat &amp;basisDual, const Int &amp;m, long dim=0)</td></tr>
<tr class="memdesc:a81445b4f83a91c2b0c25685c17b66d0b"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does essentially the same thing as <code>mDualUpperTriangular</code>, but the algorithm is slightly different.  <br /></td></tr>
<tr class="separator:a81445b4f83a91c2b0c25685c17b66d0b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3846fec78f4c1d9e01cdd3cf3e39402a" id="r_a3846fec78f4c1d9e01cdd3cf3e39402a"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:a3846fec78f4c1d9e01cdd3cf3e39402a"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3846fec78f4c1d9e01cdd3cf3e39402a">mDualBasis</a> (const IntMat &amp;basis, IntMat &amp;basisDual, const Int &amp;m)</td></tr>
<tr class="memdesc:a3846fec78f4c1d9e01cdd3cf3e39402a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assumes that <code>basis</code> contains a basis of the primal lattice scaled by the factor <code>m</code>, not necessarily triangular, and it returns in <code>basisDual</code> the m-dual basis.  <br /></td></tr>
<tr class="separator:a3846fec78f4c1d9e01cdd3cf3e39402a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e3a4b511029d1a02eadee427a2552bc" id="r_a6e3a4b511029d1a02eadee427a2552bc"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a6e3a4b511029d1a02eadee427a2552bc"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6e3a4b511029d1a02eadee427a2552bc">projectMatrix</a> (const IntMat &amp;in, IntMat &amp;out, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, long r=0)</td></tr>
<tr class="memdesc:a6e3a4b511029d1a02eadee427a2552bc"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function overwrites the first <code>r</code> rows of matrix 'out' by a matrix formed by the first <code>r</code> rows of the c columns of matrix <code>in</code> that are specified by <code>proj</code>, where &lsquo;c = size(proj)&rsquo; is the cardinality of the projection <code>proj</code>.  <br /></td></tr>
<tr class="separator:a6e3a4b511029d1a02eadee427a2552bc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b44e3431a9398fee293afdb50a9eac0" id="r_a8b44e3431a9398fee293afdb50a9eac0"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int , typename RealVec &gt; </td></tr>
<tr class="memitem:a8b44e3431a9398fee293afdb50a9eac0"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a8b44e3431a9398fee293afdb50a9eac0">projectionConstructionLLL</a> (const IntMat &amp;inBasis, IntMat &amp;projBasis, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const Int &amp;m, const double delta=0.9, long r=0, RealVec *sqlen=0)</td></tr>
<tr class="memdesc:a8b44e3431a9398fee293afdb50a9eac0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a basis for the projection <code>proj</code> of the lattice with basis <code>inBasis</code>, using <code>LLLBasisConstruction</code>, and returns it in <code>projBasis</code>.  <br /></td></tr>
<tr class="separator:a8b44e3431a9398fee293afdb50a9eac0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac555f6bc3b0697b2e1d01ca0e0f71266" id="r_ac555f6bc3b0697b2e1d01ca0e0f71266"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:ac555f6bc3b0697b2e1d01ca0e0f71266"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac555f6bc3b0697b2e1d01ca0e0f71266">projectionConstructionUpperTri</a> (const IntMat &amp;inBasis, IntMat &amp;projBasis, IntMat &amp;genTemp, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const Int &amp;m, long r=0)</td></tr>
<tr class="memdesc:ac555f6bc3b0697b2e1d01ca0e0f71266"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>projectionConstructionLLL</code>, but the construction is made using <code>upperTriangularBasis</code>, so the returned basis is upper triangular.  <br /></td></tr>
<tr class="separator:ac555f6bc3b0697b2e1d01ca0e0f71266"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4905b16a640714661b755092217cad8d" id="r_a4905b16a640714661b755092217cad8d"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:a4905b16a640714661b755092217cad8d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a4905b16a640714661b755092217cad8d">projectionConstructionUpperTri</a> (const IntMat &amp;inBasis, IntMat &amp;projBasis, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const Int &amp;m, long r=0)</td></tr>
<tr class="separator:a4905b16a640714661b755092217cad8d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b0c2d123e1f561094f709a17763334d" id="r_a3b0c2d123e1f561094f709a17763334d"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:a3b0c2d123e1f561094f709a17763334d"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3b0c2d123e1f561094f709a17763334d">projectionConstruction</a> (const IntMat &amp;inBasis, IntMat &amp;projBasis, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const Int &amp;m, const <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a> projType=<a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46a59c23f7e8d888fc3e79108dea9475dbb">LLLPROJ</a>, const double delta=0.9)</td></tr>
<tr class="memdesc:a3b0c2d123e1f561094f709a17763334d"><td class="mdescLeft">&#160;</td><td class="mdescRight">In this version, the construction method is passed as a parameter.  <br /></td></tr>
<tr class="separator:a3b0c2d123e1f561094f709a17763334d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af33527fba4e1dd098e8175fdf11afd22" id="r_af33527fba4e1dd098e8175fdf11afd22"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af33527fba4e1dd098e8175fdf11afd22"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af33527fba4e1dd098e8175fdf11afd22">LLLConstruction0</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; long &gt; &amp;gen, const double delta, long r, long c, <a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; double &gt; *sqlen)</td></tr>
<tr class="separator:af33527fba4e1dd098e8175fdf11afd22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a53d806c42058b19f3230a0c07b947dd6" id="r_a53d806c42058b19f3230a0c07b947dd6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a53d806c42058b19f3230a0c07b947dd6"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a53d806c42058b19f3230a0c07b947dd6">LLLConstruction0</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;gen, const double delta, long r, long c, <a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; double &gt; *sqlen)</td></tr>
<tr class="separator:a53d806c42058b19f3230a0c07b947dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d0e87ed1324a4d20f9289b472fe7152" id="r_a0d0e87ed1324a4d20f9289b472fe7152"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a0d0e87ed1324a4d20f9289b472fe7152"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0d0e87ed1324a4d20f9289b472fe7152">LLLConstruction0</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;gen, const double delta, long r, long c, <a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; xdouble &gt; *sqlen)</td></tr>
<tr class="separator:a0d0e87ed1324a4d20f9289b472fe7152"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2be7cff765f069ec24b7981db80329d2" id="r_a2be7cff765f069ec24b7981db80329d2"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a2be7cff765f069ec24b7981db80329d2"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2be7cff765f069ec24b7981db80329d2">LLLConstruction0</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;gen, const double delta, long r, long c, <a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; quad_float &gt; *sqlen)</td></tr>
<tr class="separator:a2be7cff765f069ec24b7981db80329d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acd510238da86208faddf5ec94f2b3e53" id="r_acd510238da86208faddf5ec94f2b3e53"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:acd510238da86208faddf5ec94f2b3e53"><td class="memTemplItemLeft" align="right" valign="top">long&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acd510238da86208faddf5ec94f2b3e53">LLLConstruction0</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;gen, const double delta, long r, long c, <a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; NTL::RR &gt; *sqlen)</td></tr>
<tr class="separator:acd510238da86208faddf5ec94f2b3e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a173df7d0a7848d304c51a0559e851502" id="r_a173df7d0a7848d304c51a0559e851502"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int , typename RealVec &gt; </td></tr>
<tr class="memitem:a173df7d0a7848d304c51a0559e851502"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a173df7d0a7848d304c51a0559e851502">LLLBasisConstruction</a> (IntMat &amp;gen, const Int &amp;m, double delta, long r, long c, RealVec *sqlen)</td></tr>
<tr class="memdesc:a173df7d0a7848d304c51a0559e851502"><td class="mdescLeft">&#160;</td><td class="mdescRight">Similar to <code>LLLConstruction0</code>, except that in case the set of generating vectors do not generate a full-dimensional lattice, it adds the vectors \(m e_i\) to the generating set, so it always returns a square matrix.  <br /></td></tr>
<tr class="separator:a173df7d0a7848d304c51a0559e851502"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9069b42c071e7adac5f4af470cc8acd5" id="r_a9069b42c071e7adac5f4af470cc8acd5"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:a9069b42c071e7adac5f4af470cc8acd5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9069b42c071e7adac5f4af470cc8acd5">lowerTriangularBasis</a> (IntMat &amp;gen, IntMat &amp;basis, const Int &amp;m, long dim1, long dim2)</td></tr>
<tr class="memdesc:a9069b42c071e7adac5f4af470cc8acd5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a set of generating vectors in the matrix <code>gen</code> and iteratively transforms it into a lower triangular lattice basis into the matrix <code>basis</code>.  <br /></td></tr>
<tr class="separator:a9069b42c071e7adac5f4af470cc8acd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b5a16cceddb84cf6ee280cc6d0e7281" id="r_a6b5a16cceddb84cf6ee280cc6d0e7281"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:a6b5a16cceddb84cf6ee280cc6d0e7281"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6b5a16cceddb84cf6ee280cc6d0e7281">upperTriangularBasis</a> (IntMat &amp;gen, IntMat &amp;basis, const Int &amp;m, long dim1, long dim2)</td></tr>
<tr class="memdesc:a6b5a16cceddb84cf6ee280cc6d0e7281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>lowerTriangularBasis</code>, except that the returned basis is upper triangular.  <br /></td></tr>
<tr class="separator:a6b5a16cceddb84cf6ee280cc6d0e7281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c3c0496c2570e89c7e0cb221911e9ca" id="r_a6c3c0496c2570e89c7e0cb221911e9ca"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:a6c3c0496c2570e89c7e0cb221911e9ca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c3c0496c2570e89c7e0cb221911e9ca">mDualUpperTriangular</a> (const IntMat &amp;A, IntMat &amp;B, const Int &amp;m, long dim)</td></tr>
<tr class="memdesc:a6c3c0496c2570e89c7e0cb221911e9ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">For <code>B</code> to be <code>m</code>-dual to <code>A</code>, we have to have that \(AB^t = mI\).  <br /></td></tr>
<tr class="separator:a6c3c0496c2570e89c7e0cb221911e9ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6384cd156f8be50657091b44faa46d44" id="r_a6384cd156f8be50657091b44faa46d44"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:a6384cd156f8be50657091b44faa46d44"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6384cd156f8be50657091b44faa46d44">mDualUpperTriangular96</a> (IntMat &amp;basis, IntMat &amp;basisDual, const Int &amp;m, long dim)</td></tr>
<tr class="memdesc:a6384cd156f8be50657091b44faa46d44"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function does essentially the same thing as <code>mDualUpperTriangular</code>, but the algorithm is slightly different.  <br /></td></tr>
<tr class="separator:a6384cd156f8be50657091b44faa46d44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3208c417df961de57aa5dd66a316708" id="r_ad3208c417df961de57aa5dd66a316708"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad3208c417df961de57aa5dd66a316708"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad3208c417df961de57aa5dd66a316708">mDualUpperTriangular96</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;basis, <a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;basisDual, const NTL::ZZ &amp;m, long dim)</td></tr>
<tr class="separator:ad3208c417df961de57aa5dd66a316708"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79552d814332bea466c22b483081c2d5" id="r_a79552d814332bea466c22b483081c2d5"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:a79552d814332bea466c22b483081c2d5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a79552d814332bea466c22b483081c2d5">mDualBasis</a> (const IntMat &amp;basis, IntMat &amp;basisDual, const Int &amp;m)</td></tr>
<tr class="memdesc:a79552d814332bea466c22b483081c2d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function assumes that <code>basis</code> contains a basis of the primal lattice scaled by the factor <code>m</code>, not necessarily triangular, and it returns in <code>basisDual</code> the m-dual basis.  <br /></td></tr>
<tr class="separator:a79552d814332bea466c22b483081c2d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16a8ee34d4c3df1e33dd4da6e2802ff6" id="r_a16a8ee34d4c3df1e33dd4da6e2802ff6"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a16a8ee34d4c3df1e33dd4da6e2802ff6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a16a8ee34d4c3df1e33dd4da6e2802ff6">mDualBasis</a> (const <a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;basis, <a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;basisDual, const NTL::ZZ &amp;m)</td></tr>
<tr class="separator:a16a8ee34d4c3df1e33dd4da6e2802ff6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46d57a1843afbeadd14a364a1b63fcaf" id="r_a46d57a1843afbeadd14a364a1b63fcaf"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a46d57a1843afbeadd14a364a1b63fcaf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a46d57a1843afbeadd14a364a1b63fcaf">projectMatrix</a> (const IntMat &amp;in, IntMat &amp;out, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, long r)</td></tr>
<tr class="memdesc:a46d57a1843afbeadd14a364a1b63fcaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">This function overwrites the first <code>r</code> rows of matrix 'out' by a matrix formed by the first <code>r</code> rows of the c columns of matrix <code>in</code> that are specified by <code>proj</code>, where &lsquo;c = size(proj)&rsquo; is the cardinality of the projection <code>proj</code>.  <br /></td></tr>
<tr class="separator:a46d57a1843afbeadd14a364a1b63fcaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a79a0e1eada5eb4f7ff364e8fd88790f1" id="r_a79a0e1eada5eb4f7ff364e8fd88790f1"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int , typename RealVec &gt; </td></tr>
<tr class="memitem:a79a0e1eada5eb4f7ff364e8fd88790f1"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a79a0e1eada5eb4f7ff364e8fd88790f1">projectionConstructionLLL</a> (const IntMat &amp;inBasis, IntMat &amp;projBasis, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const Int &amp;m, const double delta, long r, RealVec *sqlen)</td></tr>
<tr class="memdesc:a79a0e1eada5eb4f7ff364e8fd88790f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Constructs a basis for the projection <code>proj</code> of the lattice with basis <code>inBasis</code>, using <code>LLLBasisConstruction</code>, and returns it in <code>projBasis</code>.  <br /></td></tr>
<tr class="separator:a79a0e1eada5eb4f7ff364e8fd88790f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aebd32af27ce2a029c3c4ad7ffcae9b62" id="r_aebd32af27ce2a029c3c4ad7ffcae9b62"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:aebd32af27ce2a029c3c4ad7ffcae9b62"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aebd32af27ce2a029c3c4ad7ffcae9b62">projectionConstructionUpperTri</a> (const IntMat &amp;inBasis, IntMat &amp;projBasis, IntMat &amp;genTemp, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const Int &amp;m, long r)</td></tr>
<tr class="memdesc:aebd32af27ce2a029c3c4ad7ffcae9b62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as <code>projectionConstructionLLL</code>, but the construction is made using <code>upperTriangularBasis</code>, so the returned basis is upper triangular.  <br /></td></tr>
<tr class="separator:aebd32af27ce2a029c3c4ad7ffcae9b62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59b6e968f63dea501d66be8757df2df9" id="r_a59b6e968f63dea501d66be8757df2df9"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:a59b6e968f63dea501d66be8757df2df9"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a59b6e968f63dea501d66be8757df2df9">projectionConstructionUpperTri</a> (const IntMat &amp;inBasis, IntMat &amp;projBasis, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const Int &amp;m, long r)</td></tr>
<tr class="separator:a59b6e968f63dea501d66be8757df2df9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa206b52fdf65b6d25af973775599068" id="r_aaa206b52fdf65b6d25af973775599068"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename Int &gt; </td></tr>
<tr class="memitem:aaa206b52fdf65b6d25af973775599068"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa206b52fdf65b6d25af973775599068">projectionConstruction</a> (const IntMat &amp;inBasis, IntMat &amp;projBasis, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;proj, const Int &amp;m, const <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a> projType, const double delta)</td></tr>
<tr class="memdesc:aaa206b52fdf65b6d25af973775599068"><td class="mdescLeft">&#160;</td><td class="mdescRight">In this version, the construction method is passed as a parameter.  <br /></td></tr>
<tr class="separator:aaa206b52fdf65b6d25af973775599068"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59f5c660b2fa0ddb257ebb31b219d451" id="r_a59f5c660b2fa0ddb257ebb31b219d451"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a59f5c660b2fa0ddb257ebb31b219d451">toString</a> (<a class="el" href="../../d9/d32/classLatticeTester_1_1Chrono.html">Chrono</a> &amp;timer)</td></tr>
<tr class="memdesc:a59f5c660b2fa0ddb257ebb31b219d451"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the duration from <code>timer</code>.  <br /></td></tr>
<tr class="separator:a59f5c660b2fa0ddb257ebb31b219d451"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af65fc07f34906524398b038327a0bb14" id="r_af65fc07f34906524398b038327a0bb14"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af65fc07f34906524398b038327a0bb14">toStringNorm</a> (<a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm)</td></tr>
<tr class="memdesc:af65fc07f34906524398b038327a0bb14"><td class="mdescLeft">&#160;</td><td class="mdescRight">The following are functions for printing the <code>enum</code> constants in this module.  <br /></td></tr>
<tr class="separator:af65fc07f34906524398b038327a0bb14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a059f8e56d24041008c87a70625e70ba9" id="r_a059f8e56d24041008c87a70625e70ba9"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a059f8e56d24041008c87a70625e70ba9">toStringOutput</a> (<a class="el" href="#ad78f099c800f4c648134967a45b91058">OutputType</a> out)</td></tr>
<tr class="separator:a059f8e56d24041008c87a70625e70ba9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a07260b18b588fe14165b0ea411934bbd" id="r_a07260b18b588fe14165b0ea411934bbd"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a07260b18b588fe14165b0ea411934bbd">toStringProblem</a> (<a class="el" href="#aad7b917d5ef7e8167bc50aa56109faff">ProblemType</a> prob)</td></tr>
<tr class="separator:a07260b18b588fe14165b0ea411934bbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a70e26765f6794f995a8130fecc030ca7" id="r_a70e26765f6794f995a8130fecc030ca7"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a70e26765f6794f995a8130fecc030ca7">toStringPrecision</a> (<a class="el" href="#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a> precision)</td></tr>
<tr class="separator:a70e26765f6794f995a8130fecc030ca7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6567b0759b046c6deeea98a1c9f4235" id="r_ac6567b0759b046c6deeea98a1c9f4235"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac6567b0759b046c6deeea98a1c9f4235">toStringPrime</a> (<a class="el" href="#a9b64954fb374b16e1fe991e435501d65">PrimeType</a> prim)</td></tr>
<tr class="separator:ac6567b0759b046c6deeea98a1c9f4235"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d14b2942fa515f0e72edfcb4243781c" id="r_a9d14b2942fa515f0e72edfcb4243781c"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9d14b2942fa515f0e72edfcb4243781c">toStringCriterion</a> (<a class="el" href="#a2cf3c4f4181718b7adc6f5e4513695a0">CriterionType</a> criter)</td></tr>
<tr class="separator:a9d14b2942fa515f0e72edfcb4243781c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac24879d5aa087958f258e3a9e3770d37" id="r_ac24879d5aa087958f258e3a9e3770d37"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac24879d5aa087958f258e3a9e3770d37">toStringNorma</a> (<a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a> norma)</td></tr>
<tr class="separator:ac24879d5aa087958f258e3a9e3770d37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fb8cd4f08931a89c70f756d0014b2b2" id="r_a5fb8cd4f08931a89c70f756d0014b2b2"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a5fb8cd4f08931a89c70f756d0014b2b2">toStringCalc</a> (<a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105fe">CalcType</a> calc)</td></tr>
<tr class="separator:a5fb8cd4f08931a89c70f756d0014b2b2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a137cd194ce614d43c80f65557ee96109" id="r_a137cd194ce614d43c80f65557ee96109"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a137cd194ce614d43c80f65557ee96109">toStringReduction</a> (<a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cb">ReductionType</a> reduct)</td></tr>
<tr class="separator:a137cd194ce614d43c80f65557ee96109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a21f1a550ff7e4344554a043faceb7c55" id="r_a21f1a550ff7e4344554a043faceb7c55"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a21f1a550ff7e4344554a043faceb7c55">toStringDecomp</a> (<a class="el" href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">DecompTypeBB</a> decomp)</td></tr>
<tr class="separator:a21f1a550ff7e4344554a043faceb7c55"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e050957b719073c06de41c7486f1ce" id="r_a12e050957b719073c06de41c7486f1ce"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12e050957b719073c06de41c7486f1ce">toStringProjConstruct</a> (<a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a> proj)</td></tr>
<tr class="separator:a12e050957b719073c06de41c7486f1ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2fb1307d0863e4d38a3b813b180014" id="r_a1a2fb1307d0863e4d38a3b813b180014"><td class="memItemLeft" align="right" valign="top">static std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a2fb1307d0863e4d38a3b813b180014">toStringMeritType</a> (<a class="el" href="#a5e9e347d07097a1a3c82f1699ff93d58">MeritType</a> merit)</td></tr>
<tr class="separator:a1a2fb1307d0863e4d38a3b813b180014"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a37022f8ff5b0ea0a0245f4fd7e4c638b" id="r_a37022f8ff5b0ea0a0245f4fd7e4c638b"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a37022f8ff5b0ea0a0245f4fd7e4c638b">sqrtReal</a> (const double &amp;a)</td></tr>
<tr class="separator:a37022f8ff5b0ea0a0245f4fd7e4c638b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a680ffe9b30c0ebef0aad50a5dbae7929" id="r_a680ffe9b30c0ebef0aad50a5dbae7929"><td class="memItemLeft" align="right" valign="top">xdouble&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a680ffe9b30c0ebef0aad50a5dbae7929">sqrtReal</a> (const xdouble &amp;a)</td></tr>
<tr class="separator:a680ffe9b30c0ebef0aad50a5dbae7929"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d6c03745f5fa960f80c30cc5602ea48" id="r_a7d6c03745f5fa960f80c30cc5602ea48"><td class="memItemLeft" align="right" valign="top">quad_float&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a7d6c03745f5fa960f80c30cc5602ea48">sqrtReal</a> (const quad_float &amp;a)</td></tr>
<tr class="separator:a7d6c03745f5fa960f80c30cc5602ea48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af9165cbd4d3ce3c838d71db53cc6b1c6" id="r_af9165cbd4d3ce3c838d71db53cc6b1c6"><td class="memItemLeft" align="right" valign="top">NTL::RR&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af9165cbd4d3ce3c838d71db53cc6b1c6">sqrtReal</a> (const NTL::RR &amp;a)</td></tr>
<tr class="separator:af9165cbd4d3ce3c838d71db53cc6b1c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a71110e4d0e1c979d7f5da2593e8edddb" id="r_a71110e4d0e1c979d7f5da2593e8edddb"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a71110e4d0e1c979d7f5da2593e8edddb">lFactorial</a> (int64_t t)</td></tr>
<tr class="memdesc:a71110e4d0e1c979d7f5da2593e8edddb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(t!\), the factorial of \(t\).  <br /></td></tr>
<tr class="separator:a71110e4d0e1c979d7f5da2593e8edddb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a886c94b54767104cea58e0f1b6c0d11e" id="r_a886c94b54767104cea58e0f1b6c0d11e"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a886c94b54767104cea58e0f1b6c0d11e">Digamma</a> (double x)</td></tr>
<tr class="memdesc:a886c94b54767104cea58e0f1b6c0d11e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the logarithmic derivative of the Gamma function \(\psi(x) = \Gamma&#39;(x) / \Gamma(x)\).  <br /></td></tr>
<tr class="separator:a886c94b54767104cea58e0f1b6c0d11e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67515c2643b5f7029486e8118ede05d6" id="r_a67515c2643b5f7029486e8118ede05d6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a67515c2643b5f7029486e8118ede05d6">BernoulliPoly</a> (int64_t n, double x)</td></tr>
<tr class="memdesc:a67515c2643b5f7029486e8118ede05d6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\).  <br /></td></tr>
<tr class="separator:a67515c2643b5f7029486e8118ede05d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61a4b5013c295f9f07b9b2d8f26ee5f4" id="r_a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a61a4b5013c295f9f07b9b2d8f26ee5f4">Harmonic</a> (std::int64_t n)</td></tr>
<tr class="memdesc:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the \(n\)-th harmonic number \(H_n  = \sum_{j=1}^n 1/j\).  <br /></td></tr>
<tr class="separator:a61a4b5013c295f9f07b9b2d8f26ee5f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3aefa49a034495dcc46721c275f329b0" id="r_a3aefa49a034495dcc46721c275f329b0"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3aefa49a034495dcc46721c275f329b0">Harmonic2</a> (std::int64_t n)</td></tr>
<tr class="memdesc:a3aefa49a034495dcc46721c275f329b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the sum.  <br /></td></tr>
<tr class="separator:a3aefa49a034495dcc46721c275f329b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb56e7569fb24800973df89d757f2fd" id="r_a0bb56e7569fb24800973df89d757f2fd"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a0bb56e7569fb24800973df89d757f2fd">FourierC1</a> (double x, std::int64_t n)</td></tr>
<tr class="memdesc:a0bb56e7569fb24800973df89d757f2fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series (see <a class="el" href="../../d0/de3/citelist.html#CITEREF_vjoe92b">[5]</a>)  <br /></td></tr>
<tr class="separator:a0bb56e7569fb24800973df89d757f2fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5f708fa0e8d6aa53427b3e8927f5504" id="r_ab5f708fa0e8d6aa53427b3e8927f5504"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ab5f708fa0e8d6aa53427b3e8927f5504">FourierE1</a> (double x, std::int64_t n)</td></tr>
<tr class="memdesc:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes and returns the value of the series.  <br /></td></tr>
<tr class="separator:ab5f708fa0e8d6aa53427b3e8927f5504"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6b0960569f7f194c12022073a0ec7bbe" id="r_a6b0960569f7f194c12022073a0ec7bbe"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a6b0960569f7f194c12022073a0ec7bbe">negativeCholesky</a> ()</td></tr>
<tr class="separator:a6b0960569f7f194c12022073a0ec7bbe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a617ba189e7b633cbc81f08d3512bc3fb" id="r_a617ba189e7b633cbc81f08d3512bc3fb"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename RealVec &gt; </td></tr>
<tr class="memitem:a617ba189e7b633cbc81f08d3512bc3fb"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a617ba189e7b633cbc81f08d3512bc3fb">redLLL</a> (IntMat &amp;basis, double delta=0.99999, long dim=0, RealVec *sqlen=0)</td></tr>
<tr class="memdesc:a617ba189e7b633cbc81f08d3512bc3fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file provides only static functions to reduce a lattice basis in some ways (pairwise, LLL, BKZ <a class="el" href="../../d0/de3/citelist.html#CITEREF_rdie75a">[4]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_mlen82a">[9]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_msch91a">[10]</a>).  <br /></td></tr>
<tr class="separator:a617ba189e7b633cbc81f08d3512bc3fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b34105ff26302078324b66592bbff4c" id="r_a9b34105ff26302078324b66592bbff4c"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a9b34105ff26302078324b66592bbff4c"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9b34105ff26302078324b66592bbff4c">redLLLExact</a> (IntMat &amp;basis, double delta=0.99999)</td></tr>
<tr class="memdesc:a9b34105ff26302078324b66592bbff4c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This static function implements an exact algorithm from <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> to perform the original LLL reduction.  <br /></td></tr>
<tr class="separator:a9b34105ff26302078324b66592bbff4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adde2fbdfda54db87c5b68656822db927" id="r_adde2fbdfda54db87c5b68656822db927"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename RealVec &gt; </td></tr>
<tr class="memitem:adde2fbdfda54db87c5b68656822db927"><td class="memTemplItemLeft" align="right" valign="top">static void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adde2fbdfda54db87c5b68656822db927">redBKZ</a> (IntMat &amp;basis, double delta=0.99999, int64_t blocksize=10, long prune=0, long dim=0, RealVec *sqlen=0)</td></tr>
<tr class="memdesc:adde2fbdfda54db87c5b68656822db927"><td class="mdescLeft">&#160;</td><td class="mdescRight">This calls the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> implementation of the floating point version of the BKZ reduction algorithm presented in <a class="el" href="../../d0/de3/citelist.html#CITEREF_msch91a">[10]</a>, with reduction factor <code>delta</code>, block size <code>blocksize</code>, pruning parameter &lsquo;prune&rsquo;; see <a class="el" href="../../d0/de3/citelist.html#CITEREF_ilec22l">[7]</a>.  <br /></td></tr>
<tr class="separator:adde2fbdfda54db87c5b68656822db927"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63dafe7fe191c17bcb7c178149db6570" id="r_a63dafe7fe191c17bcb7c178149db6570"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename RealVec &gt; </td></tr>
<tr class="memitem:a63dafe7fe191c17bcb7c178149db6570"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a63dafe7fe191c17bcb7c178149db6570">redLLL</a> (IntMat &amp;basis, double delta, long dim, RealVec *sqlen)</td></tr>
<tr class="memdesc:a63dafe7fe191c17bcb7c178149db6570"><td class="mdescLeft">&#160;</td><td class="mdescRight">This file provides only static functions to reduce a lattice basis in some ways (pairwise, LLL, BKZ <a class="el" href="../../d0/de3/citelist.html#CITEREF_rdie75a">[4]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_mlen82a">[9]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_msch91a">[10]</a>).  <br /></td></tr>
<tr class="separator:a63dafe7fe191c17bcb7c178149db6570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a01966aadc118052152357ebbd4877051" id="r_a01966aadc118052152357ebbd4877051"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a01966aadc118052152357ebbd4877051"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a01966aadc118052152357ebbd4877051">redLLL</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; int64_t &gt; &amp;basis, double delta, long dim, <a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; double &gt; *sqlen)</td></tr>
<tr class="separator:a01966aadc118052152357ebbd4877051"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58fa2aa83677cc696e94fb373240313d" id="r_a58fa2aa83677cc696e94fb373240313d"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a58fa2aa83677cc696e94fb373240313d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a58fa2aa83677cc696e94fb373240313d">redLLL</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;basis, double delta, long dim, <a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; double &gt; *sqlen)</td></tr>
<tr class="separator:a58fa2aa83677cc696e94fb373240313d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13ea3c4adefe9d6120ac4da1b8f4f554" id="r_a13ea3c4adefe9d6120ac4da1b8f4f554"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a13ea3c4adefe9d6120ac4da1b8f4f554"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a13ea3c4adefe9d6120ac4da1b8f4f554">redLLL</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;basis, double delta, long dim, <a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; xdouble &gt; *sqlen)</td></tr>
<tr class="separator:a13ea3c4adefe9d6120ac4da1b8f4f554"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afbf047233020d1da050275ed0df223ef" id="r_afbf047233020d1da050275ed0df223ef"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:afbf047233020d1da050275ed0df223ef"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afbf047233020d1da050275ed0df223ef">redLLL</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;basis, double delta, long dim, <a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; quad_float &gt; *sqlen)</td></tr>
<tr class="separator:afbf047233020d1da050275ed0df223ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c9680e665446bbf600179b01a9eaf34" id="r_a7c9680e665446bbf600179b01a9eaf34"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a7c9680e665446bbf600179b01a9eaf34"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a7c9680e665446bbf600179b01a9eaf34">redLLL</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;basis, double delta, long dim, <a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; NTL::RR &gt; *sqlen)</td></tr>
<tr class="separator:a7c9680e665446bbf600179b01a9eaf34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5830bb0fae462b5e85c8eeb1c126a647" id="r_a5830bb0fae462b5e85c8eeb1c126a647"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a5830bb0fae462b5e85c8eeb1c126a647"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a5830bb0fae462b5e85c8eeb1c126a647">redLLLExact</a> (IntMat &amp;basis, double delta)</td></tr>
<tr class="memdesc:a5830bb0fae462b5e85c8eeb1c126a647"><td class="mdescLeft">&#160;</td><td class="mdescRight">This static function implements an exact algorithm from <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> to perform the original LLL reduction.  <br /></td></tr>
<tr class="separator:a5830bb0fae462b5e85c8eeb1c126a647"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9f2a630477cda7b6943b42949cd3123" id="r_ac9f2a630477cda7b6943b42949cd3123"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ac9f2a630477cda7b6943b42949cd3123"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ac9f2a630477cda7b6943b42949cd3123">redLLLExact</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;basis, double delta)</td></tr>
<tr class="separator:ac9f2a630477cda7b6943b42949cd3123"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5b3c8b73699d62e791da7d1bfb848db" id="r_af5b3c8b73699d62e791da7d1bfb848db"><td class="memTemplParams" colspan="2">template&lt;typename IntMat , typename RealVec &gt; </td></tr>
<tr class="memitem:af5b3c8b73699d62e791da7d1bfb848db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af5b3c8b73699d62e791da7d1bfb848db">redBKZ</a> (IntMat &amp;basis, double delta, long blocksize, long prune, long dim, RealVec *sqlen)</td></tr>
<tr class="separator:af5b3c8b73699d62e791da7d1bfb848db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad31a58271ce3e94ccef239d05592ec53" id="r_ad31a58271ce3e94ccef239d05592ec53"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad31a58271ce3e94ccef239d05592ec53"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad31a58271ce3e94ccef239d05592ec53">redBKZ</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; int64_t &gt; &amp;basis, double delta, long blocksize, long prune, long dim, <a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; double &gt; *sqlen)</td></tr>
<tr class="separator:ad31a58271ce3e94ccef239d05592ec53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc25c6590d71b62c3a9d598e6ffa5a4f" id="r_acc25c6590d71b62c3a9d598e6ffa5a4f"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:acc25c6590d71b62c3a9d598e6ffa5a4f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#acc25c6590d71b62c3a9d598e6ffa5a4f">redBKZ</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;basis, double delta, long blocksize, long prune, long dim, <a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; double &gt; *sqlen)</td></tr>
<tr class="separator:acc25c6590d71b62c3a9d598e6ffa5a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af3e2c73995e28bf1faebc73e97e523c4" id="r_af3e2c73995e28bf1faebc73e97e523c4"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:af3e2c73995e28bf1faebc73e97e523c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af3e2c73995e28bf1faebc73e97e523c4">redBKZ</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;basis, double delta, long blocksize, long prune, long dim, <a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; xdouble &gt; *sqlen)</td></tr>
<tr class="separator:af3e2c73995e28bf1faebc73e97e523c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a2070ad3e59569291798e297aee25dc" id="r_a1a2070ad3e59569291798e297aee25dc"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:a1a2070ad3e59569291798e297aee25dc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1a2070ad3e59569291798e297aee25dc">redBKZ</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;basis, double delta, long blocksize, long prune, long dim, <a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; quad_float &gt; *sqlen)</td></tr>
<tr class="separator:a1a2070ad3e59569291798e297aee25dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad62dafef6f1aae18d8d9a5a1846a13f7" id="r_ad62dafef6f1aae18d8d9a5a1846a13f7"><td class="memItemLeft" align="right" valign="top">template&lt;&gt; </td></tr>
<tr class="memitem:ad62dafef6f1aae18d8d9a5a1846a13f7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad62dafef6f1aae18d8d9a5a1846a13f7">redBKZ</a> (<a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;basis, double delta, long blocksize, long prune, long dim, <a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; NTL::RR &gt; *sqlen)</td></tr>
<tr class="separator:ad62dafef6f1aae18d8d9a5a1846a13f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4d16fed8fda92252dc423db28136932" id="r_ad4d16fed8fda92252dc423db28136932"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ad4d16fed8fda92252dc423db28136932"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad4d16fed8fda92252dc423db28136932">swap9</a> (T &amp;x, T &amp;y)</td></tr>
<tr class="memdesc:ad4d16fed8fda92252dc423db28136932"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes references to two variables of a generic type and swaps their content.  <br /></td></tr>
<tr class="separator:ad4d16fed8fda92252dc423db28136932"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aab1b2821c4805119b5eb02b3fe0437eb" id="r_aab1b2821c4805119b5eb02b3fe0437eb"><td class="memTemplParams" colspan="2">template&lt;typename Matr1 , typename Matr2 &gt; </td></tr>
<tr class="memitem:aab1b2821c4805119b5eb02b3fe0437eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aab1b2821c4805119b5eb02b3fe0437eb">copyMatrixToMat</a> (Matr1 &amp;A, Matr2 &amp;B)</td></tr>
<tr class="separator:aab1b2821c4805119b5eb02b3fe0437eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a06b6fca0fb17656efed5391c452afc9b" id="r_a06b6fca0fb17656efed5391c452afc9b"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a06b6fca0fb17656efed5391c452afc9b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a06b6fca0fb17656efed5391c452afc9b">printBase</a> (IntMat bas_mat)</td></tr>
<tr class="separator:a06b6fca0fb17656efed5391c452afc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaee961bb86089ad2cb9df512b1164e2f" id="r_aaee961bb86089ad2cb9df512b1164e2f"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:aaee961bb86089ad2cb9df512b1164e2f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaee961bb86089ad2cb9df512b1164e2f">printBase2</a> (IntMat bas_mat)</td></tr>
<tr class="separator:aaee961bb86089ad2cb9df512b1164e2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab8df54cbab1b05dae27118a586c3d4c4" id="r_ab8df54cbab1b05dae27118a586c3d4c4"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:ab8df54cbab1b05dae27118a586c3d4c4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ab8df54cbab1b05dae27118a586c3d4c4">copy</a> (IntMat &amp;b1, IntMat &amp;b2)</td></tr>
<tr class="separator:ab8df54cbab1b05dae27118a586c3d4c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d1f7ecf7379c91d2d97bc70f20d5e24" id="r_a6d1f7ecf7379c91d2d97bc70f20d5e24"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a6d1f7ecf7379c91d2d97bc70f20d5e24"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6d1f7ecf7379c91d2d97bc70f20d5e24">copy</a> (IntMat &amp;b1, IntMat &amp;b2, int64_t r, int64_t c)</td></tr>
<tr class="separator:a6d1f7ecf7379c91d2d97bc70f20d5e24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1b3637aa8820727e70ae7e915f3cde53" id="r_a1b3637aa8820727e70ae7e915f3cde53"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1b3637aa8820727e70ae7e915f3cde53">getWidth</a> (clock_t time[], int64_t dim, std::string message, clock_t totals[], int64_t ind)</td></tr>
<tr class="separator:a1b3637aa8820727e70ae7e915f3cde53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5a20627ab18ad67cd5e99368048f67" id="r_a3e5a20627ab18ad67cd5e99368048f67"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3e5a20627ab18ad67cd5e99368048f67">Harmonic</a> (long n)</td></tr>
<tr class="separator:a3e5a20627ab18ad67cd5e99368048f67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a55b0c3ebff37253c6a08f8108c1edfc6" id="r_a55b0c3ebff37253c6a08f8108c1edfc6"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a55b0c3ebff37253c6a08f8108c1edfc6">Harmonic2</a> (long n)</td></tr>
<tr class="separator:a55b0c3ebff37253c6a08f8108c1edfc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a791ecbd2ea19e9fd99ee4e5e36465728" id="r_a791ecbd2ea19e9fd99ee4e5e36465728"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a791ecbd2ea19e9fd99ee4e5e36465728">FourierC1</a> (double x, long n)</td></tr>
<tr class="separator:a791ecbd2ea19e9fd99ee4e5e36465728"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aff61b56232b701108ddaff4ac9e908b9" id="r_aff61b56232b701108ddaff4ac9e908b9"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#aff61b56232b701108ddaff4ac9e908b9">FourierE1</a> (double x, long n)</td></tr>
<tr class="separator:aff61b56232b701108ddaff4ac9e908b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a388a455c72dba5b85360b570c74f3b9b" id="r_a388a455c72dba5b85360b570c74f3b9b"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a388a455c72dba5b85360b570c74f3b9b">RandInt</a> (std::int64_t i, std::int64_t j)</td></tr>
<tr class="separator:a388a455c72dba5b85360b570c74f3b9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a285f5ccc4cf92a4b1aea6fec9f91dcc8" id="r_a285f5ccc4cf92a4b1aea6fec9f91dcc8"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a285f5ccc4cf92a4b1aea6fec9f91dcc8">check_next_chars</a> (istream &amp;is, const string &amp;token)</td></tr>
<tr class="memdesc:a285f5ccc4cf92a4b1aea6fec9f91dcc8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to check the next characters from an input stream.  <br /></td></tr>
<tr class="separator:a285f5ccc4cf92a4b1aea6fec9f91dcc8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a345f61add88dc0bbda5acf7455bf514a" id="r_a345f61add88dc0bbda5acf7455bf514a"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a345f61add88dc0bbda5acf7455bf514a">skip_any</a> (istream &amp;is, const string &amp;characters)</td></tr>
<tr class="memdesc:a345f61add88dc0bbda5acf7455bf514a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper function to skip all characters of a given class.  <br /></td></tr>
<tr class="separator:a345f61add88dc0bbda5acf7455bf514a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2088f4b44b7639e26d85979c2d90611b" id="r_a2088f4b44b7639e26d85979c2d90611b"><td class="memItemLeft" align="right" valign="top">istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a2088f4b44b7639e26d85979c2d90611b">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html">WeightsProjectionDependent</a> &amp;weights)</td></tr>
<tr class="separator:a2088f4b44b7639e26d85979c2d90611b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a246df9b0832e4c4fc450c83aa5e171ab" id="r_a246df9b0832e4c4fc450c83aa5e171ab"><td class="memItemLeft" align="right" valign="top">static std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html#a246df9b0832e4c4fc450c83aa5e171ab">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;coords)</td></tr>
<tr class="memdesc:a246df9b0832e4c4fc450c83aa5e171ab"><td class="mdescLeft">&#160;</td><td class="mdescRight">Formats the coordinate set <code>coords</code> and outputs it to <code>os</code>.  <br /></td></tr>
<tr class="separator:a246df9b0832e4c4fc450c83aa5e171ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac71356dcc070f0bc5a4ed43864bd9971" id="r_ac71356dcc070f0bc5a4ed43864bd9971"><td class="memItemLeft" align="right" valign="top">static std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html#ac71356dcc070f0bc5a4ed43864bd9971">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;coords)</td></tr>
<tr class="memdesc:ac71356dcc070f0bc5a4ed43864bd9971"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads a formatted coordinate set from <code>is</code>.  <br /></td></tr>
<tr class="separator:ac71356dcc070f0bc5a4ed43864bd9971"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef6c12eea0f3df2908bb03fb2675add3" id="r_aef6c12eea0f3df2908bb03fb2675add3"><td class="memItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html#aef6c12eea0f3df2908bb03fb2675add3">operator&lt;&lt;</a> (std::ostream &amp;os, const <a class="el" href="../../db/d40/classLatticeTester_1_1Weights.html">Weights</a> &amp;o)</td></tr>
<tr class="memdesc:aef6c12eea0f3df2908bb03fb2675add3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Identifies the type of weights, formats them and outputs them on <code>os</code>.  <br /></td></tr>
<tr class="separator:aef6c12eea0f3df2908bb03fb2675add3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85e872b69d81b7fd8a3abd47aaa29006" id="r_a85e872b69d81b7fd8a3abd47aaa29006"><td class="memItemLeft" align="right" valign="top">std::istream &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html#a85e872b69d81b7fd8a3abd47aaa29006">operator&gt;&gt;</a> (std::istream &amp;is, <a class="el" href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html">WeightsProjectionDependent</a> &amp;weights)</td></tr>
<tr class="memdesc:a85e872b69d81b7fd8a3abd47aaa29006"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reads formatted projection-dependent weights into the object <code>weights</code>.  <br /></td></tr>
<tr class="separator:a85e872b69d81b7fd8a3abd47aaa29006"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Random numbers</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>All the functions of this module use LFSR258 as an underlying source for pseudo-random numbers.</p>
<p>A free (as in freedom) implementation of this generator can be found at <a href="http://simul.iro.umontreal.ca/">http://simul.iro.umontreal.ca/</a> as well as the article presenting it. All the functions generating some sort of random number will advance an integer version of LFSR258 by one state and output a transformation of the state to give a double, an int64_t or bits. </p>
</div></td></tr>
<tr class="memitem:abba336d3a5abb22b8367ddfa37a713e4" id="r_abba336d3a5abb22b8367ddfa37a713e4"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#abba336d3a5abb22b8367ddfa37a713e4">RandU01</a> ()</td></tr>
<tr class="memdesc:abba336d3a5abb22b8367ddfa37a713e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a random number in \([0, 1)\).  <br /></td></tr>
<tr class="separator:abba336d3a5abb22b8367ddfa37a713e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3f7dd0225a074e885d6d54916757fcec" id="r_a3f7dd0225a074e885d6d54916757fcec"><td class="memItemLeft" align="right" valign="top">int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3f7dd0225a074e885d6d54916757fcec">RandInt</a> (int64_t i, int64_t j)</td></tr>
<tr class="memdesc:a3f7dd0225a074e885d6d54916757fcec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Return a uniform pseudo-random integer in \([i, j]\).  <br /></td></tr>
<tr class="separator:a3f7dd0225a074e885d6d54916757fcec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3fdad6592203c9b83f2ef7caf7b8441f" id="r_a3fdad6592203c9b83f2ef7caf7b8441f"><td class="memItemLeft" align="right" valign="top">std::uint64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a3fdad6592203c9b83f2ef7caf7b8441f">RandBits</a> (int64_t s)</td></tr>
<tr class="memdesc:a3fdad6592203c9b83f2ef7caf7b8441f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the first s pseudo-random bits of the underlying RNG in the form of a s-bit integer.  <br /></td></tr>
<tr class="separator:a3fdad6592203c9b83f2ef7caf7b8441f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a68bc6b1e81a03d09ea07fa9efed658" id="r_a1a68bc6b1e81a03d09ea07fa9efed658"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a1a68bc6b1e81a03d09ea07fa9efed658">SetSeed</a> (std::uint64_t seed)</td></tr>
<tr class="memdesc:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the seed of the generator.  <br /></td></tr>
<tr class="separator:a1a68bc6b1e81a03d09ea07fa9efed658"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Mathematical functions</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are complete reimplementation of certain mathematical functions, or wrappers for standard C/C++ functions. </p>
</div></td></tr>
<tr class="memitem:a9abb8da9fdc5fa2c37d44165f8660aaf" id="r_a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a9abb8da9fdc5fa2c37d44165f8660aaf">mysqrt</a> (double x)</td></tr>
<tr class="memdesc:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns \(\sqrt{x}\) for \(x\ge0\), and \(-1\) for \(x &lt; 0\).  <br /></td></tr>
<tr class="separator:a9abb8da9fdc5fa2c37d44165f8660aaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae12db9335c229d7c60e570dab50ef05b" id="r_ae12db9335c229d7c60e570dab50ef05b"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:ae12db9335c229d7c60e570dab50ef05b"><td class="memTemplItemLeft" align="right" valign="top">double&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ae12db9335c229d7c60e570dab50ef05b">Lg</a> (const T &amp;x)</td></tr>
<tr class="memdesc:ae12db9335c229d7c60e570dab50ef05b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logarithm of \(x\) in base 2.  <br /></td></tr>
<tr class="separator:ae12db9335c229d7c60e570dab50ef05b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a12e4b6c931cf0a19642828796b3b3bef" id="r_a12e4b6c931cf0a19642828796b3b3bef"><td class="memItemLeft" align="right" valign="top">double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a12e4b6c931cf0a19642828796b3b3bef">Lg</a> (std::int64_t x)</td></tr>
<tr class="memdesc:a12e4b6c931cf0a19642828796b3b3bef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the logarithm of \(x\) in base 2.  <br /></td></tr>
<tr class="separator:a12e4b6c931cf0a19642828796b3b3bef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67e0668a966fb5fa3e22fc1ffa6d59ed" id="r_a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memTemplParams" colspan="2">template&lt;typename Scal &gt; </td></tr>
<tr class="memitem:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memTemplItemLeft" align="right" valign="top">Scal&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a67e0668a966fb5fa3e22fc1ffa6d59ed">abs</a> (Scal x)</td></tr>
<tr class="memdesc:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the absolute value of \(x\).  <br /></td></tr>
<tr class="separator:a67e0668a966fb5fa3e22fc1ffa6d59ed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59016f13e4470ad17683b1cfeb70153c" id="r_a59016f13e4470ad17683b1cfeb70153c"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a59016f13e4470ad17683b1cfeb70153c"><td class="memTemplItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a59016f13e4470ad17683b1cfeb70153c">sign</a> (const T &amp;x)</td></tr>
<tr class="memdesc:a59016f13e4470ad17683b1cfeb70153c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the sign of <code>x</code>.  <br /></td></tr>
<tr class="separator:a59016f13e4470ad17683b1cfeb70153c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15f15a1453b578cb49b2e3deda5a200d" id="r_a15f15a1453b578cb49b2e3deda5a200d"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a15f15a1453b578cb49b2e3deda5a200d"><td class="memTemplItemLeft" align="right" valign="top">Real&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a15f15a1453b578cb49b2e3deda5a200d">Round</a> (Real x)</td></tr>
<tr class="memdesc:a15f15a1453b578cb49b2e3deda5a200d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of x rounded to the NEAREST integer value.  <br /></td></tr>
<tr class="separator:a15f15a1453b578cb49b2e3deda5a200d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a941ee9c334c67adb02d4d7098fa22553" id="r_a941ee9c334c67adb02d4d7098fa22553"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a941ee9c334c67adb02d4d7098fa22553">Factorial</a> (int64_t t)</td></tr>
<tr class="memdesc:a941ee9c334c67adb02d4d7098fa22553"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates \(t!\), the factorial of \(t\) and returns it as an std::int64_t.  <br /></td></tr>
<tr class="separator:a941ee9c334c67adb02d4d7098fa22553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Division and modular arithmetic</div></td></tr>
<tr><td colspan="2"><div class="groupText"><dl class="section remark"><dt>Remarks</dt><dd><b>Richard:</b> Pour certaines fonctions, les résultats sont mis dans les premiers arguments de la fonction pour être compatible avec <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a>; pour d’autres, ils sont mis dans les derniers arguments pour être compatible avec notre ancienne version de LatMRG en Modula-2. Plutôt détestable. Je crois qu’il faudra un jour réarranger les arguments des fonctions pour qu’elles suivent toutes la même convention que <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a>.</dd></dl>
<p>This module offers function to perform division and find remainders in a standard way. These functions are usefull in the case where one wants to do divisions or find remainders of operations with negative operands. The reason is that <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> and primitive types do not use the same logic when doing calculations on negative numbers.</p>
<p>Basically, <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> will always floor a division and C++ will always truncate a division (which effectively means the floor function is replaced by a roof function if the answer is a negative number). When calculating the remainder of x/y, both apply the same logic but get a different result because they do not do the same division. In both representations, we have that   </p><p class="formulaDsp">
\[
   y\cdot(x/y) + x%y = x.
\]
</p>
<p> It turns out that, with negative values, <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> will return an integer with the same sign as y where C++ will return an integer of opposite sign (but both will return the same number modulo y). </p>
</div></td></tr>
<tr class="memitem:aa9056e4da6e74d83c6061650caf9e59f" id="r_aa9056e4da6e74d83c6061650caf9e59f"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:aa9056e4da6e74d83c6061650caf9e59f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa9056e4da6e74d83c6061650caf9e59f">Quotient</a> (const Int &amp;a, const Int &amp;b, Int &amp;q)</td></tr>
<tr class="memdesc:aa9056e4da6e74d83c6061650caf9e59f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes <code>a/b</code>, truncates the fractionnal part and puts the result in q.  <br /></td></tr>
<tr class="separator:aa9056e4da6e74d83c6061650caf9e59f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33b2ac0aaf5689dbf1f2225dbf14b327" id="r_a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a33b2ac0aaf5689dbf1f2225dbf14b327">Modulo</a> (const Real &amp;a, const Real &amp;b, Real &amp;r)</td></tr>
<tr class="memdesc:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the remainder of a/b and stores its positive equivalent mod b in r.  <br /></td></tr>
<tr class="separator:a33b2ac0aaf5689dbf1f2225dbf14b327"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeccbd231b4002cadbaac0157871f5570" id="r_aeccbd231b4002cadbaac0157871f5570"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:aeccbd231b4002cadbaac0157871f5570"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aeccbd231b4002cadbaac0157871f5570">Divide</a> (Real &amp;q, Real &amp;r, const Real &amp;a, const Real &amp;b)</td></tr>
<tr class="memdesc:aeccbd231b4002cadbaac0157871f5570"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the quotient \(q = a/b\) and remainder  \(r = a
\bmod b\).  <br /></td></tr>
<tr class="separator:aeccbd231b4002cadbaac0157871f5570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a76b74332cd4ded85d51dc6020b930772" id="r_a76b74332cd4ded85d51dc6020b930772"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a76b74332cd4ded85d51dc6020b930772"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a76b74332cd4ded85d51dc6020b930772">DivideRound</a> (const Real &amp;a, const Real &amp;b, Real &amp;q)</td></tr>
<tr class="memdesc:a76b74332cd4ded85d51dc6020b930772"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\).  <br /></td></tr>
<tr class="separator:a76b74332cd4ded85d51dc6020b930772"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a14db19d396c104b730dd5ea23a7752b5" id="r_a14db19d396c104b730dd5ea23a7752b5"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a14db19d396c104b730dd5ea23a7752b5">gcd</a> (std::int64_t a, std::int64_t b)</td></tr>
<tr class="memdesc:a14db19d396c104b730dd5ea23a7752b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the value of the greatest common divisor of \(a\) and \(b\) by using Stein's binary GCD algorithm.  <br /></td></tr>
<tr class="separator:a14db19d396c104b730dd5ea23a7752b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abfe3d98ab5a4c91cac2ef0fa59ec897d" id="r_abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">Euclide</a> (const Int &amp;A, const Int &amp;B, Int &amp;C, Int &amp;D, Int &amp;E, Int &amp;F, Int &amp;G)</td></tr>
<tr class="memdesc:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="mdescLeft">&#160;</td><td class="mdescRight">This method computes the greater common divisor of <code>A</code> and <code>B</code> with Euclid's algorithm.  <br /></td></tr>
<tr class="separator:abfe3d98ab5a4c91cac2ef0fa59ec897d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a734b88021d0f2b51a6c8ab5ca7c1a5aa" id="r_a734b88021d0f2b51a6c8ab5ca7c1a5aa"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a734b88021d0f2b51a6c8ab5ca7c1a5aa"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a734b88021d0f2b51a6c8ab5ca7c1a5aa">Euclide</a> (const Int &amp;A, const Int &amp;B, Int &amp;C, Int &amp;D, Int &amp;G)</td></tr>
<tr class="separator:a734b88021d0f2b51a6c8ab5ca7c1a5aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa2f58453cd5cd239b67d0eb92b3dadf" id="r_aaa2f58453cd5cd239b67d0eb92b3dadf"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:aaa2f58453cd5cd239b67d0eb92b3dadf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa2f58453cd5cd239b67d0eb92b3dadf">TransposeMatrix</a> (IntMat &amp;mat, IntMat &amp;mat2)</td></tr>
<tr class="memdesc:aaa2f58453cd5cd239b67d0eb92b3dadf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a set of generating vectors in the matrix <code>mat</code> and iteratively transforms it into an upper triangular lattice basis into the matrix <code>mat2</code>.  <br /></td></tr>
<tr class="separator:aaa2f58453cd5cd239b67d0eb92b3dadf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Vectors</div></td></tr>
<tr><td colspan="2"><div class="groupText"><p>These are utilities to manipulate vectors ranging from instantiation to scalar product. </p>
</div></td></tr>
<tr class="memitem:a0416b061a693a6e604d4cc99b14a7050" id="r_a0416b061a693a6e604d4cc99b14a7050"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a0416b061a693a6e604d4cc99b14a7050"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0416b061a693a6e604d4cc99b14a7050">CreateVect</a> (Real *&amp;A, int64_t d)</td></tr>
<tr class="memdesc:a0416b061a693a6e604d4cc99b14a7050"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory to <code>A</code> as an array of <code>Real</code> of dimension <code>d</code> and initializes its elements to 0.  <br /></td></tr>
<tr class="separator:a0416b061a693a6e604d4cc99b14a7050"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af40f02397dea42344f2c4b6016f5e4f0" id="r_af40f02397dea42344f2c4b6016f5e4f0"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:af40f02397dea42344f2c4b6016f5e4f0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#af40f02397dea42344f2c4b6016f5e4f0">CreateVect</a> (Vect &amp;A, int64_t d)</td></tr>
<tr class="memdesc:af40f02397dea42344f2c4b6016f5e4f0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates the vector <code>A</code> of dimensions <code>d+1</code> and initializes its elements to 0.  <br /></td></tr>
<tr class="separator:af40f02397dea42344f2c4b6016f5e4f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3290d1c59f58412753021d37fd9059c3" id="r_a3290d1c59f58412753021d37fd9059c3"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a3290d1c59f58412753021d37fd9059c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a3290d1c59f58412753021d37fd9059c3">DeleteVect</a> (Real *&amp;A)</td></tr>
<tr class="memdesc:a3290d1c59f58412753021d37fd9059c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the vector <code>A</code>.  <br /></td></tr>
<tr class="separator:a3290d1c59f58412753021d37fd9059c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74b9ac2e545b1a8e3febffe458488898" id="r_a74b9ac2e545b1a8e3febffe458488898"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a74b9ac2e545b1a8e3febffe458488898"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a74b9ac2e545b1a8e3febffe458488898">DeleteVect</a> (Vect &amp;A)</td></tr>
<tr class="memdesc:a74b9ac2e545b1a8e3febffe458488898"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the vector <code>A</code>, destroying all the elements it contains.  <br /></td></tr>
<tr class="separator:a74b9ac2e545b1a8e3febffe458488898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42f9afe1397f5fba24397a495d995ff" id="r_aa42f9afe1397f5fba24397a495d995ff"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:aa42f9afe1397f5fba24397a495d995ff"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa42f9afe1397f5fba24397a495d995ff">SetZero</a> (Real *A, int64_t d)</td></tr>
<tr class="memdesc:aa42f9afe1397f5fba24397a495d995ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first <code>d</code> of <code>A</code> to 0.  <br /></td></tr>
<tr class="separator:aa42f9afe1397f5fba24397a495d995ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afe6937cb95337e67ec106791e9b528c3" id="r_afe6937cb95337e67ec106791e9b528c3"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:afe6937cb95337e67ec106791e9b528c3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afe6937cb95337e67ec106791e9b528c3">SetZero</a> (Vect &amp;A, int64_t d)</td></tr>
<tr class="memdesc:afe6937cb95337e67ec106791e9b528c3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first <code>d</code> components of <code>A</code> to 0.  <br /></td></tr>
<tr class="separator:afe6937cb95337e67ec106791e9b528c3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a728d56ee563237fe943ebd333fa3f5" id="r_a2a728d56ee563237fe943ebd333fa3f5"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a2a728d56ee563237fe943ebd333fa3f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2a728d56ee563237fe943ebd333fa3f5">SetValue</a> (Real *A, int64_t d, const Real &amp;x)</td></tr>
<tr class="memdesc:a2a728d56ee563237fe943ebd333fa3f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the first <code>d</code> components of <code>A</code> to 0.  <br /></td></tr>
<tr class="separator:a2a728d56ee563237fe943ebd333fa3f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad18ba9347ad4166201654eb4ad5c6972" id="r_ad18ba9347ad4166201654eb4ad5c6972"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:ad18ba9347ad4166201654eb4ad5c6972"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#ad18ba9347ad4166201654eb4ad5c6972">toString</a> (const Vect &amp;A, int64_t c, int64_t d, const char *sep=&quot; &quot;)</td></tr>
<tr class="memdesc:ad18ba9347ad4166201654eb4ad5c6972"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing <code>A[c]</code> to <code>A[d-1]</code> formated as <code>[A[c]sep...sepA[d-1]]</code>.  <br /></td></tr>
<tr class="separator:ad18ba9347ad4166201654eb4ad5c6972"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c697e5d81b902cbb4283a21104ac62b" id="r_a9c697e5d81b902cbb4283a21104ac62b"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a9c697e5d81b902cbb4283a21104ac62b"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9c697e5d81b902cbb4283a21104ac62b">toString</a> (const Vect &amp;A, int64_t d)</td></tr>
<tr class="memdesc:a9c697e5d81b902cbb4283a21104ac62b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string containing the first <code>d</code> components of the vector <code>A</code> as a string.  <br /></td></tr>
<tr class="separator:a9c697e5d81b902cbb4283a21104ac62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa4a7a8260b1240f8f5c75bfd829b2db" id="r_aaa4a7a8260b1240f8f5c75bfd829b2db"><td class="memTemplParams" colspan="2">template&lt;typename Int , typename Vect1 , typename Vect2 , typename Scal &gt; </td></tr>
<tr class="memitem:aaa4a7a8260b1240f8f5c75bfd829b2db"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa4a7a8260b1240f8f5c75bfd829b2db">ProdScal</a> (const Vect1 &amp;A, const Vect2 &amp;B, int64_t n, Scal &amp;D)</td></tr>
<tr class="memdesc:aaa4a7a8260b1240f8f5c75bfd829b2db"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the scalar product of vectors <code>A</code> and <code>B</code> truncated to their <code>n</code> first components, then puts the result in <code>D</code>.  <br /></td></tr>
<tr class="separator:aaa4a7a8260b1240f8f5c75bfd829b2db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72aa6823947400db540862e204399ccc" id="r_a72aa6823947400db540862e204399ccc"><td class="memTemplParams" colspan="2">template&lt;typename IntVec &gt; </td></tr>
<tr class="memitem:a72aa6823947400db540862e204399ccc"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a72aa6823947400db540862e204399ccc">Invert</a> (const IntVec &amp;A, IntVec &amp;B, int64_t n)</td></tr>
<tr class="memdesc:a72aa6823947400db540862e204399ccc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes an input vector <code>A</code> of dimension <code>n+1</code> and fill the vector <code>B</code> with the values <code>[-A[n] -A[n-1] ... -A[1][1]</code>.  <br /></td></tr>
<tr class="separator:a72aa6823947400db540862e204399ccc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ea54fdf78267250c4b56be6f616c625" id="r_a2ea54fdf78267250c4b56be6f616c625"><td class="memTemplParams" colspan="2">template&lt;typename Vect , typename Scal &gt; </td></tr>
<tr class="memitem:a2ea54fdf78267250c4b56be6f616c625"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2ea54fdf78267250c4b56be6f616c625">CalcNorm</a> (const Vect &amp;V, int64_t n, Scal &amp;S, <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a> norm)</td></tr>
<tr class="memdesc:a2ea54fdf78267250c4b56be6f616c625"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the <code>norm</code> norm of vector <code>V</code> trunctated to its <code>n</code> first components, and puts the result in <code>S</code>.  <br /></td></tr>
<tr class="separator:a2ea54fdf78267250c4b56be6f616c625"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa45b3957599dec1d3c32b9dec0d0644c" id="r_aa45b3957599dec1d3c32b9dec0d0644c"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:aa45b3957599dec1d3c32b9dec0d0644c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aa45b3957599dec1d3c32b9dec0d0644c">CopyPartVec</a> (Vect &amp;toVec, const Vect &amp;fromVec, int64_t c)</td></tr>
<tr class="memdesc:aa45b3957599dec1d3c32b9dec0d0644c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the first <code>c</code> components of vector <code>fromVec</code> into vector <code>toVec</code>.  <br /></td></tr>
<tr class="separator:aa45b3957599dec1d3c32b9dec0d0644c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aba7ffaaa36d63e57ab488e8815a77bb7" id="r_aba7ffaaa36d63e57ab488e8815a77bb7"><td class="memTemplParams" colspan="2">template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:aba7ffaaa36d63e57ab488e8815a77bb7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aba7ffaaa36d63e57ab488e8815a77bb7">CopyPartMat</a> (Matr &amp;toMat, const Matr &amp;fromMat, int64_t r, int64_t c)</td></tr>
<tr class="memdesc:aba7ffaaa36d63e57ab488e8815a77bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the first <code>r</code> rows and <code>c</code> columns of matrix <code>fromMat</code> into matrix <code>toMat</code>.  <br /></td></tr>
<tr class="separator:aba7ffaaa36d63e57ab488e8815a77bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a81bbadb519aa05a3a699329d0e08183e" id="r_a81bbadb519aa05a3a699329d0e08183e"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a81bbadb519aa05a3a699329d0e08183e"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a81bbadb519aa05a3a699329d0e08183e">CopyVect</a> (Vect &amp;A, const Vect &amp;B, int64_t n)</td></tr>
<tr class="memdesc:a81bbadb519aa05a3a699329d0e08183e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the first <code>n</code> components of vector <code>B</code> into vector <code>A</code>.  <br /></td></tr>
<tr class="separator:a81bbadb519aa05a3a699329d0e08183e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc9a8b7fb956c99df2713c1767b3f257" id="r_adc9a8b7fb956c99df2713c1767b3f257"><td class="memTemplParams" colspan="2">template&lt;typename Vect1 , typename Vect2 , typename Scal &gt; </td></tr>
<tr class="memitem:adc9a8b7fb956c99df2713c1767b3f257"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adc9a8b7fb956c99df2713c1767b3f257">ModifVect</a> (Vect1 &amp;A, const Vect2 &amp;B, Scal x, int64_t n)</td></tr>
<tr class="memdesc:adc9a8b7fb956c99df2713c1767b3f257"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds the first <code>n</code> components of vector <code>B</code> multiplied by <code>x</code> to first <code>n</code> components of vector <code>A</code>.  <br /></td></tr>
<tr class="separator:adc9a8b7fb956c99df2713c1767b3f257"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80edc77542f933dcde8561a54d59c13b" id="r_a80edc77542f933dcde8561a54d59c13b"><td class="memTemplParams" colspan="2">template&lt;typename Vect &gt; </td></tr>
<tr class="memitem:a80edc77542f933dcde8561a54d59c13b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a80edc77542f933dcde8561a54d59c13b">ChangeSign</a> (Vect &amp;A, int64_t n)</td></tr>
<tr class="memdesc:a80edc77542f933dcde8561a54d59c13b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes the sign (multiplies by -1) the first <code>n</code> components of vector <code>A</code>.  <br /></td></tr>
<tr class="separator:a80edc77542f933dcde8561a54d59c13b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037fd4e351a079af3d672889e89666e0" id="r_a037fd4e351a079af3d672889e89666e0"><td class="memItemLeft" align="right" valign="top">std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#a037fd4e351a079af3d672889e89666e0">GCD2vect</a> (std::vector&lt; std::int64_t &gt; V, int64_t k, int64_t n)</td></tr>
<tr class="memdesc:a037fd4e351a079af3d672889e89666e0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Computes the greatest common divisor of <code>V[k],...,V[n-1]</code>.  <br /></td></tr>
<tr class="separator:a037fd4e351a079af3d672889e89666e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Matrices</div></td></tr>
<tr class="memitem:a1f76eab56c1a9defffae5b8bf629290f" id="r_a1f76eab56c1a9defffae5b8bf629290f"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a1f76eab56c1a9defffae5b8bf629290f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a1f76eab56c1a9defffae5b8bf629290f">CreateMatr</a> (Real **&amp;A, int64_t d)</td></tr>
<tr class="memdesc:a1f76eab56c1a9defffae5b8bf629290f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory to a square matrix <code>A</code> of dimensions \(d \times d\) and initializes its elements to 0.  <br /></td></tr>
<tr class="separator:a1f76eab56c1a9defffae5b8bf629290f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:add086c03b1352ae2ed9413068d5e3f6d" id="r_add086c03b1352ae2ed9413068d5e3f6d"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:add086c03b1352ae2ed9413068d5e3f6d"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#add086c03b1352ae2ed9413068d5e3f6d">CreateMatr</a> (Real **&amp;A, int64_t line, int64_t col)</td></tr>
<tr class="memdesc:add086c03b1352ae2ed9413068d5e3f6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Allocates memory for the matrix <code>A</code> of dimensions  \(\text{line} \times
\text{col}\) and initializes its elements to 0.  <br /></td></tr>
<tr class="separator:add086c03b1352ae2ed9413068d5e3f6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03d33e22aad4f4a29a20c11bb96c7b02" id="r_a03d33e22aad4f4a29a20c11bb96c7b02"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a03d33e22aad4f4a29a20c11bb96c7b02"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a03d33e22aad4f4a29a20c11bb96c7b02">CreateMatr</a> (IntMat &amp;A, int64_t d)</td></tr>
<tr class="memdesc:a03d33e22aad4f4a29a20c11bb96c7b02"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the matrix <code>A</code> to a square matrix of dimensions <code>d*d</code> and re-initializes its elements to 0.  <br /></td></tr>
<tr class="separator:a03d33e22aad4f4a29a20c11bb96c7b02"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afcf8fb861104547f84a5d73c33401fe6" id="r_afcf8fb861104547f84a5d73c33401fe6"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:afcf8fb861104547f84a5d73c33401fe6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#afcf8fb861104547f84a5d73c33401fe6">CreateMatr</a> (IntMat &amp;A, int64_t line, int64_t col)</td></tr>
<tr class="memdesc:afcf8fb861104547f84a5d73c33401fe6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the matrix <code>A</code> to a matrix of dimensions \(line \times col\) and re-initializes its elements to 0.  <br /></td></tr>
<tr class="separator:afcf8fb861104547f84a5d73c33401fe6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b3fbf56b76e1a95c0f935bb0acca3a4" id="r_a2b3fbf56b76e1a95c0f935bb0acca3a4"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:a2b3fbf56b76e1a95c0f935bb0acca3a4"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a2b3fbf56b76e1a95c0f935bb0acca3a4">DeleteMatr</a> (Real **&amp;A, int64_t d)</td></tr>
<tr class="memdesc:a2b3fbf56b76e1a95c0f935bb0acca3a4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the \(d \times d\) matrix <code>A</code>.  <br /></td></tr>
<tr class="separator:a2b3fbf56b76e1a95c0f935bb0acca3a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb7b6d86bbad87845663bfb8e8e00d06" id="r_adb7b6d86bbad87845663bfb8e8e00d06"><td class="memTemplParams" colspan="2">template&lt;typename Real &gt; </td></tr>
<tr class="memitem:adb7b6d86bbad87845663bfb8e8e00d06"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adb7b6d86bbad87845663bfb8e8e00d06">DeleteMatr</a> (Real **&amp;A, int64_t line, int64_t col)</td></tr>
<tr class="memdesc:adb7b6d86bbad87845663bfb8e8e00d06"><td class="mdescLeft">&#160;</td><td class="mdescRight">Frees the memory used by the matrix <code>A</code> of dimension  \(\text{line} \times
\text{col}\).  <br /></td></tr>
<tr class="separator:adb7b6d86bbad87845663bfb8e8e00d06"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f66d14fcb15c8a2e358b9ab5e08b524" id="r_a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memTemplParams" colspan="2">template&lt;typename IntMat &gt; </td></tr>
<tr class="memitem:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0f66d14fcb15c8a2e358b9ab5e08b524">DeleteMatr</a> (IntMat &amp;A)</td></tr>
<tr class="memdesc:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calls the <code>clear()</code> method on <code>A</code>.  <br /></td></tr>
<tr class="separator:a0f66d14fcb15c8a2e358b9ab5e08b524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb6cc508f7a12e043a9d39eab4e99c0" id="r_adfb6cc508f7a12e043a9d39eab4e99c0"><td class="memTemplParams" colspan="2">template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:adfb6cc508f7a12e043a9d39eab4e99c0"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#adfb6cc508f7a12e043a9d39eab4e99c0">CopyMatr</a> (Matr &amp;A, const Matr &amp;B, int64_t n)</td></tr>
<tr class="memdesc:adfb6cc508f7a12e043a9d39eab4e99c0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the \(n \times n\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>.  <br /></td></tr>
<tr class="separator:adfb6cc508f7a12e043a9d39eab4e99c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a620105c7b91ca77c4259bd116d48ed61" id="r_a620105c7b91ca77c4259bd116d48ed61"><td class="memTemplParams" colspan="2">template&lt;typename Matr &gt; </td></tr>
<tr class="memitem:a620105c7b91ca77c4259bd116d48ed61"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a620105c7b91ca77c4259bd116d48ed61">CopyMatr</a> (Matr &amp;A, const Matr &amp;B, int64_t line, int64_t col)</td></tr>
<tr class="memdesc:a620105c7b91ca77c4259bd116d48ed61"><td class="mdescLeft">&#160;</td><td class="mdescRight">Copies the \(\text{line} \times col\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>.  <br /></td></tr>
<tr class="separator:a620105c7b91ca77c4259bd116d48ed61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6c4c9e2b77c4dc22c74401738c15c8b8" id="r_a6c4c9e2b77c4dc22c74401738c15c8b8"><td class="memTemplParams" colspan="2">template&lt;typename MatT &gt; </td></tr>
<tr class="memitem:a6c4c9e2b77c4dc22c74401738c15c8b8"><td class="memTemplItemLeft" align="right" valign="top">std::string&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6c4c9e2b77c4dc22c74401738c15c8b8">toStr</a> (const MatT &amp;mat, int64_t d1, int64_t d2, int64_t prec=2)</td></tr>
<tr class="memdesc:a6c4c9e2b77c4dc22c74401738c15c8b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a string that is a representation of <code>mat</code>.  <br /></td></tr>
<tr class="separator:a6c4c9e2b77c4dc22c74401738c15c8b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6fcf166e4019360356e28b566d4c1220" id="r_a6fcf166e4019360356e28b566d4c1220"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a6fcf166e4019360356e28b566d4c1220"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a6fcf166e4019360356e28b566d4c1220">ProductDiagonal</a> (const <a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; Int &gt; &amp;A, long dim, Int &amp;prod)</td></tr>
<tr class="memdesc:a6fcf166e4019360356e28b566d4c1220"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the product of the diagonal elements of the matrix <code>A</code>, which is assumed to be square <code>dim x dim</code>.  <br /></td></tr>
<tr class="separator:a6fcf166e4019360356e28b566d4c1220"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05684550e5a7aa0b7d625024702a966d" id="r_a05684550e5a7aa0b7d625024702a966d"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:a05684550e5a7aa0b7d625024702a966d"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a05684550e5a7aa0b7d625024702a966d">CheckTriangular</a> (const <a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; Int &gt; &amp;A, long dim, const Int m)</td></tr>
<tr class="memdesc:a05684550e5a7aa0b7d625024702a966d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks that the upper \(\text{dim} \times \text{dim}\) submatrix of <code>A</code> is triangular modulo <code>m</code>.  <br /></td></tr>
<tr class="separator:a05684550e5a7aa0b7d625024702a966d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa7e3c2a768efb43ed2cdc366eedb8e4" id="r_aaa7e3c2a768efb43ed2cdc366eedb8e4"><td class="memTemplParams" colspan="2">template&lt;typename Int &gt; </td></tr>
<tr class="memitem:aaa7e3c2a768efb43ed2cdc366eedb8e4"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#aaa7e3c2a768efb43ed2cdc366eedb8e4">checkInverseModm</a> (const <a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; Int &gt; &amp;A, const <a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; Int &gt; &amp;B, const Int m)</td></tr>
<tr class="memdesc:aaa7e3c2a768efb43ed2cdc366eedb8e4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if A and B are m-dual to each other.  <br /></td></tr>
<tr class="separator:aaa7e3c2a768efb43ed2cdc366eedb8e4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a525c1afc0f42bff5922cdc947aafe142" id="r_a525c1afc0f42bff5922cdc947aafe142"><td class="memTemplParams" colspan="2">template&lt;typename Matr , typename Int &gt; </td></tr>
<tr class="memitem:a525c1afc0f42bff5922cdc947aafe142"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a525c1afc0f42bff5922cdc947aafe142">Triangularization</a> (Matr &amp;W, Matr &amp;V, int64_t lin, int64_t col, const Int &amp;m)</td></tr>
<tr class="memdesc:a525c1afc0f42bff5922cdc947aafe142"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a set of generating vectors in the matrix <code>W</code> and iteratively transforms it into an upper triangular lattice basis into the matrix <code>V</code>.  <br /></td></tr>
<tr class="separator:a525c1afc0f42bff5922cdc947aafe142"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04449fdf436107c5ef230401edf3a200" id="r_a04449fdf436107c5ef230401edf3a200"><td class="memTemplParams" colspan="2">template&lt;typename Matr , typename Int &gt; </td></tr>
<tr class="memitem:a04449fdf436107c5ef230401edf3a200"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a04449fdf436107c5ef230401edf3a200">calcDual</a> (const Matr &amp;A, Matr &amp;B, int64_t d, const Int &amp;m)</td></tr>
<tr class="memdesc:a04449fdf436107c5ef230401edf3a200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Takes a basis <code>A</code> and computes an m-dual lattice basis B.  <br /></td></tr>
<tr class="separator:a04449fdf436107c5ef230401edf3a200"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Debugging functions</div></td></tr>
<tr class="memitem:af79fc7cd4419fe00202f162860573d89" id="r_af79fc7cd4419fe00202f162860573d89"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#af79fc7cd4419fe00202f162860573d89">MyExit</a> (int64_t status, std::string msg)</td></tr>
<tr class="memdesc:af79fc7cd4419fe00202f162860573d89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Special exit function.  <br /></td></tr>
<tr class="separator:af79fc7cd4419fe00202f162860573d89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr><td colspan="2"><div class="groupHeader">Printing functions and operators</div></td></tr>
<tr class="memitem:a9c5c3904af8b547eb32bba8d42b5c3b1" id="r_a9c5c3904af8b547eb32bba8d42b5c3b1"><td class="memTemplParams" colspan="2">template&lt;class K , class T , class C , class A &gt; </td></tr>
<tr class="memitem:a9c5c3904af8b547eb32bba8d42b5c3b1"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a9c5c3904af8b547eb32bba8d42b5c3b1">operator&lt;&lt;</a> (std::ostream &amp;out, const std::map&lt; K, T, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a9c5c3904af8b547eb32bba8d42b5c3b1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for maps.  <br /></td></tr>
<tr class="separator:a9c5c3904af8b547eb32bba8d42b5c3b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00572b373d97cc0227547867bd1cde0d" id="r_a00572b373d97cc0227547867bd1cde0d"><td class="memTemplParams" colspan="2">template&lt;class T1 , class T2 &gt; </td></tr>
<tr class="memitem:a00572b373d97cc0227547867bd1cde0d"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a00572b373d97cc0227547867bd1cde0d">operator&lt;&lt;</a> (std::ostream &amp;out, const std::pair&lt; T1, T2 &gt; &amp;x)</td></tr>
<tr class="memdesc:a00572b373d97cc0227547867bd1cde0d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <br /></td></tr>
<tr class="separator:a00572b373d97cc0227547867bd1cde0d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ddcbc9a5e063f35176f9c48d38f2650" id="r_a0ddcbc9a5e063f35176f9c48d38f2650"><td class="memTemplParams" colspan="2">template&lt;class T , class A &gt; </td></tr>
<tr class="memitem:a0ddcbc9a5e063f35176f9c48d38f2650"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a0ddcbc9a5e063f35176f9c48d38f2650">operator&lt;&lt;</a> (std::ostream &amp;out, const std::vector&lt; T, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a0ddcbc9a5e063f35176f9c48d38f2650"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for vectors.  <br /></td></tr>
<tr class="separator:a0ddcbc9a5e063f35176f9c48d38f2650"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97b28ac9e1e15b5ede018202a73fe664" id="r_a97b28ac9e1e15b5ede018202a73fe664"><td class="memTemplParams" colspan="2">template&lt;class K , class C , class A &gt; </td></tr>
<tr class="memitem:a97b28ac9e1e15b5ede018202a73fe664"><td class="memTemplItemLeft" align="right" valign="top">std::ostream &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="#a97b28ac9e1e15b5ede018202a73fe664">operator&lt;&lt;</a> (std::ostream &amp;out, const std::set&lt; K, C, A &gt; &amp;x)</td></tr>
<tr class="memdesc:a97b28ac9e1e15b5ede018202a73fe664"><td class="mdescLeft">&#160;</td><td class="mdescRight">Streaming operator for sets.  <br /></td></tr>
<tr class="separator:a97b28ac9e1e15b5ede018202a73fe664"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="var-members" name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ac9adbd421a1148216c8eac1b7d96a5b8" id="r_ac9adbd421a1148216c8eac1b7d96a5b8"><td class="memItemLeft" align="right" valign="top">const double&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ac9adbd421a1148216c8eac1b7d96a5b8">MAX_LONG_DOUBLE</a> = 9007199254740992.0</td></tr>
<tr class="memdesc:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum integer that can be represented exactly as a <code>double</code>: \(2^{53}\).  <br /></td></tr>
<tr class="separator:ac9adbd421a1148216c8eac1b7d96a5b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae540464b3215755b9a0ba65ebfba38f8" id="r_ae540464b3215755b9a0ba65ebfba38f8"><td class="memItemLeft" align="right" valign="top">const std::int64_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="#ae540464b3215755b9a0ba65ebfba38f8">TWO_EXP</a> []</td></tr>
<tr class="memdesc:ae540464b3215755b9a0ba65ebfba38f8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Table of powers of 2: <code>TWO_EXP[</code> \(i\)<code>]</code> \(= 2^i\), \(i=0, 1, …, 63\).  <br /></td></tr>
<tr class="separator:ae540464b3215755b9a0ba65ebfba38f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Lattice namespace. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a951f7e7b03767aa0971dde55f9d328ec" name="a951f7e7b03767aa0971dde55f9d328ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a951f7e7b03767aa0971dde55f9d328ec">&#9670;&#160;</a></span>Weight</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef double <a class="el" href="#a951f7e7b03767aa0971dde55f9d328ec">LatticeTester::Weight</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A scalar weight type. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="a0d2f9ab69a9d586b8273cbb29bb105fe" name="a0d2f9ab69a9d586b8273cbb29bb105fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d2f9ab69a9d586b8273cbb29bb105fe">&#9670;&#160;</a></span>CalcType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105fe">LatticeTester::CalcType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates which type of calculation is considered for the \(P_{\alpha}\) test. </p>
<p><a class="anchor" id="REF__Const_CalcType_def"></a>Is this used anywhere? ************</p>
<p><code>PAL</code> is for the \(P_{\alpha}\) test. <br  />
 <code>BAL</code> is for the bound on the \(P_{\alpha}\) test. <br  />
 <code>NORMPAL</code> is for the \(P_{\alpha}\) test <code>PAL</code>, with the result normalized over the <code>BAL</code> bound. <br  />
 <code>SEEKPAL</code> is for the \(P_{\alpha}\) seek, which searches for good values of the multiplier. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a0d2f9ab69a9d586b8273cbb29bb105feae444ad54301419ac37ef878aedb20234" name="a0d2f9ab69a9d586b8273cbb29bb105feae444ad54301419ac37ef878aedb20234"></a>PAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d2f9ab69a9d586b8273cbb29bb105fea18fa93c0ce684acf5f50252d813034f4" name="a0d2f9ab69a9d586b8273cbb29bb105fea18fa93c0ce684acf5f50252d813034f4"></a>NORMPAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d2f9ab69a9d586b8273cbb29bb105fea1eea8810a9a8d0e0721cbab47592d29c" name="a0d2f9ab69a9d586b8273cbb29bb105fea1eea8810a9a8d0e0721cbab47592d29c"></a>BAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a0d2f9ab69a9d586b8273cbb29bb105feae7e8d0e1b5a15810847d798d1fe0b039" name="a0d2f9ab69a9d586b8273cbb29bb105feae7e8d0e1b5a15810847d798d1fe0b039"></a>SEEKPAL&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a2cf3c4f4181718b7adc6f5e4513695a0" name="a2cf3c4f4181718b7adc6f5e4513695a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cf3c4f4181718b7adc6f5e4513695a0">&#9670;&#160;</a></span>CriterionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a2cf3c4f4181718b7adc6f5e4513695a0">LatticeTester::CriterionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merit criteria to measure the quality of generators or lattices. </p>
<p>TO DO: this list is not very clear. Maybe outdated. ****************</p>
<p><code>LENGTH</code>: Only using the length of the shortest vector as a criterion. <code>SPECTRAL</code>: figure of merit \(S_T\) based on the spectral test.<br  />
 <code>BEYER</code>: figure of merit is the Beyer quotient \(Q_T\).<br  />
 <code>PALPHA</code>: figure of merit based on \(P_{\alpha}\).<br  />
 <code>BOUND_JS</code>: figure of merit based on the Joe-Sinescu bound <a class="el" href="../../d0/de3/citelist.html#CITEREF_rsin08a">[11]</a>.<br  />
 ??? </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2cf3c4f4181718b7adc6f5e4513695a0ab6783128c1344cbef4cc8429cc63d0b5" name="a2cf3c4f4181718b7adc6f5e4513695a0ab6783128c1344cbef4cc8429cc63d0b5"></a>LENGTH&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2cf3c4f4181718b7adc6f5e4513695a0a012ebaf6929fea5b0d330cf292d19e3c" name="a2cf3c4f4181718b7adc6f5e4513695a0a012ebaf6929fea5b0d330cf292d19e3c"></a>SPECTRAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2cf3c4f4181718b7adc6f5e4513695a0a91ce17e475c9002db6b12ed2e528d7e8" name="a2cf3c4f4181718b7adc6f5e4513695a0a91ce17e475c9002db6b12ed2e528d7e8"></a>BEYER&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2cf3c4f4181718b7adc6f5e4513695a0a782750d0af36a267ddfd84b32ae7d79c" name="a2cf3c4f4181718b7adc6f5e4513695a0a782750d0af36a267ddfd84b32ae7d79c"></a>PALPHA&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2cf3c4f4181718b7adc6f5e4513695a0aad5231f38003aaa7c1cc16c314d9605e" name="a2cf3c4f4181718b7adc6f5e4513695a0aad5231f38003aaa7c1cc16c314d9605e"></a>BOUND_JS&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a5bf461b8f167cc8c7ebebc8ee6a96ee4" name="a5bf461b8f167cc8c7ebebc8ee6a96ee4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">&#9670;&#160;</a></span>DecompTypeBB</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">LatticeTester::DecompTypeBB</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Two possible ways of obtaining a triangular matrix to compute the bounds in the BB algorithm. </p>
<p><code>CHOLESKY</code>: use a lower-triangular matrix obtained as the Cholesky decomposition of the matrix of scalar products. <code>TRIANGULAR</code>: use a lower-triangular basis </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5bf461b8f167cc8c7ebebc8ee6a96ee4a3266f268976e38e1d5e53fb38ef4de9d" name="a5bf461b8f167cc8c7ebebc8ee6a96ee4a3266f268976e38e1d5e53fb38ef4de9d"></a>CHOLESKY&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5bf461b8f167cc8c7ebebc8ee6a96ee4ab3f7f0887ca0f53844b887588c92cd66" name="a5bf461b8f167cc8c7ebebc8ee6a96ee4ab3f7f0887ca0f53844b887588c92cd66"></a>TRIANGULAR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a5e9e347d07097a1a3c82f1699ff93d58" name="a5e9e347d07097a1a3c82f1699ff93d58"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e9e347d07097a1a3c82f1699ff93d58">&#9670;&#160;</a></span>MeritType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a5e9e347d07097a1a3c82f1699ff93d58">LatticeTester::MeritType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Two different types of figures of merit. </p>
<p><code>MERITM</code>: based on shortest vector. <code>MERITQ</code>: based on Beyer quotient. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a5e9e347d07097a1a3c82f1699ff93d58a094d81300c3a1bd13d96d01e8c53a3ad" name="a5e9e347d07097a1a3c82f1699ff93d58a094d81300c3a1bd13d96d01e8c53a3ad"></a>MERITM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a5e9e347d07097a1a3c82f1699ff93d58ad875e35fbaf2f2e8be530376935b6c6d" name="a5e9e347d07097a1a3c82f1699ff93d58ad875e35fbaf2f2e8be530376935b6c6d"></a>MERITQ&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ab747c1cbb0f5e47fef711b62327a8e90" name="ab747c1cbb0f5e47fef711b62327a8e90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab747c1cbb0f5e47fef711b62327a8e90">&#9670;&#160;</a></span>NormaType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90">LatticeTester::NormaType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different types of normalizations that can be used for shortest-vector lengths. </p>
<p>Corresponds to different ways of approximating the Hermite constants <code>gamma_t</code>.</p>
<p><code>BESTLAT</code>: the value used for \(d_t^*\) corresponds to the best lattice.<br  />
 <code>BESTBOUND</code>: the value used for \(d_t^*\) corresponds to the best bound known to us.<br  />
 <code>LAMINATED</code>: the value used for \(d_t^*\) corresponds to the best <em>laminated</em> lattice.<br  />
 <code>ROGERS</code>: the value for \(d_t^*\) is obtained from <em>Rogers’</em> bound on the density of sphere packing.<br  />
 <code>MINKL1</code>: the value for \(d_t^*\) is obtained from the theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\mathcal{L}}_1\) norm.<br  />
 <code>MINKL2</code>: the value for \(d_t^*\) is obtained from <em>Minkowski’</em> theoretical bounds on the length of the shortest nonzero vector in the lattice using the \({\mathcal{L}}_2\) norm.<br  />
 <code>NONE</code>: no normalization will be used.<br  />
 </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90a6f65388b2929fedcf40d456d30df3551" name="ab747c1cbb0f5e47fef711b62327a8e90a6f65388b2929fedcf40d456d30df3551"></a>BESTLAT&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90af1bfd880a4ddd5ed4fb67c6b69a5f1bf" name="ab747c1cbb0f5e47fef711b62327a8e90af1bfd880a4ddd5ed4fb67c6b69a5f1bf"></a>BESTBOUND&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90ae8842bb9870dacacc65ef1ad46f8fa4b" name="ab747c1cbb0f5e47fef711b62327a8e90ae8842bb9870dacacc65ef1ad46f8fa4b"></a>LAMINATED&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90a81b5bfa5986a0cf0f014837542837641" name="ab747c1cbb0f5e47fef711b62327a8e90a81b5bfa5986a0cf0f014837542837641"></a>ROGERS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90a5e579ba5452180d37e3e048875ba46e5" name="ab747c1cbb0f5e47fef711b62327a8e90a5e579ba5452180d37e3e048875ba46e5"></a>MINKL1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90ae8cc385eecfe5b72009c9e74386b1c96" name="ab747c1cbb0f5e47fef711b62327a8e90ae8cc385eecfe5b72009c9e74386b1c96"></a>MINKL2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ab747c1cbb0f5e47fef711b62327a8e90a5e9d13ae2852670258864320734e0cbf" name="ab747c1cbb0f5e47fef711b62327a8e90a5e9d13ae2852670258864320734e0cbf"></a>NONE&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a9770e4d57aa715e249cd7e700c6f37e4" name="a9770e4d57aa715e249cd7e700c6f37e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9770e4d57aa715e249cd7e700c6f37e4">&#9670;&#160;</a></span>NormType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">LatticeTester::NormType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>The available norm types to measure the length of vectors. </p>
<p>For \(X = (x_1,…,x_t)\):<br  />
 <code>SUPNORM</code> corresponds to \(\Vert X\Vert= \max(|x_1|,…,|x_t|)\).<br  />
 <code>L1NORM</code> corresponds to \(\Vert X\Vert= |x_1|+\cdots+|x_t|\).<br  />
 <code>L2NORM</code> corresponds to \(\Vert X\Vert= (x_1^2+\cdots+x_t^2)^{1/2}\).<br  />
 <code>ZAREMBANORM</code> corresponds to \(\Vert X\Vert= \max(1, |x_1|)\cdots\max(1, |x_t|)\). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9770e4d57aa715e249cd7e700c6f37e4a3e12e2ca7e65c77c86a8afbbf1faed0d" name="a9770e4d57aa715e249cd7e700c6f37e4a3e12e2ca7e65c77c86a8afbbf1faed0d"></a>SUPNORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9770e4d57aa715e249cd7e700c6f37e4a6031a75d242058c5b26d05f510267b41" name="a9770e4d57aa715e249cd7e700c6f37e4a6031a75d242058c5b26d05f510267b41"></a>L1NORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9770e4d57aa715e249cd7e700c6f37e4a2d8982335f008ef95768bd7ec450d86b" name="a9770e4d57aa715e249cd7e700c6f37e4a2d8982335f008ef95768bd7ec450d86b"></a>L2NORM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9770e4d57aa715e249cd7e700c6f37e4a9dd28fa34c8fd3331bd55e85d9b8ff2b" name="a9770e4d57aa715e249cd7e700c6f37e4a9dd28fa34c8fd3331bd55e85d9b8ff2b"></a>ZAREMBANORM&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ad78f099c800f4c648134967a45b91058" name="ad78f099c800f4c648134967a45b91058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad78f099c800f4c648134967a45b91058">&#9670;&#160;</a></span>OutputType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#ad78f099c800f4c648134967a45b91058">LatticeTester::OutputType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Different choices of output formats. </p>
<p><code>TERM</code>: the results will appear only on the terminal screen.<br  />
 <code>RES</code>: the results will be in plain text and sent to a <code>.res</code> file.<br  />
 <code>TEX</code>: the results will be in a LaTeX file with extension <code>.tex</code>.<br  />
 <code>GEN</code>: a list of retained generators will be sent to a file with extension <code>.gen</code>, in a specific format so this list can be read again for further analysis. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ad78f099c800f4c648134967a45b91058a7424f6330dcef06bb69cd6d1f4f9045a" name="ad78f099c800f4c648134967a45b91058a7424f6330dcef06bb69cd6d1f4f9045a"></a>TERM&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad78f099c800f4c648134967a45b91058a0c648307bf3301ea0606de04fcb79715" name="ad78f099c800f4c648134967a45b91058a0c648307bf3301ea0606de04fcb79715"></a>RES&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad78f099c800f4c648134967a45b91058a3143e7b5be2e3d8d6aad062460f51f97" name="ad78f099c800f4c648134967a45b91058a3143e7b5be2e3d8d6aad062460f51f97"></a>TEX&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ad78f099c800f4c648134967a45b91058a0f15b71adaba58b2f5476a93823f1767" name="ad78f099c800f4c648134967a45b91058a0f15b71adaba58b2f5476a93823f1767"></a>GEN&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a94f96ff406f8b56147a2b7fd96209cb2" name="a94f96ff406f8b56147a2b7fd96209cb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94f96ff406f8b56147a2b7fd96209cb2">&#9670;&#160;</a></span>PrecisionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a94f96ff406f8b56147a2b7fd96209cb2">LatticeTester::PrecisionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This can be supersed by the Real type. </p>
<p><a class="el" href="../../d6/df9/classLatticeTester_1_1Types.html" title="Sets standard typedef’s for the types that can be used in LatticeTester.">Types</a> of precision that the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> can use for real numbers: <code>DOUBLE</code> &ndash; double <code>QUADRUPLE</code> &ndash; quad_float (quasi quadruple precision) this is useful when roundoff errors can cause problems <code>XDOUBLE</code> &ndash; xdouble (extended exponent doubles) this is useful when numbers get too big <code>RR</code> &ndash; RR (arbitrary precision floating point). The choice <code>DOUBLE</code> is usually the fastest, but may be prone to roundoff errors and/or overflow. See <code><a href="https://github.com/u-u-h/NTL/blob/master/doc/LLL.txt">https://github.com/u-u-h/NTL/blob/master/doc/LLL.txt</a></code>. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6" name="a94f96ff406f8b56147a2b7fd96209cb2a14b6ff7a5d157ffdfd9ab4d80d7f5ea6"></a>DOUBLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a94f96ff406f8b56147a2b7fd96209cb2a3a2dae8e1fda53e4a5f9744979a818e0" name="a94f96ff406f8b56147a2b7fd96209cb2a3a2dae8e1fda53e4a5f9744979a818e0"></a>QUADRUPLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a94f96ff406f8b56147a2b7fd96209cb2acf1cb9ccf9b182660b0f40feabc2f007" name="a94f96ff406f8b56147a2b7fd96209cb2acf1cb9ccf9b182660b0f40feabc2f007"></a>XDOUBLE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a94f96ff406f8b56147a2b7fd96209cb2aa4d2c16f89d60274b8ed8859a2594ab7" name="a94f96ff406f8b56147a2b7fd96209cb2aa4d2c16f89d60274b8ed8859a2594ab7"></a>RR&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a9b64954fb374b16e1fe991e435501d65" name="a9b64954fb374b16e1fe991e435501d65"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b64954fb374b16e1fe991e435501d65">&#9670;&#160;</a></span>PrimeType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a9b64954fb374b16e1fe991e435501d65">LatticeTester::PrimeType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Indicates whether an integer is prime, probably prime, composite or its status is unknown (or we do not care). </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a9b64954fb374b16e1fe991e435501d65a1a116a76db19a0cf4ad43973fc2c2279" name="a9b64954fb374b16e1fe991e435501d65a1a116a76db19a0cf4ad43973fc2c2279"></a>PRIME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9b64954fb374b16e1fe991e435501d65a4ad8925491567caca357efe9f609bb27" name="a9b64954fb374b16e1fe991e435501d65a4ad8925491567caca357efe9f609bb27"></a>PROB_PRIME&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9b64954fb374b16e1fe991e435501d65aac48dba763e4f64c60ef238bf66f82f8" name="a9b64954fb374b16e1fe991e435501d65aac48dba763e4f64c60ef238bf66f82f8"></a>COMPOSITE&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a9b64954fb374b16e1fe991e435501d65a5a0fef7085559362287f893caa97425e" name="a9b64954fb374b16e1fe991e435501d65a5a0fef7085559362287f893caa97425e"></a>UNKNOWN&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="aad7b917d5ef7e8167bc50aa56109faff" name="aad7b917d5ef7e8167bc50aa56109faff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aad7b917d5ef7e8167bc50aa56109faff">&#9670;&#160;</a></span>ProblemType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#aad7b917d5ef7e8167bc50aa56109faff">LatticeTester::ProblemType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p><a class="el" href="../../d6/df9/classLatticeTester_1_1Types.html" title="Sets standard typedef’s for the types that can be used in LatticeTester.">Types</a> of problems that <a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a> can handle. </p>
<p>Not sure if we still need this. ******* </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="aad7b917d5ef7e8167bc50aa56109faffaa9cfecaf8d5048f10d4016c41ff814d2" name="aad7b917d5ef7e8167bc50aa56109faffaa9cfecaf8d5048f10d4016c41ff814d2"></a>BASIS&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aad7b917d5ef7e8167bc50aa56109faffa6230d8b5b7473284e7ae5ce9c99a879a" name="aad7b917d5ef7e8167bc50aa56109faffa6230d8b5b7473284e7ae5ce9c99a879a"></a>DUAL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aad7b917d5ef7e8167bc50aa56109faffae72b9cc5c1b60f82db4dc146e05102bc" name="aad7b917d5ef7e8167bc50aa56109faffae72b9cc5c1b60f82db4dc146e05102bc"></a>REDUCTION&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aad7b917d5ef7e8167bc50aa56109faffabc152d94a75cc74adfdb22335c8980f9" name="aad7b917d5ef7e8167bc50aa56109faffabc152d94a75cc74adfdb22335c8980f9"></a>SHORTEST&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="aad7b917d5ef7e8167bc50aa56109faffa861d3886c143a0cc3d686de47fb98920" name="aad7b917d5ef7e8167bc50aa56109faffa861d3886c143a0cc3d686de47fb98920"></a>MERIT&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="a1ff6c9ee29ca0bac6c63d2622508aa46" name="a1ff6c9ee29ca0bac6c63d2622508aa46"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ff6c9ee29ca0bac6c63d2622508aa46">&#9670;&#160;</a></span>ProjConstructType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">LatticeTester::ProjConstructType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Two possible ways of computing the basis for a projection. </p>
<p><code>LLLPROJ</code>: uses LLL reduction. <code>UPPERTRIPROJ</code>: use an upper-triangular basis construction. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a1ff6c9ee29ca0bac6c63d2622508aa46a59c23f7e8d888fc3e79108dea9475dbb" name="a1ff6c9ee29ca0bac6c63d2622508aa46a59c23f7e8d888fc3e79108dea9475dbb"></a>LLLPROJ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a1ff6c9ee29ca0bac6c63d2622508aa46abbfbd0f53d264fdd705b4416b8c36d87" name="a1ff6c9ee29ca0bac6c63d2622508aa46abbfbd0f53d264fdd705b4416b8c36d87"></a>UPPERTRIPROJ&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="af2a213e64bd54d3e33a7aff0f80068cb" name="af2a213e64bd54d3e33a7aff0f80068cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2a213e64bd54d3e33a7aff0f80068cb">&#9670;&#160;</a></span>ReductionType</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cb">LatticeTester::ReductionType</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>A list of all the possible lattice reductions implemented in <code><a class="el" href="../../d8/d74/namespaceLatticeTester.html" title="Lattice namespace.">LatticeTester</a></code>. </p>
<p><code>PAIR</code>: Pairwise reductions only. <code>LLL</code>: LLL reduction only. <code>BKZ</code>: block Korkine-Zolotarev reduction only. <code>BB</code>: direct shortest vector search with BB (no pre-red.). <code>PAIRBB</code>: Pairwise reduction followed by BB. <code>LLLBB</code>: LLL followed by BB. <code>BKZBB</code>: BKZ followed by BB. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="af2a213e64bd54d3e33a7aff0f80068cba7212a3bb53b382d1e38c3f8cdf7a47cf" name="af2a213e64bd54d3e33a7aff0f80068cba7212a3bb53b382d1e38c3f8cdf7a47cf"></a>PAIR&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2a213e64bd54d3e33a7aff0f80068cba8d04551154f945a747c129cdabff4af5" name="af2a213e64bd54d3e33a7aff0f80068cba8d04551154f945a747c129cdabff4af5"></a>LLL&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2a213e64bd54d3e33a7aff0f80068cba14aace9298ad3f3297ff86c30b8d34eb" name="af2a213e64bd54d3e33a7aff0f80068cba14aace9298ad3f3297ff86c30b8d34eb"></a>BKZ&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2a213e64bd54d3e33a7aff0f80068cba00217b110040213df758637d15e36795" name="af2a213e64bd54d3e33a7aff0f80068cba00217b110040213df758637d15e36795"></a>BB&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2a213e64bd54d3e33a7aff0f80068cba59eedbabbb28a332f4d36822d74ae6dd" name="af2a213e64bd54d3e33a7aff0f80068cba59eedbabbb28a332f4d36822d74ae6dd"></a>PAIRBB&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2a213e64bd54d3e33a7aff0f80068cba841193f6d276a17aff255f4f59a712d9" name="af2a213e64bd54d3e33a7aff0f80068cba841193f6d276a17aff255f4f59a712d9"></a>LLLBB&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="af2a213e64bd54d3e33a7aff0f80068cba3c1372bd908125ef772819276035b74c" name="af2a213e64bd54d3e33a7aff0f80068cba3c1372bd908125ef772819276035b74c"></a>BKZBB&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a67e0668a966fb5fa3e22fc1ffa6d59ed" name="a67e0668a966fb5fa3e22fc1ffa6d59ed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67e0668a966fb5fa3e22fc1ffa6d59ed">&#9670;&#160;</a></span>abs()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Scal LatticeTester::abs </td>
          <td>(</td>
          <td class="paramtype">Scal</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the absolute value of \(x\). </p>

</div>
</div>
<a id="a67515c2643b5f7029486e8118ede05d6" name="a67515c2643b5f7029486e8118ede05d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67515c2643b5f7029486e8118ede05d6">&#9670;&#160;</a></span>BernoulliPoly()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::BernoulliPoly </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Evaluates the Bernoulli polynomial \(B_n(x)\) of degree \(n\) at \(x\). </p>
<p>The first Bernoulli polynomials are:           </p><p class="formulaDsp">
\begin{align*}
B_0(x) &amp;= 1  \\
B_1(x) &amp;= x - 1/2  \\
B_2(x) &amp;= x^2-x+1/6  \\
B_3(x) &amp;= x^3 - 3x^2/2 + x/2  \\
B_4(x) &amp;= x^4-2x^3+x^2-1/30 \\
B_5(x) &amp;= x^5 - 5x^4/2 + 5x^3/3 - x/6  \\
B_6(x) &amp;= x^6-3x^5+5x^4/2-x^2/2+1/42  \\
B_7(x) &amp;= x^7 - 7x^6/2 +  7x^5/2 - 7x^3/6 + x/6  \\
B_8(x) &amp;= x^8-4x^7+14x^6/3 - 7x^4/3 +2x^2/3-1/30.
\end{align*}
</p>
<p> Only degrees \(n \le 8\) are programmed for now. </p>

</div>
</div>
<a id="a04449fdf436107c5ef230401edf3a200" name="a04449fdf436107c5ef230401edf3a200"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a04449fdf436107c5ef230401edf3a200">&#9670;&#160;</a></span>calcDual()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::calcDual </td>
          <td>(</td>
          <td class="paramtype">const Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a basis <code>A</code> and computes an m-dual lattice basis B. </p>
<p>The matrix B is the m-dual basis of A. Takes an upper triangular basis <code>A</code> and computes an m-dual lattice basis to this matrix. For this algorithm to work, <code>A</code> has to be upper triangular and all the coefficients on the diagonal have to divide <code>m</code>.</p>
<p>For <code>B</code> to be <code>m</code>-dual to <code>A</code>, we have to have that \(AB^t = mI\). It is quite easy to show that, knowing <code>A</code> is upper triangular, <code>B</code> will be a lower triangular matrix with <code>A(i,i)*B(i,i) = m</code> for all <code>i</code> and \( A_i \cdot B_j = 0\) for \(i\neq j\). To get the second condition, we simply have to recursively take for each line </p><p class="formulaDsp">
\[B_{i,j} = -\frac{1}{A_{j,j}}\sum_{k=j+1}^i A_{j,k} B_{i,k}.\]
</p>
 
</div>
</div>
<a id="a2ea54fdf78267250c4b56be6f616c625" name="a2ea54fdf78267250c4b56be6f616c625"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ea54fdf78267250c4b56be6f616c625">&#9670;&#160;</a></span>CalcNorm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect , typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CalcNorm </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal &amp;</td>          <td class="paramname"><span class="paramname"><em>S</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a></td>          <td class="paramname"><span class="paramname"><em>norm</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the <code>norm</code> norm of vector <code>V</code> trunctated to its <code>n</code> first components, and puts the result in <code>S</code>. </p>
<p><code>Scal</code> has to be a floating point type. </p>

</div>
</div>
<a id="a80edc77542f933dcde8561a54d59c13b" name="a80edc77542f933dcde8561a54d59c13b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80edc77542f933dcde8561a54d59c13b">&#9670;&#160;</a></span>ChangeSign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ChangeSign </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Changes the sign (multiplies by -1) the first <code>n</code> components of vector <code>A</code>. </p>

</div>
</div>
<a id="a285f5ccc4cf92a4b1aea6fec9f91dcc8" name="a285f5ccc4cf92a4b1aea6fec9f91dcc8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a285f5ccc4cf92a4b1aea6fec9f91dcc8">&#9670;&#160;</a></span>check_next_chars()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool LatticeTester::check_next_chars </td>
          <td>(</td>
          <td class="paramtype">istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>token</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to check the next characters from an input stream. </p>
<p>Returns <code>true</code> if the next characters in <code>is</code> are <code>token</code>. Upon a match, the characters are removed from <code>is</code>; otherwise, they are left in <code>is</code>. </p>

</div>
</div>
<a id="aaa7e3c2a768efb43ed2cdc366eedb8e4" name="aaa7e3c2a768efb43ed2cdc366eedb8e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa7e3c2a768efb43ed2cdc366eedb8e4">&#9670;&#160;</a></span>checkInverseModm()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LatticeTester::checkInverseModm </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if A and B are m-dual to each other. </p>
<p>They must be square with the same dimensions. Returns <code>true</code> if <code>AB = mI</code>, false otherwise. </p>

</div>
</div>
<a id="a05684550e5a7aa0b7d625024702a966d" name="a05684550e5a7aa0b7d625024702a966d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a05684550e5a7aa0b7d625024702a966d">&#9670;&#160;</a></span>CheckTriangular()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">bool LatticeTester::CheckTriangular </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks that the upper \(\text{dim} \times \text{dim}\) submatrix of <code>A</code> is triangular modulo <code>m</code>. </p>
<p>This will return <code>true</code> if all the elements under the diagonal are equal to zero modulo <code>m</code> and <code>false</code> otherwise. If <code>m</code> is <code>0</code>, this function simply verifies that the matrix is triangular. </p>

</div>
</div>
<a id="ab8df54cbab1b05dae27118a586c3d4c4" name="ab8df54cbab1b05dae27118a586c3d4c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab8df54cbab1b05dae27118a586c3d4c4">&#9670;&#160;</a></span>copy() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::copy </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>b1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>b2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6d1f7ecf7379c91d2d97bc70f20d5e24" name="a6d1f7ecf7379c91d2d97bc70f20d5e24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6d1f7ecf7379c91d2d97bc70f20d5e24">&#9670;&#160;</a></span>copy() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::copy </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>b1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>b2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a620105c7b91ca77c4259bd116d48ed61" name="a620105c7b91ca77c4259bd116d48ed61"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a620105c7b91ca77c4259bd116d48ed61">&#9670;&#160;</a></span>CopyMatr() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyMatr </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the \(\text{line} \times col\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>. </p>
<p>This function does not check for sizes, so <code>A</code> and <code>B</code> both have to be at leat \(line \times col\). </p>

</div>
</div>
<a id="adfb6cc508f7a12e043a9d39eab4e99c0" name="adfb6cc508f7a12e043a9d39eab4e99c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb6cc508f7a12e043a9d39eab4e99c0">&#9670;&#160;</a></span>CopyMatr() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyMatr </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the \(n \times n\) submatrix of the first lines and columns of <code>B</code> into matrix <code>A</code>. </p>
<p>This function does not check for sizes, so <code>A</code> and <code>B</code> both have to be at leat \(n \times n\). </p>

</div>
</div>
<a id="aab1b2821c4805119b5eb02b3fe0437eb" name="aab1b2821c4805119b5eb02b3fe0437eb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aab1b2821c4805119b5eb02b3fe0437eb">&#9670;&#160;</a></span>copyMatrixToMat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr1 , typename Matr2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::copyMatrixToMat </td>
          <td>(</td>
          <td class="paramtype">Matr1 &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr2 &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aba7ffaaa36d63e57ab488e8815a77bb7" name="aba7ffaaa36d63e57ab488e8815a77bb7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aba7ffaaa36d63e57ab488e8815a77bb7">&#9670;&#160;</a></span>CopyPartMat()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyPartMat </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>toMat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>fromMat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the first <code>r</code> rows and <code>c</code> columns of matrix <code>fromMat</code> into matrix <code>toMat</code>. </p>

</div>
</div>
<a id="aa45b3957599dec1d3c32b9dec0d0644c" name="aa45b3957599dec1d3c32b9dec0d0644c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa45b3957599dec1d3c32b9dec0d0644c">&#9670;&#160;</a></span>CopyPartVec()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyPartVec </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>toVec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>fromVec</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>c</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the first <code>c</code> components of vector <code>fromVec</code> into vector <code>toVec</code>. </p>

</div>
</div>
<a id="a81bbadb519aa05a3a699329d0e08183e" name="a81bbadb519aa05a3a699329d0e08183e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81bbadb519aa05a3a699329d0e08183e">&#9670;&#160;</a></span>CopyVect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CopyVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Copies the first <code>n</code> components of vector <code>B</code> into vector <code>A</code>. </p>

</div>
</div>
<a id="a03d33e22aad4f4a29a20c11bb96c7b02" name="a03d33e22aad4f4a29a20c11bb96c7b02"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03d33e22aad4f4a29a20c11bb96c7b02">&#9670;&#160;</a></span>CreateMatr() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the matrix <code>A</code> to a square matrix of dimensions <code>d*d</code> and re-initializes its elements to 0. </p>

</div>
</div>
<a id="afcf8fb861104547f84a5d73c33401fe6" name="afcf8fb861104547f84a5d73c33401fe6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afcf8fb861104547f84a5d73c33401fe6">&#9670;&#160;</a></span>CreateMatr() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Resizes the matrix <code>A</code> to a matrix of dimensions \(line \times col\) and re-initializes its elements to 0. </p>

</div>
</div>
<a id="a1f76eab56c1a9defffae5b8bf629290f" name="a1f76eab56c1a9defffae5b8bf629290f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f76eab56c1a9defffae5b8bf629290f">&#9670;&#160;</a></span>CreateMatr() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory to a square matrix <code>A</code> of dimensions \(d \times d\) and initializes its elements to 0. </p>

</div>
</div>
<a id="add086c03b1352ae2ed9413068d5e3f6d" name="add086c03b1352ae2ed9413068d5e3f6d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#add086c03b1352ae2ed9413068d5e3f6d">&#9670;&#160;</a></span>CreateMatr() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory for the matrix <code>A</code> of dimensions  \(\text{line} \times
\text{col}\) and initializes its elements to 0. </p>

</div>
</div>
<a id="a0416b061a693a6e604d4cc99b14a7050" name="a0416b061a693a6e604d4cc99b14a7050"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0416b061a693a6e604d4cc99b14a7050">&#9670;&#160;</a></span>CreateVect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateVect </td>
          <td>(</td>
          <td class="paramtype">Real *&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Allocates memory to <code>A</code> as an array of <code>Real</code> of dimension <code>d</code> and initializes its elements to 0. </p>
<p><code>Real</code> has to be a numeric type. </p>

</div>
</div>
<a id="af40f02397dea42344f2c4b6016f5e4f0" name="af40f02397dea42344f2c4b6016f5e4f0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af40f02397dea42344f2c4b6016f5e4f0">&#9670;&#160;</a></span>CreateVect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::CreateVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates the vector <code>A</code> of dimensions <code>d+1</code> and initializes its elements to 0. </p>
<p>The type <code>Vect</code> has to have a <code>resize(integer_type)</code> method that sets the size of the instance to the value of the argument. </p>

</div>
</div>
<a id="a0f66d14fcb15c8a2e358b9ab5e08b524" name="a0f66d14fcb15c8a2e358b9ab5e08b524"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0f66d14fcb15c8a2e358b9ab5e08b524">&#9670;&#160;</a></span>DeleteMatr() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calls the <code>clear()</code> method on <code>A</code>. </p>
<p><code>A</code> has to have a <code>clear()</code> method that frees the memory allocated to it. </p>

</div>
</div>
<a id="a2b3fbf56b76e1a95c0f935bb0acca3a4" name="a2b3fbf56b76e1a95c0f935bb0acca3a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2b3fbf56b76e1a95c0f935bb0acca3a4">&#9670;&#160;</a></span>DeleteMatr() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the \(d \times d\) matrix <code>A</code>. </p>
<p>This will not free all the memory allocated to <code>A</code> if <code>A</code> is of greater dimension and it can cause a memory leak. </p>

</div>
</div>
<a id="adb7b6d86bbad87845663bfb8e8e00d06" name="adb7b6d86bbad87845663bfb8e8e00d06"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adb7b6d86bbad87845663bfb8e8e00d06">&#9670;&#160;</a></span>DeleteMatr() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteMatr </td>
          <td>(</td>
          <td class="paramtype">Real **&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>line</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the matrix <code>A</code> of dimension  \(\text{line} \times
\text{col}\). </p>
<p>This will not free all the memory allocated to <code>A</code> if <code>A</code> is of greater dimension and it can cause a memory leak. </p>

</div>
</div>
<a id="a3290d1c59f58412753021d37fd9059c3" name="a3290d1c59f58412753021d37fd9059c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3290d1c59f58412753021d37fd9059c3">&#9670;&#160;</a></span>DeleteVect() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteVect </td>
          <td>(</td>
          <td class="paramtype">Real *&amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the vector <code>A</code>. </p>
<p>This calls <code>delete[]</code> on <code>A</code> so trying to access <code>A</code> after using this is unsafe. </p>

</div>
</div>
<a id="a74b9ac2e545b1a8e3febffe458488898" name="a74b9ac2e545b1a8e3febffe458488898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a74b9ac2e545b1a8e3febffe458488898">&#9670;&#160;</a></span>DeleteVect() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DeleteVect </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Frees the memory used by the vector <code>A</code>, destroying all the elements it contains. </p>
<p><code>Vect</code> type has to have a <code>clear()</code> method that deallocates all the elements in the vector. </p>

</div>
</div>
<a id="a886c94b54767104cea58e0f1b6c0d11e" name="a886c94b54767104cea58e0f1b6c0d11e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a886c94b54767104cea58e0f1b6c0d11e">&#9670;&#160;</a></span>Digamma()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Digamma </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the logarithmic derivative of the Gamma function \(\psi(x) = \Gamma&#39;(x) / \Gamma(x)\). </p>

</div>
</div>
<a id="aeccbd231b4002cadbaac0157871f5570" name="aeccbd231b4002cadbaac0157871f5570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeccbd231b4002cadbaac0157871f5570">&#9670;&#160;</a></span>Divide()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Divide </td>
          <td>(</td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the quotient \(q = a/b\) and remainder  \(r = a
\bmod b\). </p>
<p>Truncates \(q\) to the nearest integer towards 0. One always has \(a = qb + r\) and \(|r| &lt; |b|\). This works with std::int64_t, NTL::ZZ and real numbers.</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td><td class="r bl br">\(r\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(-2\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td><td class="r bl br">\(2\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\) </td><td class="r bl br">\(-2\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="a76b74332cd4ded85d51dc6020b930772" name="a76b74332cd4ded85d51dc6020b930772"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a76b74332cd4ded85d51dc6020b930772">&#9670;&#160;</a></span>DivideRound()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::DivideRound </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes \(a/b\), rounds the result to the nearest integer and returns the result in \(q\). </p>
<p>This works with std::int64_t, NTL::ZZ and real numbers. </p>

</div>
</div>
<a id="abfe3d98ab5a4c91cac2ef0fa59ec897d" name="abfe3d98ab5a4c91cac2ef0fa59ec897d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abfe3d98ab5a4c91cac2ef0fa59ec897d">&#9670;&#160;</a></span>Euclide() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Euclide </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>E</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>F</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This method computes the greater common divisor of <code>A</code> and <code>B</code> with Euclid's algorithm. </p>
<p>This will store this gcd in <code>G</code> and also the linear combination that permits to get <code>G</code> from <code>A</code> and <code>B</code>. This function should work with std::int64_t and NTL::ZZ.</p>
<p>For \(A\) and \(B\) this will assign to \(C\), \(D\), \(E\), \(F\) and \(G\) values such that:    </p><p class="formulaDsp">
\begin{align*}
   C a + D b &amp; = G = \mbox{GCD } (a,b)\\
    E a + F b &amp; = 0.
\end{align*}
</p>
 
</div>
</div>
<a id="a734b88021d0f2b51a6c8ab5ca7c1a5aa" name="a734b88021d0f2b51a6c8ab5ca7c1a5aa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a734b88021d0f2b51a6c8ab5ca7c1a5aa">&#9670;&#160;</a></span>Euclide() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Euclide </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>C</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>D</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>G</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a941ee9c334c67adb02d4d7098fa22553" name="a941ee9c334c67adb02d4d7098fa22553"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a941ee9c334c67adb02d4d7098fa22553">&#9670;&#160;</a></span>Factorial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::Factorial </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \(t!\), the factorial of \(t\) and returns it as an std::int64_t. </p>

</div>
</div>
<a id="a791ecbd2ea19e9fd99ee4e5e36465728" name="a791ecbd2ea19e9fd99ee4e5e36465728"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a791ecbd2ea19e9fd99ee4e5e36465728">&#9670;&#160;</a></span>FourierC1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierC1 </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0bb56e7569fb24800973df89d757f2fd" name="a0bb56e7569fb24800973df89d757f2fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb56e7569fb24800973df89d757f2fd">&#9670;&#160;</a></span>FourierC1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierC1 </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the value of the series (see <a class="el" href="../../d0/de3/citelist.html#CITEREF_vjoe92b">[5]</a>) </p>
<p class="formulaDsp">
\[
S(x, n) = \sum_{j=1}^{n} \frac{\cos(2\pi j x)}{j}.
\]
</p>
<p> Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). </p>

</div>
</div>
<a id="aff61b56232b701108ddaff4ac9e908b9" name="aff61b56232b701108ddaff4ac9e908b9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aff61b56232b701108ddaff4ac9e908b9">&#9670;&#160;</a></span>FourierE1() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierE1 </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ab5f708fa0e8d6aa53427b3e8927f5504" name="ab5f708fa0e8d6aa53427b3e8927f5504"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab5f708fa0e8d6aa53427b3e8927f5504">&#9670;&#160;</a></span>FourierE1() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::FourierE1 </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes and returns the value of the series. </p>
<p class="formulaDsp">
\[
G(x, n) = \sideset{}{&#39;}\sum_{-n/2&lt;h\le n/2}\;  \frac{e^{2\pi i h x}}{|h|},
\]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(h=0\) is excluded from the sum, and assuming that the imaginary part of \(G(x, n)\) vanishes. Restrictions: \(n&gt;0\) and \(0 \le x \le 1\). </p>

</div>
</div>
<a id="a14db19d396c104b730dd5ea23a7752b5" name="a14db19d396c104b730dd5ea23a7752b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a14db19d396c104b730dd5ea23a7752b5">&#9670;&#160;</a></span>gcd()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::gcd </td>
          <td>(</td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>b</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the greatest common divisor of \(a\) and \(b\) by using Stein's binary GCD algorithm. </p>

</div>
</div>
<a id="a037fd4e351a079af3d672889e89666e0" name="a037fd4e351a079af3d672889e89666e0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a037fd4e351a079af3d672889e89666e0">&#9670;&#160;</a></span>GCD2vect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::GCD2vect </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; std::int64_t &gt;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>k</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the greatest common divisor of <code>V[k],...,V[n-1]</code>. </p>

</div>
</div>
<a id="a1b3637aa8820727e70ae7e915f3cde53" name="a1b3637aa8820727e70ae7e915f3cde53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b3637aa8820727e70ae7e915f3cde53">&#9670;&#160;</a></span>getWidth()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">int64_t LatticeTester::getWidth </td>
          <td>(</td>
          <td class="paramtype">clock_t</td>          <td class="paramname"><span class="paramname"><em>time</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>message</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">clock_t</td>          <td class="paramname"><span class="paramname"><em>totals</em></span>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>ind</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a3e5a20627ab18ad67cd5e99368048f67" name="a3e5a20627ab18ad67cd5e99368048f67"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e5a20627ab18ad67cd5e99368048f67">&#9670;&#160;</a></span>Harmonic() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Harmonic </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a61a4b5013c295f9f07b9b2d8f26ee5f4" name="a61a4b5013c295f9f07b9b2d8f26ee5f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a61a4b5013c295f9f07b9b2d8f26ee5f4">&#9670;&#160;</a></span>Harmonic() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Harmonic </td>
          <td>(</td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the \(n\)-th harmonic number \(H_n  = \sum_{j=1}^n 1/j\). </p>

</div>
</div>
<a id="a55b0c3ebff37253c6a08f8108c1edfc6" name="a55b0c3ebff37253c6a08f8108c1edfc6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a55b0c3ebff37253c6a08f8108c1edfc6">&#9670;&#160;</a></span>Harmonic2() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Harmonic2 </td>
          <td>(</td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a3aefa49a034495dcc46721c275f329b0" name="a3aefa49a034495dcc46721c275f329b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3aefa49a034495dcc46721c275f329b0">&#9670;&#160;</a></span>Harmonic2() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Harmonic2 </td>
          <td>(</td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Computes the sum. </p>
<p class="formulaDsp">
\[
\sideset{}{&#39;}\sum_{-n/2&lt;j\le n/2}\; \frac 1{|j|},
\]
</p>
<p> where the symbol \(\sum^\prime\) means that the term with \(j=0\) is excluded from the sum. </p>

</div>
</div>
<a id="a72aa6823947400db540862e204399ccc" name="a72aa6823947400db540862e204399ccc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72aa6823947400db540862e204399ccc">&#9670;&#160;</a></span>Invert()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntVec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Invert </td>
          <td>(</td>
          <td class="paramtype">const IntVec &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntVec &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes an input vector <code>A</code> of dimension <code>n+1</code> and fill the vector <code>B</code> with the values <code>[-A[n] -A[n-1] ... -A[1][1]</code>. </p>
<p><code>B</code> is assumed to be of dimension at least <code>n+1</code>. </p>

</div>
</div>
<a id="a71110e4d0e1c979d7f5da2593e8edddb" name="a71110e4d0e1c979d7f5da2593e8edddb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a71110e4d0e1c979d7f5da2593e8edddb">&#9670;&#160;</a></span>lFactorial()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::lFactorial </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>t</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculates \(t!\), the factorial of \(t\). </p>
<p>Might throw if <code>t</code> is too large or if std::int64_t can't contain the factorial asked for. </p>

</div>
</div>
<a id="ae12db9335c229d7c60e570dab50ef05b" name="ae12db9335c229d7c60e570dab50ef05b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae12db9335c229d7c60e570dab50ef05b">&#9670;&#160;</a></span>Lg() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Lg </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logarithm of \(x\) in base 2. </p>

</div>
</div>
<a id="a12e4b6c931cf0a19642828796b3b3bef" name="a12e4b6c931cf0a19642828796b3b3bef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e4b6c931cf0a19642828796b3b3bef">&#9670;&#160;</a></span>Lg() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::Lg </td>
          <td>(</td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the logarithm of \(x\) in base 2. </p>

</div>
</div>
<a id="a1b7cb50b78290e16a29bd5e4be503a1f" name="a1b7cb50b78290e16a29bd5e4be503a1f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1b7cb50b78290e16a29bd5e4be503a1f">&#9670;&#160;</a></span>LLLBasisConstruction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int , typename RealVec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LatticeTester::LLLBasisConstruction </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealVec *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Similar to <code>LLLConstruction0</code>, except that in case the set of generating vectors do not generate a full-dimensional lattice, it adds the vectors \(m e_i\) to the generating set, so it always returns a square matrix. </p>
<p>The matrix <code>gen</code> is not resized by this function, so it can remain larger than the lattice dimension. </p>

</div>
</div>
<a id="a173df7d0a7848d304c51a0559e851502" name="a173df7d0a7848d304c51a0559e851502"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a173df7d0a7848d304c51a0559e851502">&#9670;&#160;</a></span>LLLBasisConstruction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int , typename RealVec &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::LLLBasisConstruction </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealVec *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Similar to <code>LLLConstruction0</code>, except that in case the set of generating vectors do not generate a full-dimensional lattice, it adds the vectors \(m e_i\) to the generating set, so it always returns a square matrix. </p>
<p>The matrix <code>gen</code> is not resized by this function, so it can remain larger than the lattice dimension. </p>

</div>
</div>
<a id="a5f920d49aa69c0997fcb3d9a57be59fd" name="a5f920d49aa69c0997fcb3d9a57be59fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5f920d49aa69c0997fcb3d9a57be59fd">&#9670;&#160;</a></span>LLLConstruction0() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename RealVec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static long LatticeTester::LLLConstruction0 </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealVec *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This static class offers methods (functions) to construct a basis from a set of generating vectors that are not necessarily independent, to construct a triangular basis, to construct the basis for a projection over a given subset of coordinates, and to obtain the \(m\)-dual of a given basis. </p>
<p>The implementation relies on <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> and uses <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> matrices. When the basis turns out to have fewer rows than columns, some of the methods add implicitly the rescaled unit vectors to the set of generating vectors. In that case, the basis matrix is always square and all the vectors of the form \(m \be_i\) belong to the lattice.</p>
<p><a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> already offers an efficient method to construct an LLL-reduced basis from a set of generating vectors. This is the most effective way of constructing a basis and it is encapsulated in the <code>LLLConstruction0</code> method given below. This method does not assume that the rescaled unit vectors \(m \be_i\) belong to the lattices and it does not even know about \(m\). The method <code>LLLBasisConstruction</code> adds those vectors to the set of generating vectors, so it always returns a square basis.</p>
<p>We also offer an alternative methods that construct a triangular basis from a set of generating vectors. They always add the rescaled unit vectors implicitly to the set. The method <code>lowerTriangularBasis</code> constructs a lower-triangular basis, while <code>upperTriangularBasis</code> constructs an upper-triangular basis.</p>
<p>To compute the \(m\)-dual of a given basis, we have a general (but slow) method implemented in <code>mDualBasis</code>, and a much faster method in <code>mDualUpperTriangular</code> that works only when the basis is upper-triangular.</p>
<p>We also have functions to compute the basis of a projection of a given lattice over a specified set of coordinates. The function <code>projectionConstructionLLL</code> does this by using LLL to construct the basis of the projection, while <code>projectionConstructionUpperTri</code> constructs an upper-triangular basis for the projection. The function <code>projectionConstruction</code> takes the construction method as a parameter.</p>
<p>All functions take as input a <code>IntMat</code> object that contains either a basis or a set of generating vectors. By default, all rows and columns of this matrix object are used. But in most functions, the user can ask to use only a subset of these rows and columns, via the optional parameters <code>r</code> and <code>c</code>. This can permit one to use the same <code>IntMat</code> object for several numbers of dimensions, to avoid doing many object creations or resizing.</p>
<p>All functions in this class are static, so there is no reason to create any <code>BasisConstruction</code> object. We also avoid to create new objects (such as vectors and matrices) inside these functions. These functions can be called thousands or millions of times in a program, and we want the user to be able to re-use the same vectors and matrices over and over again instead of creating new ones.</p>
<p>Note that when one of these functions is used for an <code>IntMat</code> object that store the primal or \(m\)-dual basis inside an <code><a class="el" href="../../d6/dc0/classLatticeTester_1_1IntLattice.html" title="An IntLattice object is an integral lattice, with its basis or its m-dual basis, or both.">IntLattice</a></code> object, only the primal or the \(m\)-dual basis is changed, and therefore the \(m\)-dual relationship will no longer hold after the call. The user must be aware of that. Most of the time, there is no need to reinstate this relationship, because for example if we want to compute a shortest nonzero vector is the \(m\)-dual lattice, then once we have an \(m\)-dual basis we no longer need a primal basis.</p>
<p>The programs <code>BasisManipulationVerbose</code> and <code>BasisManipulation</code> in the examples illustrate how to use these functions and make speed comparisons. This function takes a set of generating vectors of a lattice in matrix <code>gen</code> and finds a lattice basis by applying LLL reduction with the given value of <code>delta</code>, using the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> implementation specified by <code>prec</code>. The basis is returned in the first rows of <code>gen</code>, in a number of rows equal to its rank. See the class <code>EnumTypes</code> and the documentation of LLL in <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> for the meaning and choices for <code>prec</code>. The default value of delta is not very close to 1 because the goal here is just to compute a basis. It can be taken much closer to 1 if we really prefer a highly-reduced basis. The optional parameters <code>r</code> and <code>c</code> indicate the numbers of rows and columns of the matrix <code>gen</code> that are actually used. When they are 0 (the default values), then these numbers are taken to be the dimensions of the matrix <code>gen</code>. When <code>sqlen</code> is not 0, the square lengths of the basis vectors are returned in this array, exactly as in the <code>LLL_FPZZflex.h</code> module. These optional parameters are allowed to take non-default values only when <code>Int==ZZ</code> and <code>precision = DOUBLE</code>. The function returns the dimension (number of rows) of the newly computed basis, which may differ from the number of rows of the <code>gen</code> object. The latter is never resized.</p>
<p>This function <em>does not</em> assume that all vectors \(m e_i\) belong to the lattice, so it may return a basis matrix that has fewer rows than columns! To make sure that these vectors belong to the lattice, we can add them explicitly beforehand to the set of generating vectors, or call the next method. </p>

</div>
</div>
<a id="af33527fba4e1dd098e8175fdf11afd22" name="af33527fba4e1dd098e8175fdf11afd22"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af33527fba4e1dd098e8175fdf11afd22">&#9670;&#160;</a></span>LLLConstruction0() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long LatticeTester::LLLConstruction0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; long &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a53d806c42058b19f3230a0c07b947dd6" name="a53d806c42058b19f3230a0c07b947dd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a53d806c42058b19f3230a0c07b947dd6">&#9670;&#160;</a></span>LLLConstruction0() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long LatticeTester::LLLConstruction0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acd510238da86208faddf5ec94f2b3e53" name="acd510238da86208faddf5ec94f2b3e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acd510238da86208faddf5ec94f2b3e53">&#9670;&#160;</a></span>LLLConstruction0() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long LatticeTester::LLLConstruction0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; NTL::RR &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a2be7cff765f069ec24b7981db80329d2" name="a2be7cff765f069ec24b7981db80329d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2be7cff765f069ec24b7981db80329d2">&#9670;&#160;</a></span>LLLConstruction0() <span class="overload">[5/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long LatticeTester::LLLConstruction0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; quad_float &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a0d0e87ed1324a4d20f9289b472fe7152" name="a0d0e87ed1324a4d20f9289b472fe7152"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d0e87ed1324a4d20f9289b472fe7152">&#9670;&#160;</a></span>LLLConstruction0() <span class="overload">[6/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">long LatticeTester::LLLConstruction0 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; xdouble &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9069b42c071e7adac5f4af470cc8acd5" name="a9069b42c071e7adac5f4af470cc8acd5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9069b42c071e7adac5f4af470cc8acd5">&#9670;&#160;</a></span>lowerTriangularBasis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::lowerTriangularBasis </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a set of generating vectors in the matrix <code>gen</code> and iteratively transforms it into a lower triangular lattice basis into the matrix <code>basis</code>. </p>
<p>This lattice is assumed to contain all the vectors of the form \(m e_j\), so these vectors are added implicitly to the generating set. Apart from that, all the entries of <code>gen</code> given as input are assumed to be reduced modulo the scaling factor <code>m</code> and all the computations are done modulo <code>m</code>. The matrix <code>basis</code> is assumed to be large enough to contain the new basis, whose dimension should be the number of columns taken from <code>gen</code>. After the execution, <code>gen</code> will contain irrelevant information (garbage) and <code>basis</code> will contain an upper triangular basis. The algorithm is explained in the lattice tester guide. Important: <code>gen</code> and <code>basis</code> must be different <code>IntMat</code> objects.</p>
<p>When <code>r</code> and/or <code>c</code> are strictly positive, they specify the numbers of rows and columns of <code>gen</code> that are actually used, as in <code>LLLConstruction0</code>. The matrix <code>gen</code> is never resized. The new basis should be c x c. </p>

</div>
</div>
<a id="acdf5792485dd769979e3d1e3e9da1932" name="acdf5792485dd769979e3d1e3e9da1932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdf5792485dd769979e3d1e3e9da1932">&#9670;&#160;</a></span>lowerTriangularBasis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LatticeTester::lowerTriangularBasis </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes a set of generating vectors in the matrix <code>gen</code> and iteratively transforms it into a lower triangular lattice basis into the matrix <code>basis</code>. </p>
<p>This lattice is assumed to contain all the vectors of the form \(m e_j\), so these vectors are added implicitly to the generating set. Apart from that, all the entries of <code>gen</code> given as input are assumed to be reduced modulo the scaling factor <code>m</code> and all the computations are done modulo <code>m</code>. The matrix <code>basis</code> is assumed to be large enough to contain the new basis, whose dimension should be the number of columns taken from <code>gen</code>. After the execution, <code>gen</code> will contain irrelevant information (garbage) and <code>basis</code> will contain an upper triangular basis. The algorithm is explained in the lattice tester guide. Important: <code>gen</code> and <code>basis</code> must be different <code>IntMat</code> objects.</p>
<p>When <code>r</code> and/or <code>c</code> are strictly positive, they specify the numbers of rows and columns of <code>gen</code> that are actually used, as in <code>LLLConstruction0</code>. The matrix <code>gen</code> is never resized. The new basis should be c x c. </p>

</div>
</div>
<a id="a3846fec78f4c1d9e01cdd3cf3e39402a" name="a3846fec78f4c1d9e01cdd3cf3e39402a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3846fec78f4c1d9e01cdd3cf3e39402a">&#9670;&#160;</a></span>mDualBasis() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LatticeTester::mDualBasis </td>
          <td>(</td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function assumes that <code>basis</code> contains a basis of the primal lattice scaled by the factor <code>m</code>, not necessarily triangular, and it returns in <code>basisDual</code> the m-dual basis. </p>
<p>It uses matrix inversion and is rather slow. It is currently implemented only for <code>Int = ZZ</code> and it also assumes that the dimensions of the two <code>IntMat</code> objects is exactly the same as the dimensions of the lattices. The reason for this is that we use an <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> function that works only under these conditions. </p>

</div>
</div>
<a id="a79552d814332bea466c22b483081c2d5" name="a79552d814332bea466c22b483081c2d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79552d814332bea466c22b483081c2d5">&#9670;&#160;</a></span>mDualBasis() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualBasis </td>
          <td>(</td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function assumes that <code>basis</code> contains a basis of the primal lattice scaled by the factor <code>m</code>, not necessarily triangular, and it returns in <code>basisDual</code> the m-dual basis. </p>
<p>It uses matrix inversion and is rather slow. It is currently implemented only for <code>Int = ZZ</code> and it also assumes that the dimensions of the two <code>IntMat</code> objects is exactly the same as the dimensions of the lattices. The reason for this is that we use an <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> function that works only under these conditions. </p>

</div>
</div>
<a id="a16a8ee34d4c3df1e33dd4da6e2802ff6" name="a16a8ee34d4c3df1e33dd4da6e2802ff6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16a8ee34d4c3df1e33dd4da6e2802ff6">&#9670;&#160;</a></span>mDualBasis() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualBasis </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a6c3c0496c2570e89c7e0cb221911e9ca" name="a6c3c0496c2570e89c7e0cb221911e9ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c3c0496c2570e89c7e0cb221911e9ca">&#9670;&#160;</a></span>mDualUpperTriangular() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualUpperTriangular </td>
          <td>(</td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>For <code>B</code> to be <code>m</code>-dual to <code>A</code>, we have to have that \(AB^t = mI\). </p>
<p>Takes an upper triangular basis matrix <code>basis</code> and computes the m-dual basis <code>basisDual</code>.</p>
<p>Since <code>A</code> is upper triangular, <code>B</code> will be a lower triangular matrix with <code>A(i,i)*B(i,i) = m</code> for all <code>i</code> and \( A_i \cdot B_j = 0\) for \(i\neq j\). To get the second condition, we simply have to recursively take for each line </p><p class="formulaDsp">
\[B_{i,j} = -\frac{1}{A_{j,j}}\sum_{k=j+1}^i A_{j,k} B_{i,k}.\]
</p>
 
</div>
</div>
<a id="a7138efa423d213c77627f9e530e37533" name="a7138efa423d213c77627f9e530e37533"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7138efa423d213c77627f9e530e37533">&#9670;&#160;</a></span>mDualUpperTriangular() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LatticeTester::mDualUpperTriangular </td>
          <td>(</td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes an upper triangular basis matrix <code>basis</code> and computes the m-dual basis <code>basisDual</code>. </p>
<p>The method assumes that each coefficient on the diagonal of <code>basis</code> is nonzero and divides <code>m</code>. That is, the basis matrix must be square and invertible. The algorithm is described in the Lattice Tester guide <a class="el" href="../../d0/de3/citelist.html#CITEREF_ilec22l">[7]</a>. Since the basis is upper triangular, its m-dual will be lower triangular. When <code>dim &gt; 0</code>, it gives the number of rows and columns of the matrix <code>basis</code> that is actually used. Otherwise (by default) the method uses <code>basis.numCols()</code>.</p>
<p>Takes an upper triangular basis matrix <code>basis</code> and computes the m-dual basis <code>basisDual</code>.</p>
<p>Since <code>A</code> is upper triangular, <code>B</code> will be a lower triangular matrix with <code>A(i,i)*B(i,i) = m</code> for all <code>i</code> and \( A_i \cdot B_j = 0\) for \(i\neq j\). To get the second condition, we simply have to recursively take for each line </p><p class="formulaDsp">
\[B_{i,j} = -\frac{1}{A_{j,j}}\sum_{k=j+1}^i A_{j,k} B_{i,k}.\]
</p>
 
</div>
</div>
<a id="a6384cd156f8be50657091b44faa46d44" name="a6384cd156f8be50657091b44faa46d44"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6384cd156f8be50657091b44faa46d44">&#9670;&#160;</a></span>mDualUpperTriangular96() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualUpperTriangular96 </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function does essentially the same thing as <code>mDualUpperTriangular</code>, but the algorithm is slightly different. </p>
<p>It uses the method described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_rcou96a">[3]</a>. </p>

</div>
</div>
<a id="a81445b4f83a91c2b0c25685c17b66d0b" name="a81445b4f83a91c2b0c25685c17b66d0b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a81445b4f83a91c2b0c25685c17b66d0b">&#9670;&#160;</a></span>mDualUpperTriangular96() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LatticeTester::mDualUpperTriangular96 </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function does essentially the same thing as <code>mDualUpperTriangular</code>, but the algorithm is slightly different. </p>
<p>It uses the method described in <a class="el" href="../../d0/de3/citelist.html#CITEREF_rcou96a">[3]</a>. </p>

</div>
</div>
<a id="ad3208c417df961de57aa5dd66a316708" name="ad3208c417df961de57aa5dd66a316708"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad3208c417df961de57aa5dd66a316708">&#9670;&#160;</a></span>mDualUpperTriangular96() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::mDualUpperTriangular96 </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basisDual</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const NTL::ZZ &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adc9a8b7fb956c99df2713c1767b3f257" name="adc9a8b7fb956c99df2713c1767b3f257"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc9a8b7fb956c99df2713c1767b3f257">&#9670;&#160;</a></span>ModifVect()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect1 , typename Vect2 , typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ModifVect </td>
          <td>(</td>
          <td class="paramtype">Vect1 &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect2 &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Adds the first <code>n</code> components of vector <code>B</code> multiplied by <code>x</code> to first <code>n</code> components of vector <code>A</code>. </p>
<p>This will modify <code>A</code>. This does wierd type convertion and might not work well if different types are used. </p>

</div>
</div>
<a id="a33b2ac0aaf5689dbf1f2225dbf14b327" name="a33b2ac0aaf5689dbf1f2225dbf14b327"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33b2ac0aaf5689dbf1f2225dbf14b327">&#9670;&#160;</a></span>Modulo()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Modulo </td>
          <td>(</td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Real &amp;</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the remainder of a/b and stores its positive equivalent mod b in r. </p>
<p>This works with std::int64_t, NTL::ZZ and real numbers. </p>

</div>
</div>
<a id="af79fc7cd4419fe00202f162860573d89" name="af79fc7cd4419fe00202f162860573d89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af79fc7cd4419fe00202f162860573d89">&#9670;&#160;</a></span>MyExit()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::MyExit </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>status</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::string</td>          <td class="paramname"><span class="paramname"><em>msg</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Special exit function. </p>
<p><code>status</code> is the status code to return to the system, <code>msg</code> is the message to print upon exit. </p>

</div>
</div>
<a id="a9abb8da9fdc5fa2c37d44165f8660aaf" name="a9abb8da9fdc5fa2c37d44165f8660aaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9abb8da9fdc5fa2c37d44165f8660aaf">&#9670;&#160;</a></span>mysqrt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::mysqrt </td>
          <td>(</td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns \(\sqrt{x}\) for \(x\ge0\), and \(-1\) for \(x &lt; 0\). </p>

</div>
</div>
<a id="a6b0960569f7f194c12022073a0ec7bbe" name="a6b0960569f7f194c12022073a0ec7bbe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b0960569f7f194c12022073a0ec7bbe">&#9670;&#160;</a></span>negativeCholesky()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::negativeCholesky </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a9c5c3904af8b547eb32bba8d42b5c3b1" name="a9c5c3904af8b547eb32bba8d42b5c3b1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c5c3904af8b547eb32bba8d42b5c3b1">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[1/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class T , class C , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::map&lt; K, T, C, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for maps. </p>
<p>Formats a map as: <code>{ key1=&gt;val1, ..., keyN=&gt;valN }</code>. </p>

</div>
</div>
<a id="a00572b373d97cc0227547867bd1cde0d" name="a00572b373d97cc0227547867bd1cde0d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00572b373d97cc0227547867bd1cde0d">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[2/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T1 , class T2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::pair&lt; T1, T2 &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a pair as: <code>(first,second)</code>. </p>

</div>
</div>
<a id="a97b28ac9e1e15b5ede018202a73fe664" name="a97b28ac9e1e15b5ede018202a73fe664"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a97b28ac9e1e15b5ede018202a73fe664">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[3/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class K , class C , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::set&lt; K, C, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for sets. </p>
<p>Formats a set as: <code>{ val1, ..., valN }</code>. </p>

</div>
</div>
<a id="a0ddcbc9a5e063f35176f9c48d38f2650" name="a0ddcbc9a5e063f35176f9c48d38f2650"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0ddcbc9a5e063f35176f9c48d38f2650">&#9670;&#160;</a></span>operator&lt;&lt;() <span class="overload">[4/6]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T , class A &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::ostream &amp; LatticeTester::operator&lt;&lt; </td>
          <td>(</td>
          <td class="paramtype">std::ostream &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::vector&lt; T, A &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Streaming operator for vectors. </p>
<p>Formats a vector as: <code>[ val1, ..., valN ]</code>. </p>

</div>
</div>
<a id="a2088f4b44b7639e26d85979c2d90611b" name="a2088f4b44b7639e26d85979c2d90611b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2088f4b44b7639e26d85979c2d90611b">&#9670;&#160;</a></span>operator&gt;&gt;() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">istream &amp; LatticeTester::operator&gt;&gt; </td>
          <td>(</td>
          <td class="paramtype">std::istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d2/d23/classLatticeTester_1_1WeightsProjectionDependent.html">WeightsProjectionDependent</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>weights</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">related</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a06b6fca0fb17656efed5391c452afc9b" name="a06b6fca0fb17656efed5391c452afc9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a06b6fca0fb17656efed5391c452afc9b">&#9670;&#160;</a></span>printBase()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::printBase </td>
          <td>(</td>
          <td class="paramtype">IntMat</td>          <td class="paramname"><span class="paramname"><em>bas_mat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaee961bb86089ad2cb9df512b1164e2f" name="aaee961bb86089ad2cb9df512b1164e2f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaee961bb86089ad2cb9df512b1164e2f">&#9670;&#160;</a></span>printBase2()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::printBase2 </td>
          <td>(</td>
          <td class="paramtype">IntMat</td>          <td class="paramname"><span class="paramname"><em>bas_mat</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa4a7a8260b1240f8f5c75bfd829b2db" name="aaa4a7a8260b1240f8f5c75bfd829b2db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa4a7a8260b1240f8f5c75bfd829b2db">&#9670;&#160;</a></span>ProdScal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int , typename Vect1 , typename Vect2 , typename Scal &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ProdScal </td>
          <td>(</td>
          <td class="paramtype">const Vect1 &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Vect2 &amp;</td>          <td class="paramname"><span class="paramname"><em>B</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>n</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Scal &amp;</td>          <td class="paramname"><span class="paramname"><em>D</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes the scalar product of vectors <code>A</code> and <code>B</code> truncated to their <code>n</code> first components, then puts the result in <code>D</code>. </p>
<p>There is a lot to consider when passing types to this function. The best is for <code>Vect1</code> to be the same type as <code>Vect2</code> and for <code>Scal</code> to be the same as <code>Int</code>, and that those types are the ones stored in <code>Vect1</code> and <code>Vect2</code>.</p>
<p><b>WARNING</b>: This uses so many types without check about them and also assumes all those types can be converted to each other without problem. This is used in many places to compute a floating point norm of vectors with integers values. Take care when using this function. </p>

</div>
</div>
<a id="a6fcf166e4019360356e28b566d4c1220" name="a6fcf166e4019360356e28b566d4c1220"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6fcf166e4019360356e28b566d4c1220">&#9670;&#160;</a></span>ProductDiagonal()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::ProductDiagonal </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; Int &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>prod</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the product of the diagonal elements of the matrix <code>A</code>, which is assumed to be square <code>dim x dim</code>. </p>

</div>
</div>
<a id="aaa206b52fdf65b6d25af973775599068" name="aaa206b52fdf65b6d25af973775599068"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa206b52fdf65b6d25af973775599068">&#9670;&#160;</a></span>projectionConstruction() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectionConstruction </td>
          <td>(</td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a></td>          <td class="paramname"><span class="paramname"><em>projType</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46a59c23f7e8d888fc3e79108dea9475dbb">LLLPROJ</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>In this version, the construction method is passed as a parameter. </p>
<p>The default is LLL. In the triangular case, a temporary matrix is created internally. </p>

</div>
</div>
<a id="a3b0c2d123e1f561094f709a17763334d" name="a3b0c2d123e1f561094f709a17763334d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b0c2d123e1f561094f709a17763334d">&#9670;&#160;</a></span>projectionConstruction() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LatticeTester::projectionConstruction </td>
          <td>(</td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a></td>          <td class="paramname"><span class="paramname"><em>projType</em></span><span class="paramdefsep"> = </span><span class="paramdefval"><a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46a59c23f7e8d888fc3e79108dea9475dbb">LLLPROJ</a></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>In this version, the construction method is passed as a parameter. </p>
<p>The default is LLL. In the triangular case, a temporary matrix is created internally. </p>

</div>
</div>
<a id="a79a0e1eada5eb4f7ff364e8fd88790f1" name="a79a0e1eada5eb4f7ff364e8fd88790f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a79a0e1eada5eb4f7ff364e8fd88790f1">&#9670;&#160;</a></span>projectionConstructionLLL() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int , typename RealVec &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectionConstructionLLL </td>
          <td>(</td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealVec *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Constructs a basis for the projection <code>proj</code> of the lattice with basis <code>inBasis</code>, using <code>LLLBasisConstruction</code>, and returns it in <code>projBasis</code>. </p>
<p>This returned basis is not triangular in general. Its dimension will be the number of coordinates in <code>proj</code>. The matrix <code>projBasis</code> must have enough columns to hold it and at least as many rows as the number of rows that we use from <code>inBasis</code>. When <code>r &gt; 0</code>, only the first <code>r</code> rows of the matrix <code>inBasis</code> are used, otherwise we use all rows of that matrix. This <code>r</code> should normally be the true dimension <code>dim</code> of that basis, which is often smaller than the size <code>maxDim</code> of the <code>IntMat</code> object that contains the basis. The square Euclidean lengths of the basis vectors are returned in the array <code>sqlen</code> when the latter is given. </p>

</div>
</div>
<a id="a8b44e3431a9398fee293afdb50a9eac0" name="a8b44e3431a9398fee293afdb50a9eac0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b44e3431a9398fee293afdb50a9eac0">&#9670;&#160;</a></span>projectionConstructionLLL() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int , typename RealVec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LatticeTester::projectionConstructionLLL </td>
          <td>(</td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.9</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealVec *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Constructs a basis for the projection <code>proj</code> of the lattice with basis <code>inBasis</code>, using <code>LLLBasisConstruction</code>, and returns it in <code>projBasis</code>. </p>
<p>This returned basis is not triangular in general. Its dimension will be the number of coordinates in <code>proj</code>. The matrix <code>projBasis</code> must have enough columns to hold it and at least as many rows as the number of rows that we use from <code>inBasis</code>. When <code>r &gt; 0</code>, only the first <code>r</code> rows of the matrix <code>inBasis</code> are used, otherwise we use all rows of that matrix. This <code>r</code> should normally be the true dimension <code>dim</code> of that basis, which is often smaller than the size <code>maxDim</code> of the <code>IntMat</code> object that contains the basis. The square Euclidean lengths of the basis vectors are returned in the array <code>sqlen</code> when the latter is given. </p>

</div>
</div>
<a id="a59b6e968f63dea501d66be8757df2df9" name="a59b6e968f63dea501d66be8757df2df9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59b6e968f63dea501d66be8757df2df9">&#9670;&#160;</a></span>projectionConstructionUpperTri() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectionConstructionUpperTri </td>
          <td>(</td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a4905b16a640714661b755092217cad8d" name="a4905b16a640714661b755092217cad8d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4905b16a640714661b755092217cad8d">&#9670;&#160;</a></span>projectionConstructionUpperTri() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LatticeTester::projectionConstructionUpperTri </td>
          <td>(</td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aebd32af27ce2a029c3c4ad7ffcae9b62" name="aebd32af27ce2a029c3c4ad7ffcae9b62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aebd32af27ce2a029c3c4ad7ffcae9b62">&#9670;&#160;</a></span>projectionConstructionUpperTri() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectionConstructionUpperTri </td>
          <td>(</td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>genTemp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code>projectionConstructionLLL</code>, but the construction is made using <code>upperTriangularBasis</code>, so the returned basis is upper triangular. </p>
<p>When <code>r &gt; 0</code>, only the first <code>r</code> rows of the matrix <code>inBasis</code> are actually used, otherwise we use all rows of that matrix. In the first version, we pass a matrix <code>genTemp</code> that will be used to store the generating vectors of the projection before making the triangularization. The two matrices <code>projBasis</code> and <code>genTemp</code> must have enough columns to hold the projection and at least as many rows as the number of rows that we use from <code>inBasis</code>. We pass <code>genTemp</code> as a parameter to avoid the internal creation of a new matrix each time, in case we call this method several times. Its contents will be modified. In the second version, this matrix is not passed and a temporary one is created internally, which may add a bit of overhead. </p>

</div>
</div>
<a id="ac555f6bc3b0697b2e1d01ca0e0f71266" name="ac555f6bc3b0697b2e1d01ca0e0f71266"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac555f6bc3b0697b2e1d01ca0e0f71266">&#9670;&#160;</a></span>projectionConstructionUpperTri() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LatticeTester::projectionConstructionUpperTri </td>
          <td>(</td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>inBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>projBasis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>genTemp</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <code>projectionConstructionLLL</code>, but the construction is made using <code>upperTriangularBasis</code>, so the returned basis is upper triangular. </p>
<p>When <code>r &gt; 0</code>, only the first <code>r</code> rows of the matrix <code>inBasis</code> are actually used, otherwise we use all rows of that matrix. In the first version, we pass a matrix <code>genTemp</code> that will be used to store the generating vectors of the projection before making the triangularization. The two matrices <code>projBasis</code> and <code>genTemp</code> must have enough columns to hold the projection and at least as many rows as the number of rows that we use from <code>inBasis</code>. We pass <code>genTemp</code> as a parameter to avoid the internal creation of a new matrix each time, in case we call this method several times. Its contents will be modified. In the second version, this matrix is not passed and a temporary one is created internally, which may add a bit of overhead. </p>

</div>
</div>
<a id="a46d57a1843afbeadd14a364a1b63fcaf" name="a46d57a1843afbeadd14a364a1b63fcaf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46d57a1843afbeadd14a364a1b63fcaf">&#9670;&#160;</a></span>projectMatrix() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::projectMatrix </td>
          <td>(</td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This function overwrites the first <code>r</code> rows of matrix 'out' by a matrix formed by the first <code>r</code> rows of the c columns of matrix <code>in</code> that are specified by <code>proj</code>, where &lsquo;c = size(proj)&rsquo; is the cardinality of the projection <code>proj</code>. </p>
<p>Only the first c columns of the first <code>r</code> rows are overwritten; the other entries are left unchanged. If <code>r = 0</code>, then all the rows of matrix <code>in</code> are taken. When <code>in</code> is a basis, <code>r</code> will usually be the dimension of that basis and <code>c</code> will be smaller. The dimensions of the matrices <code>in</code> and <code>out</code> are always left unchanged. The dimensions of <code>out</code> are assumed to be large enough. After the call, the matrix <code>out</code> will then contain a set of generating vectors for the projection <code>proj</code>. The matrices <code>in</code> and <code>out</code> must be different IntMat objects, otherwise the program halts with an error message. </p>

</div>
</div>
<a id="a6e3a4b511029d1a02eadee427a2552bc" name="a6e3a4b511029d1a02eadee427a2552bc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e3a4b511029d1a02eadee427a2552bc">&#9670;&#160;</a></span>projectMatrix() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LatticeTester::projectMatrix </td>
          <td>(</td>
          <td class="paramtype">const IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>in</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>out</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="../../d9/dd3/classLatticeTester_1_1Coordinates.html">Coordinates</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>proj</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This function overwrites the first <code>r</code> rows of matrix 'out' by a matrix formed by the first <code>r</code> rows of the c columns of matrix <code>in</code> that are specified by <code>proj</code>, where &lsquo;c = size(proj)&rsquo; is the cardinality of the projection <code>proj</code>. </p>
<p>Only the first c columns of the first <code>r</code> rows are overwritten; the other entries are left unchanged. If <code>r = 0</code>, then all the rows of matrix <code>in</code> are taken. When <code>in</code> is a basis, <code>r</code> will usually be the dimension of that basis and <code>c</code> will be smaller. The dimensions of the matrices <code>in</code> and <code>out</code> are always left unchanged. The dimensions of <code>out</code> are assumed to be large enough. After the call, the matrix <code>out</code> will then contain a set of generating vectors for the projection <code>proj</code>. The matrices <code>in</code> and <code>out</code> must be different IntMat objects, otherwise the program halts with an error message. </p>

</div>
</div>
<a id="aa9056e4da6e74d83c6061650caf9e59f" name="aa9056e4da6e74d83c6061650caf9e59f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9056e4da6e74d83c6061650caf9e59f">&#9670;&#160;</a></span>Quotient()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Quotient </td>
          <td>(</td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>b</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Int &amp;</td>          <td class="paramname"><span class="paramname"><em>q</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Computes <code>a/b</code>, truncates the fractionnal part and puts the result in q. </p>
<p>This function is overloaded to work as specified on NTL::ZZ integers. Example:</p>
<center></center><center><table class="LatSoft-table LatSoft-has-hlines">
<tr class="bt">
<td class="r bl br">\(a\) </td><td class="r bl br">\(b\) </td><td class="r bl br">\(q\) </td></tr>
<tr class="bt">
<td class="r bl br">\(5\) </td><td class="r bl br">3 </td><td class="r bl br">1 </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(-1\) </td></tr>
<tr>
<td class="r bl br">\(-5\) </td><td class="r bl br">\(-3\) </td><td class="r bl br">\(1\)  </td></tr>
</table>
</center><center></center> 
</div>
</div>
<a id="a3fdad6592203c9b83f2ef7caf7b8441f" name="a3fdad6592203c9b83f2ef7caf7b8441f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3fdad6592203c9b83f2ef7caf7b8441f">&#9670;&#160;</a></span>RandBits()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::uint64_t LatticeTester::RandBits </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>s</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the first s pseudo-random bits of the underlying RNG in the form of a s-bit integer. </p>
<p>It is imperative that \(1 \leq s \leq 64\) because the RNG is 64 bits wide. </p>

</div>
</div>
<a id="a3f7dd0225a074e885d6d54916757fcec" name="a3f7dd0225a074e885d6d54916757fcec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f7dd0225a074e885d6d54916757fcec">&#9670;&#160;</a></span>RandInt() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int64_t LatticeTester::RandInt </td>
          <td>(</td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Return a uniform pseudo-random integer in \([i, j]\). </p>
<p>Note that the numbers \(i\) and \(j\) are part of the possible output. It is important that \(i &lt; j\) because the underlying arithmetic uses unsigned integers to store j-i+1 and that will be undefined behavior. </p>

</div>
</div>
<a id="a388a455c72dba5b85360b570c74f3b9b" name="a388a455c72dba5b85360b570c74f3b9b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a388a455c72dba5b85360b570c74f3b9b">&#9670;&#160;</a></span>RandInt() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::RandInt </td>
          <td>(</td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>i</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::int64_t</td>          <td class="paramname"><span class="paramname"><em>j</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="abba336d3a5abb22b8367ddfa37a713e4" name="abba336d3a5abb22b8367ddfa37a713e4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abba336d3a5abb22b8367ddfa37a713e4">&#9670;&#160;</a></span>RandU01()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::RandU01 </td>
          <td>(</td>
          <td class="paramname"><span class="paramname"><em></em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a random number in \([0, 1)\). </p>
<p>The number will have 53 pseudo-random bits. </p>

</div>
</div>
<a id="af5b3c8b73699d62e791da7d1bfb848db" name="af5b3c8b73699d62e791da7d1bfb848db"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5b3c8b73699d62e791da7d1bfb848db">&#9670;&#160;</a></span>redBKZ() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename RealVec &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redBKZ </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>blocksize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>prune</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealVec *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="adde2fbdfda54db87c5b68656822db927" name="adde2fbdfda54db87c5b68656822db927"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adde2fbdfda54db87c5b68656822db927">&#9670;&#160;</a></span>redBKZ() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename RealVec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LatticeTester::redBKZ </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.99999</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>blocksize</em></span><span class="paramdefsep"> = </span><span class="paramdefval">10</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>prune</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealVec *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This calls the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> implementation of the floating point version of the BKZ reduction algorithm presented in <a class="el" href="../../d0/de3/citelist.html#CITEREF_msch91a">[10]</a>, with reduction factor <code>delta</code>, block size <code>blocksize</code>, pruning parameter &lsquo;prune&rsquo;; see <a class="el" href="../../d0/de3/citelist.html#CITEREF_ilec22l">[7]</a>. </p>
<p>The other paraameters have the same meaning as in <code>redLLLNTL</code>. The parameter <code>blocksize</code> gives the size of the blocks in the BKZ reduction. Roughly, larger blocks means a stronger condition. A <code>blocksize</code> of 2 is equivalent to LLL reduction. </p>

</div>
</div>
<a id="ad31a58271ce3e94ccef239d05592ec53" name="ad31a58271ce3e94ccef239d05592ec53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad31a58271ce3e94ccef239d05592ec53">&#9670;&#160;</a></span>redBKZ() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redBKZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>blocksize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>prune</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="acc25c6590d71b62c3a9d598e6ffa5a4f" name="acc25c6590d71b62c3a9d598e6ffa5a4f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc25c6590d71b62c3a9d598e6ffa5a4f">&#9670;&#160;</a></span>redBKZ() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redBKZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>blocksize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>prune</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="ad62dafef6f1aae18d8d9a5a1846a13f7" name="ad62dafef6f1aae18d8d9a5a1846a13f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad62dafef6f1aae18d8d9a5a1846a13f7">&#9670;&#160;</a></span>redBKZ() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redBKZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>blocksize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>prune</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; NTL::RR &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a2070ad3e59569291798e297aee25dc" name="a1a2070ad3e59569291798e297aee25dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2070ad3e59569291798e297aee25dc">&#9670;&#160;</a></span>redBKZ() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redBKZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>blocksize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>prune</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; quad_float &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="af3e2c73995e28bf1faebc73e97e523c4" name="af3e2c73995e28bf1faebc73e97e523c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af3e2c73995e28bf1faebc73e97e523c4">&#9670;&#160;</a></span>redBKZ() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redBKZ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>blocksize</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>prune</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; xdouble &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a63dafe7fe191c17bcb7c178149db6570" name="a63dafe7fe191c17bcb7c178149db6570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63dafe7fe191c17bcb7c178149db6570">&#9670;&#160;</a></span>redLLL() <span class="overload">[1/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename RealVec &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redLLL </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.99999</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealVec *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This file provides only static functions to reduce a lattice basis in some ways (pairwise, LLL, BKZ <a class="el" href="../../d0/de3/citelist.html#CITEREF_rdie75a">[4]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_mlen82a">[9]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_msch91a">[10]</a>). </p>
<p>The LLL and BKZ ones are wrappers to slightly modified versions of the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> functions described at <a href="https://libntl.org/doc/LLL.cpp.html">https://libntl.org/doc/LLL.cpp.html</a> . These functions do not require the creation of an object like in <code><a class="el" href="../../d0/dea/classLatticeTester_1_1ReducerBB.html" title="This ReducerBB class provides facilities to reduce the basis of a lattice (an IntLattice object) in v...">ReducerBB</a></code>. They take an <code>IntMat</code> object that contains a basis and return the reduced basis in the same object. In our versions, the basis can occupy only part of the <code>IntMat</code> object so we can use the same object for several bases of various sizes, the basis entries can be of either ZZ or <code>int64_t</code> type, the shortest basis vector is always placed in the first row, and the squared vector lengths are also returned in a vector. The norm to measure the vector lengths is always taken as the Euclidean one. The computations can be done either in <code>double</code> or in <code>RR</code> for the real numbers.</p>
<p>All these functions take as input (and return as output) an <code>IntMat</code> object whose first <code>dim</code> rows and columns (a square matrix) are assumed to form be a set of independent vectors that form a basis for the lattice. The same <code>IntMat</code> object can then be used for several lattices of different sizes. This function uses the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> implementation of the LLL reduction algorithm with factor <code>delta</code>, presented in <a class="el" href="../../d0/de3/citelist.html#CITEREF_msch91a">[10]</a> (see also <a class="el" href="../../d0/de3/citelist.html#CITEREF_ilec22l">[7]</a>). The reduction is applied to the first <code>dim</code> basis vectors and coordinates when <code>dim &gt; 0</code>, and to the entire basis (all vectors) when <code>dim=0</code>. In the former case, the transformations are not applied to all the columns, so we will no longer have a consistent basis for the original lattice if it had more than <code>dim</code> dimensions. To recover a basis for the full lattice in this case, we may save it before calling this function, or rebuild it.</p>
<p>This function always uses the Euclidean norm. The factor <code>delta</code> must be between 1/2 and 1. The closer it is to 1, the more the basis is reduced, in the sense that the LLL algorithm will enforce tighter conditions on the basis. The returned basis always has its shortest vector in first place. The vector pointed by <code>sqlen</code> (if given) will contain the square lengths of the basis vectors. To recover these values in a <code>Vec&lt;double&gt; v</code> one can pass <code>&amp;v</code> to the function. The parameter <code>precision</code> specifies the precision of the floating point numbers that the algorithm will use. <code><a class="el" href="../../dd/d8f/EnumTypes_8h.html">EnumTypes.h</a></code> provides a list of the possible values, and their description is done in the module <code>LLL</code> of <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a>. </p>

</div>
</div>
<a id="a617ba189e7b633cbc81f08d3512bc3fb" name="a617ba189e7b633cbc81f08d3512bc3fb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a617ba189e7b633cbc81f08d3512bc3fb">&#9670;&#160;</a></span>redLLL() <span class="overload">[2/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename RealVec &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LatticeTester::redLLL </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.99999</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RealVec *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This file provides only static functions to reduce a lattice basis in some ways (pairwise, LLL, BKZ <a class="el" href="../../d0/de3/citelist.html#CITEREF_rdie75a">[4]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_mlen82a">[9]</a>, <a class="el" href="../../d0/de3/citelist.html#CITEREF_msch91a">[10]</a>). </p>
<p>The LLL and BKZ ones are wrappers to slightly modified versions of the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> functions described at <a href="https://libntl.org/doc/LLL.cpp.html">https://libntl.org/doc/LLL.cpp.html</a> . These functions do not require the creation of an object like in <code><a class="el" href="../../d0/dea/classLatticeTester_1_1ReducerBB.html" title="This ReducerBB class provides facilities to reduce the basis of a lattice (an IntLattice object) in v...">ReducerBB</a></code>. They take an <code>IntMat</code> object that contains a basis and return the reduced basis in the same object. In our versions, the basis can occupy only part of the <code>IntMat</code> object so we can use the same object for several bases of various sizes, the basis entries can be of either ZZ or <code>int64_t</code> type, the shortest basis vector is always placed in the first row, and the squared vector lengths are also returned in a vector. The norm to measure the vector lengths is always taken as the Euclidean one. The computations can be done either in <code>double</code> or in <code>RR</code> for the real numbers.</p>
<p>All these functions take as input (and return as output) an <code>IntMat</code> object whose first <code>dim</code> rows and columns (a square matrix) are assumed to form be a set of independent vectors that form a basis for the lattice. The same <code>IntMat</code> object can then be used for several lattices of different sizes. This function uses the <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> implementation of the LLL reduction algorithm with factor <code>delta</code>, presented in <a class="el" href="../../d0/de3/citelist.html#CITEREF_msch91a">[10]</a> (see also <a class="el" href="../../d0/de3/citelist.html#CITEREF_ilec22l">[7]</a>). The reduction is applied to the first <code>dim</code> basis vectors and coordinates when <code>dim &gt; 0</code>, and to the entire basis (all vectors) when <code>dim=0</code>. In the former case, the transformations are not applied to all the columns, so we will no longer have a consistent basis for the original lattice if it had more than <code>dim</code> dimensions. To recover a basis for the full lattice in this case, we may save it before calling this function, or rebuild it.</p>
<p>This function always uses the Euclidean norm. The factor <code>delta</code> must be between 1/2 and 1. The closer it is to 1, the more the basis is reduced, in the sense that the LLL algorithm will enforce tighter conditions on the basis. The returned basis always has its shortest vector in first place. The vector pointed by <code>sqlen</code> (if given) will contain the square lengths of the basis vectors. To recover these values in a <code>Vec&lt;double&gt; v</code> one can pass <code>&amp;v</code> to the function. The parameter <code>precision</code> specifies the precision of the floating point numbers that the algorithm will use. <code><a class="el" href="../../dd/d8f/EnumTypes_8h.html">EnumTypes.h</a></code> provides a list of the possible values, and their description is done in the module <code>LLL</code> of <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a>. </p>

</div>
</div>
<a id="a01966aadc118052152357ebbd4877051" name="a01966aadc118052152357ebbd4877051"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a01966aadc118052152357ebbd4877051">&#9670;&#160;</a></span>redLLL() <span class="overload">[3/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redLLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; int64_t &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a58fa2aa83677cc696e94fb373240313d" name="a58fa2aa83677cc696e94fb373240313d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58fa2aa83677cc696e94fb373240313d">&#9670;&#160;</a></span>redLLL() <span class="overload">[4/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redLLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; double &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7c9680e665446bbf600179b01a9eaf34" name="a7c9680e665446bbf600179b01a9eaf34"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c9680e665446bbf600179b01a9eaf34">&#9670;&#160;</a></span>redLLL() <span class="overload">[5/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redLLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; NTL::RR &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="afbf047233020d1da050275ed0df223ef" name="afbf047233020d1da050275ed0df223ef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afbf047233020d1da050275ed0df223ef">&#9670;&#160;</a></span>redLLL() <span class="overload">[6/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redLLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; quad_float &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a13ea3c4adefe9d6120ac4da1b8f4f554" name="a13ea3c4adefe9d6120ac4da1b8f4f554"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a13ea3c4adefe9d6120ac4da1b8f4f554">&#9670;&#160;</a></span>redLLL() <span class="overload">[7/7]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redLLL </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="../../d0/d01/classNTL_1_1vector.html">NTL::vector</a>&lt; xdouble &gt; *</td>          <td class="paramname"><span class="paramname"><em>sqlen</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a5830bb0fae462b5e85c8eeb1c126a647" name="a5830bb0fae462b5e85c8eeb1c126a647"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5830bb0fae462b5e85c8eeb1c126a647">&#9670;&#160;</a></span>redLLLExact() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redLLLExact </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.99999</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>This static function implements an exact algorithm from <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> to perform the original LLL reduction. </p>
<p>This is slower than <code>redLLLNTL</code>, but more accurate. It does not take the <code>dim</code> and <code>sqlen</code> parameters (for now). </p>

</div>
</div>
<a id="a9b34105ff26302078324b66592bbff4c" name="a9b34105ff26302078324b66592bbff4c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b34105ff26302078324b66592bbff4c">&#9670;&#160;</a></span>redLLLExact() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LatticeTester::redLLLExact </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0.99999</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>This static function implements an exact algorithm from <a class="el" href="../../d2/d5a/namespaceNTL.html" title="This module extends the Vec and Mat classes of NTL.">NTL</a> to perform the original LLL reduction. </p>
<p>This is slower than <code>redLLLNTL</code>, but more accurate. It does not take the <code>dim</code> and <code>sqlen</code> parameters (for now). </p>

</div>
</div>
<a id="ac9f2a630477cda7b6943b42949cd3123" name="ac9f2a630477cda7b6943b42949cd3123"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9f2a630477cda7b6943b42949cd3123">&#9670;&#160;</a></span>redLLLExact() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::redLLLExact </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d4/d6f/classNTL_1_1matrix.html">NTL::matrix</a>&lt; NTL::ZZ &gt; &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double</td>          <td class="paramname"><span class="paramname"><em>delta</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a15f15a1453b578cb49b2e3deda5a200d" name="a15f15a1453b578cb49b2e3deda5a200d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a15f15a1453b578cb49b2e3deda5a200d">&#9670;&#160;</a></span>Round()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">Real LatticeTester::Round </td>
          <td>(</td>
          <td class="paramtype">Real</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the value of x rounded to the NEAREST integer value. </p>
<p>(This does not truncate the integer value as is usual in computer arithmetic.) </p>

</div>
</div>
<a id="a1a68bc6b1e81a03d09ea07fa9efed658" name="a1a68bc6b1e81a03d09ea07fa9efed658"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a68bc6b1e81a03d09ea07fa9efed658">&#9670;&#160;</a></span>SetSeed()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetSeed </td>
          <td>(</td>
          <td class="paramtype">std::uint64_t</td>          <td class="paramname"><span class="paramname"><em>seed</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets the seed of the generator. </p>
<p>Because of the constraints on the state, <code>seed</code> has to be \( &gt; 2\). If this is never called, a default seed will be used. </p>

</div>
</div>
<a id="a2a728d56ee563237fe943ebd333fa3f5" name="a2a728d56ee563237fe943ebd333fa3f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2a728d56ee563237fe943ebd333fa3f5">&#9670;&#160;</a></span>SetValue()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetValue </td>
          <td>(</td>
          <td class="paramtype">Real *</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Real &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the first <code>d</code> components of <code>A</code> to 0. </p>
<p>Sets the first <code>d</code> components of <code>A</code> to the value <code>x</code>. </p>

</div>
</div>
<a id="aa42f9afe1397f5fba24397a495d995ff" name="aa42f9afe1397f5fba24397a495d995ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa42f9afe1397f5fba24397a495d995ff">&#9670;&#160;</a></span>SetZero() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Real &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetZero </td>
          <td>(</td>
          <td class="paramtype">Real *</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the first <code>d</code> of <code>A</code> to 0. </p>

</div>
</div>
<a id="afe6937cb95337e67ec106791e9b528c3" name="afe6937cb95337e67ec106791e9b528c3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afe6937cb95337e67ec106791e9b528c3">&#9670;&#160;</a></span>SetZero() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::SetZero </td>
          <td>(</td>
          <td class="paramtype">Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the first <code>d</code> components of <code>A</code> to 0. </p>

</div>
</div>
<a id="a59016f13e4470ad17683b1cfeb70153c" name="a59016f13e4470ad17683b1cfeb70153c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59016f13e4470ad17683b1cfeb70153c">&#9670;&#160;</a></span>sign()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">std::int64_t LatticeTester::sign </td>
          <td>(</td>
          <td class="paramtype">const T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the sign of <code>x</code>. </p>
<p>The sign is 1 if <code>x&gt;0</code>, 0 if <code>x==0</code> and -1 if <code>x&lt;0</code>. </p>

</div>
</div>
<a id="a345f61add88dc0bbda5acf7455bf514a" name="a345f61add88dc0bbda5acf7455bf514a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a345f61add88dc0bbda5acf7455bf514a">&#9670;&#160;</a></span>skip_any()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LatticeTester::skip_any </td>
          <td>(</td>
          <td class="paramtype">istream &amp;</td>          <td class="paramname"><span class="paramname"><em>is</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const string &amp;</td>          <td class="paramname"><span class="paramname"><em>characters</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper function to skip all characters of a given class. </p>

</div>
</div>
<a id="a37022f8ff5b0ea0a0245f4fd7e4c638b" name="a37022f8ff5b0ea0a0245f4fd7e4c638b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a37022f8ff5b0ea0a0245f4fd7e4c638b">&#9670;&#160;</a></span>sqrtReal() <span class="overload">[1/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">double LatticeTester::sqrtReal </td>
          <td>(</td>
          <td class="paramtype">const double &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af9165cbd4d3ce3c838d71db53cc6b1c6" name="af9165cbd4d3ce3c838d71db53cc6b1c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af9165cbd4d3ce3c838d71db53cc6b1c6">&#9670;&#160;</a></span>sqrtReal() <span class="overload">[2/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">NTL::RR LatticeTester::sqrtReal </td>
          <td>(</td>
          <td class="paramtype">const NTL::RR &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a7d6c03745f5fa960f80c30cc5602ea48" name="a7d6c03745f5fa960f80c30cc5602ea48"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d6c03745f5fa960f80c30cc5602ea48">&#9670;&#160;</a></span>sqrtReal() <span class="overload">[3/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">quad_float LatticeTester::sqrtReal </td>
          <td>(</td>
          <td class="paramtype">const quad_float &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a680ffe9b30c0ebef0aad50a5dbae7929" name="a680ffe9b30c0ebef0aad50a5dbae7929"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a680ffe9b30c0ebef0aad50a5dbae7929">&#9670;&#160;</a></span>sqrtReal() <span class="overload">[4/4]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">xdouble LatticeTester::sqrtReal </td>
          <td>(</td>
          <td class="paramtype">const xdouble &amp;</td>          <td class="paramname"><span class="paramname"><em>a</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ad4d16fed8fda92252dc423db28136932" name="ad4d16fed8fda92252dc423db28136932"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4d16fed8fda92252dc423db28136932">&#9670;&#160;</a></span>swap9()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::swap9 </td>
          <td>(</td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>x</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T &amp;</td>          <td class="paramname"><span class="paramname"><em>y</em></span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Takes references to two variables of a generic type and swaps their content. </p>
<p>This uses the assignment operator, so it might not always work well if this operator's implementation is not thorough. </p>

</div>
</div>
<a id="a6c4c9e2b77c4dc22c74401738c15c8b8" name="a6c4c9e2b77c4dc22c74401738c15c8b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6c4c9e2b77c4dc22c74401738c15c8b8">&#9670;&#160;</a></span>toStr()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename MatT &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toStr </td>
          <td>(</td>
          <td class="paramtype">const MatT &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d2</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>prec</em></span><span class="paramdefsep"> = </span><span class="paramdefval">2</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string that is a representation of <code>mat</code>. </p>
<p>This string represents the \(d1 \times d2\) submatrix of the first lines and columns of <code>mat</code>. </p>

</div>
</div>
<a id="a59f5c660b2fa0ddb257ebb31b219d451" name="a59f5c660b2fa0ddb257ebb31b219d451"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a59f5c660b2fa0ddb257ebb31b219d451">&#9670;&#160;</a></span>toString() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toString </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="../../d9/d32/classLatticeTester_1_1Chrono.html">Chrono</a> &amp;</td>          <td class="paramname"><span class="paramname"><em>timer</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the value of the duration from <code>timer</code>. </p>

</div>
</div>
<a id="ad18ba9347ad4166201654eb4ad5c6972" name="ad18ba9347ad4166201654eb4ad5c6972"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad18ba9347ad4166201654eb4ad5c6972">&#9670;&#160;</a></span>toString() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toString </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>c</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *</td>          <td class="paramname"><span class="paramname"><em>sep</em></span><span class="paramdefsep"> = </span><span class="paramdefval">&quot;&#160;&quot;</span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing <code>A[c]</code> to <code>A[d-1]</code> formated as <code>[A[c]sep...sepA[d-1]]</code>. </p>
<p>In this string, components are separated by string <code>sep</code>. By default, <code>sep</code> is just a whitespace character. </p>

</div>
</div>
<a id="a9c697e5d81b902cbb4283a21104ac62b" name="a9c697e5d81b902cbb4283a21104ac62b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9c697e5d81b902cbb4283a21104ac62b">&#9670;&#160;</a></span>toString() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Vect &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">std::string LatticeTester::toString </td>
          <td>(</td>
          <td class="paramtype">const Vect &amp;</td>          <td class="paramname"><span class="paramname"><em>A</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>d</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns a string containing the first <code>d</code> components of the vector <code>A</code> as a string. </p>
<p>Calls <code>toString(const Vect&amp;, int, int, const char*)</code>. </p>

</div>
</div>
<a id="a5fb8cd4f08931a89c70f756d0014b2b2" name="a5fb8cd4f08931a89c70f756d0014b2b2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5fb8cd4f08931a89c70f756d0014b2b2">&#9670;&#160;</a></span>toStringCalc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string LatticeTester::toStringCalc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a0d2f9ab69a9d586b8273cbb29bb105fe">CalcType</a></td>          <td class="paramname"><span class="paramname"><em>calc</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a9d14b2942fa515f0e72edfcb4243781c" name="a9d14b2942fa515f0e72edfcb4243781c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9d14b2942fa515f0e72edfcb4243781c">&#9670;&#160;</a></span>toStringCriterion()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string LatticeTester::toStringCriterion </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a2cf3c4f4181718b7adc6f5e4513695a0">CriterionType</a></td>          <td class="paramname"><span class="paramname"><em>criter</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a21f1a550ff7e4344554a043faceb7c55" name="a21f1a550ff7e4344554a043faceb7c55"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a21f1a550ff7e4344554a043faceb7c55">&#9670;&#160;</a></span>toStringDecomp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string LatticeTester::toStringDecomp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a5bf461b8f167cc8c7ebebc8ee6a96ee4">DecompTypeBB</a></td>          <td class="paramname"><span class="paramname"><em>decomp</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1a2fb1307d0863e4d38a3b813b180014" name="a1a2fb1307d0863e4d38a3b813b180014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a2fb1307d0863e4d38a3b813b180014">&#9670;&#160;</a></span>toStringMeritType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string LatticeTester::toStringMeritType </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a5e9e347d07097a1a3c82f1699ff93d58">MeritType</a></td>          <td class="paramname"><span class="paramname"><em>merit</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="af65fc07f34906524398b038327a0bb14" name="af65fc07f34906524398b038327a0bb14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af65fc07f34906524398b038327a0bb14">&#9670;&#160;</a></span>toStringNorm()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string LatticeTester::toStringNorm </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9770e4d57aa715e249cd7e700c6f37e4">NormType</a></td>          <td class="paramname"><span class="paramname"><em>norm</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>The following are functions for printing the <code>enum</code> constants in this module. </p>
<p>Each function returns the value of the <code>enum</code> variable given as input as a string. </p>

</div>
</div>
<a id="ac24879d5aa087958f258e3a9e3770d37" name="ac24879d5aa087958f258e3a9e3770d37"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac24879d5aa087958f258e3a9e3770d37">&#9670;&#160;</a></span>toStringNorma()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string LatticeTester::toStringNorma </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ab747c1cbb0f5e47fef711b62327a8e90">NormaType</a></td>          <td class="paramname"><span class="paramname"><em>norma</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a059f8e56d24041008c87a70625e70ba9" name="a059f8e56d24041008c87a70625e70ba9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a059f8e56d24041008c87a70625e70ba9">&#9670;&#160;</a></span>toStringOutput()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string LatticeTester::toStringOutput </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#ad78f099c800f4c648134967a45b91058">OutputType</a></td>          <td class="paramname"><span class="paramname"><em>out</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a70e26765f6794f995a8130fecc030ca7" name="a70e26765f6794f995a8130fecc030ca7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70e26765f6794f995a8130fecc030ca7">&#9670;&#160;</a></span>toStringPrecision()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string LatticeTester::toStringPrecision </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a94f96ff406f8b56147a2b7fd96209cb2">PrecisionType</a></td>          <td class="paramname"><span class="paramname"><em>precision</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="ac6567b0759b046c6deeea98a1c9f4235" name="ac6567b0759b046c6deeea98a1c9f4235"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac6567b0759b046c6deeea98a1c9f4235">&#9670;&#160;</a></span>toStringPrime()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string LatticeTester::toStringPrime </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a9b64954fb374b16e1fe991e435501d65">PrimeType</a></td>          <td class="paramname"><span class="paramname"><em>prim</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a07260b18b588fe14165b0ea411934bbd" name="a07260b18b588fe14165b0ea411934bbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a07260b18b588fe14165b0ea411934bbd">&#9670;&#160;</a></span>toStringProblem()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string LatticeTester::toStringProblem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#aad7b917d5ef7e8167bc50aa56109faff">ProblemType</a></td>          <td class="paramname"><span class="paramname"><em>prob</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a12e050957b719073c06de41c7486f1ce" name="a12e050957b719073c06de41c7486f1ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a12e050957b719073c06de41c7486f1ce">&#9670;&#160;</a></span>toStringProjConstruct()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string LatticeTester::toStringProjConstruct </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#a1ff6c9ee29ca0bac6c63d2622508aa46">ProjConstructType</a></td>          <td class="paramname"><span class="paramname"><em>proj</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a137cd194ce614d43c80f65557ee96109" name="a137cd194ce614d43c80f65557ee96109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a137cd194ce614d43c80f65557ee96109">&#9670;&#160;</a></span>toStringReduction()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::string LatticeTester::toStringReduction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="#af2a213e64bd54d3e33a7aff0f80068cb">ReductionType</a></td>          <td class="paramname"><span class="paramname"><em>reduct</em></span></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="aaa2f58453cd5cd239b67d0eb92b3dadf" name="aaa2f58453cd5cd239b67d0eb92b3dadf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaa2f58453cd5cd239b67d0eb92b3dadf">&#9670;&#160;</a></span>TransposeMatrix()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::TransposeMatrix </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>mat</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>mat2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a set of generating vectors in the matrix <code>mat</code> and iteratively transforms it into an upper triangular lattice basis into the matrix <code>mat2</code>. </p>
<p><code>mat</code> and <code>mat2</code> have to have the same number of rows and the same number of columns. All the computations will be done modulo <code>mod</code>, which means that you must know the rescaling factor for the vector system to call this function. After the execution, <code>mat</code> will be a matrix containing irrelevant information and <code>mat2</code> will contain an upper triangular basis.</p>
<p>For more details please look at <b>[latTesterGide]</b>. This algorithm basically implements what is written in this guide. The matrix <code>mat</code> contains the set of vectors that is used and modified at each step to get a new vector from the basis. Lower triangularization </p>

</div>
</div>
<a id="a525c1afc0f42bff5922cdc947aafe142" name="a525c1afc0f42bff5922cdc947aafe142"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a525c1afc0f42bff5922cdc947aafe142">&#9670;&#160;</a></span>Triangularization()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename Matr , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::Triangularization </td>
          <td>(</td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>W</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Matr &amp;</td>          <td class="paramname"><span class="paramname"><em>V</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>lin</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int64_t</td>          <td class="paramname"><span class="paramname"><em>col</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Takes a set of generating vectors in the matrix <code>W</code> and iteratively transforms it into an upper triangular lattice basis into the matrix <code>V</code>. </p>
<p><code>W</code> and <code>V</code> have to have more rows than <code>lin</code> and more columns than <code>col</code> since this algorithm will only operate on the upper <code>lin*col</code> matrix of <code>W</code>. All the computations will be done modulo <code>m</code>, which means that you must know the rescaling factor for the vector system to call this function. After the execution, <code>W</code> will be a matrix containing irrelevant information and <code>V</code> will contain an upper triangular basis.</p>
<p>For more details please look at <a class="el" href="../../d0/de3/citelist.html#CITEREF_rcou96a">[3]</a>. This algorithm basically implements what is written at the end of the article, that is the matrix <code>W</code> contains the set of vectors that is used and modified at each step to get a new vector from the basis. </p>

</div>
</div>
<a id="a6b5a16cceddb84cf6ee280cc6d0e7281" name="a6b5a16cceddb84cf6ee280cc6d0e7281"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6b5a16cceddb84cf6ee280cc6d0e7281">&#9670;&#160;</a></span>upperTriangularBasis() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void LatticeTester::upperTriangularBasis </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim1</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>dim2</em></span>&#160;)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Same as <code>lowerTriangularBasis</code>, except that the returned basis is upper triangular. </p>

</div>
</div>
<a id="a03944f3ab46d31e7574872bcfaad6956" name="a03944f3ab46d31e7574872bcfaad6956"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03944f3ab46d31e7574872bcfaad6956">&#9670;&#160;</a></span>upperTriangularBasis() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename IntMat , typename Int &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void LatticeTester::upperTriangularBasis </td>
          <td>(</td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>gen</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">IntMat &amp;</td>          <td class="paramname"><span class="paramname"><em>basis</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const Int &amp;</td>          <td class="paramname"><span class="paramname"><em>m</em></span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>r</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">long</td>          <td class="paramname"><span class="paramname"><em>c</em></span><span class="paramdefsep"> = </span><span class="paramdefval">0</span>&#160;)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Same as <code>lowerTriangularBasis</code>, except that the returned basis is upper triangular. </p>

</div>
</div>
<h2 class="groupheader">Variable Documentation</h2>
<a id="ac9adbd421a1148216c8eac1b7d96a5b8" name="ac9adbd421a1148216c8eac1b7d96a5b8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9adbd421a1148216c8eac1b7d96a5b8">&#9670;&#160;</a></span>MAX_LONG_DOUBLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const double LatticeTester::MAX_LONG_DOUBLE = 9007199254740992.0</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Maximum integer that can be represented exactly as a <code>double</code>: \(2^{53}\). </p>

</div>
</div>
<a id="ae540464b3215755b9a0ba65ebfba38f8" name="ae540464b3215755b9a0ba65ebfba38f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae540464b3215755b9a0ba65ebfba38f8">&#9670;&#160;</a></span>TWO_EXP</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const std::int64_t LatticeTester::TWO_EXP</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Initial value:</b><div class="fragment"><div class="line">= {</div>
<div class="line">    1, 2, 4, 8, 16, 32, 64, 128, 256, 512, 1024, 2048, 4096, 8192, 16384, 32768,</div>
<div class="line">    65536, 131072, 262144, 524288, 1048576, 2097152, 4194304, 8388608, 16777216,</div>
<div class="line">    33554432, 67108864, 134217728, 268435456, 536870912, 1073741824, 2147483648,</div>
<div class="line">    4294967296, 8589934592, 17179869184, 34359738368, 68719476736, 137438953472,</div>
<div class="line">    274877906944, 549755813888, 1099511627776, 2199023255552, 4398046511104,</div>
<div class="line">    8796093022208, 17592186044416, 35184372088832, 70368744177664,</div>
<div class="line">    140737488355328, 281474976710656, 562949953421312, 1125899906842624,</div>
<div class="line">    2251799813685248, 4503599627370496, 9007199254740992, 18014398509481984,</div>
<div class="line">    36028797018963968, 72057594037927936, 144115188075855872, 288230376151711744,</div>
<div class="line">    576460752303423488, 1152921504606846976, 2305843009213693952,</div>
<div class="line">    (std::int64_t)4611686018427387904U, (std::int64_t)9223372036854775808U }</div>
</div><!-- fragment -->
<p>Table of powers of 2: <code>TWO_EXP[</code> \(i\)<code>]</code> \(= 2^i\), \(i=0, 1, …, 63\). </p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.15-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <a href="https://github.com/umontreal-simul/latticetester">Available on Github</a>
    <li class="navelem"><a class="el" href="../../d8/d74/namespaceLatticeTester.html">LatticeTester</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="../../doxygen.png" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
